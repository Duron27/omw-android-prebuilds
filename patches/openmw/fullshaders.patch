From a7c29c99bfb0b842ffdefbfba3e1264b1ff77085 Mon Sep 17 00:00:00 2001
From: Duron27 <duron27@gmail.com>
Date: Thu, 15 Feb 2024 23:30:38 -0500
Subject: [PATCH] fixed sisahs patches for newest commit

yep
---
 apps/navmeshtool/CMakeLists.txt               |    2 +-
 apps/navmeshtool/main.cpp                     |    8 +-
 apps/navmeshtool/main.cpp.orig                |  260 +++
 apps/navmeshtool/navmesh.cpp                  |    3 +
 apps/navmeshtool/navmesh.hpp                  |    2 +
 apps/openmw/CMakeLists.txt                    |    4 +
 apps/openmw/engine.cpp                        |    3 +
 apps/openmw/main.cpp                          |   14 +
 apps/openmw/mwrender/luminancecalculator.cpp  |    4 +-
 apps/openmw/mwrender/npcanimation.cpp         |    2 +-
 apps/openmw/mwrender/postprocessor.cpp        |    6 +-
 apps/openmw/mwrender/postprocessor.cpp.orig   |  840 ++++++++
 apps/openmw/mwrender/renderingmanager.cpp     |    4 +-
 .../openmw/mwrender/renderingmanager.cpp.orig | 1767 +++++++++++++++++
 apps/openmw/mwrender/transparentpass.cpp      |    7 +-
 apps/openmw/mwrender/water.cpp                |   10 +-
 apps/openmw/mwrender/water.cpp.orig           |  907 +++++++++
 components/debug/debugging.cpp                |    2 +
 components/fx/parse_constants.hpp             |    5 +-
 components/fx/pass.cpp                        |    2 +-
 components/settings/categories/water.hpp      |    1 +
 components/shader/shadervisitor.cpp           |   10 +
 files/data/l10n/OMWEngine/en.yaml             |    1 +
 files/data/l10n/OMWEngine/en.yaml.orig        |  180 ++
 .../data/mygui/openmw_settings_window.layout  |   14 +
 .../mygui/openmw_settings_window.layout.orig  |  729 +++++++
 files/data/shaders/bloomlinear.omwfx          |   10 +-
 files/settings-default.cfg                    |    3 +
 files/settings-default.cfg.orig               | 1267 ++++++++++++
 files/shaders/CMakeLists.txt                  |    1 +
 files/shaders/compatibility/bs/default.frag   |    2 +-
 files/shaders/compatibility/bs/default.vert   |    2 +-
 .../shaders/compatibility/bs/nolighting.frag  |    0
 .../shaders/compatibility/bs/nolighting.vert  |    2 +-
 files/shaders/compatibility/debug.frag        |    2 +-
 files/shaders/compatibility/debug.vert        |    2 +-
 files/shaders/compatibility/depthclipped.frag |    0
 files/shaders/compatibility/depthclipped.vert |    0
 files/shaders/compatibility/fog.glsl          |    0
 .../shaders/compatibility/fullscreen_tri.frag |    0
 .../shaders/compatibility/fullscreen_tri.vert |    2 +-
 files/shaders/compatibility/groundcover.frag  |    0
 files/shaders/compatibility/groundcover.vert  |    2 +-
 files/shaders/compatibility/gui.frag          |    0
 files/shaders/compatibility/gui.vert          |    0
 .../compatibility/luminance/luminance.frag    |    0
 .../compatibility/luminance/resolve.frag      |    0
 .../compatibility/multiview_resolve.frag      |    0
 .../compatibility/multiview_resolve.vert      |    0
 files/shaders/compatibility/normals.glsl      |    0
 files/shaders/compatibility/objects.frag      |    8 +-
 files/shaders/compatibility/objects.vert      |    2 +-
 .../compatibility/ripples_blobber.frag        |    0
 .../compatibility/ripples_simulate.frag       |    0
 files/shaders/compatibility/s360.frag         |    0
 files/shaders/compatibility/s360.vert         |    0
 .../shaders/compatibility/shadowcasting.frag  |    0
 .../shaders/compatibility/shadowcasting.vert  |    0
 .../compatibility/shadows_fragment.glsl       |    0
 .../shaders/compatibility/shadows_vertex.glsl |    0
 files/shaders/compatibility/sky.frag          |    0
 files/shaders/compatibility/sky.vert          |    0
 files/shaders/compatibility/terrain.frag      |    2 +-
 files/shaders/compatibility/terrain.vert      |    2 +-
 files/shaders/compatibility/vertexcolors.glsl |    0
 files/shaders/compatibility/water.frag        |   30 +-
 files/shaders/compatibility/water.frag.orig   |  255 +++
 files/shaders/compatibility/water.vert        |    0
 files/shaders/core/gui.frag                   |    0
 files/shaders/core/gui.vert                   |    0
 files/shaders/core/ripples_blobber.comp       |    0
 files/shaders/core/ripples_simulate.comp      |    0
 files/shaders/lib/core/fragment.glsl          |    0
 .../shaders/lib/core/fragment_multiview.glsl  |    0
 files/shaders/lib/core/vertex.glsl            |    0
 files/shaders/lib/core/vertex.h.glsl          |   20 +-
 files/shaders/lib/core/vertex_multiview.glsl  |    0
 files/shaders/lib/light/lighting.glsl         |    0
 files/shaders/lib/light/lighting_util.glsl    |    0
 files/shaders/lib/luminance/constants.glsl    |    0
 files/shaders/lib/material/alpha.glsl         |    0
 files/shaders/lib/material/parallax.glsl      |    0
 files/shaders/lib/particle/occlusion.glsl     |    0
 files/shaders/lib/particle/soft.glsl          |    0
 files/shaders/lib/sky/passes.glsl             |    0
 files/shaders/lib/util/coordinates.glsl       |    0
 files/shaders/lib/util/distortion.glsl        |    0
 files/shaders/lib/util/quickstep.glsl         |    0
 files/shaders/lib/view/depth.glsl             |    0
 files/shaders/lib/water/fresnel.glsl          |    0
 files/shaders/lib/water/rain_ripples.glsl     |    0
 files/shaders/lib/water/rain_ripples_old.glsl |  126 ++
 files/shaders/lib/water/ripples.glsl          |    0
 93 files changed, 6461 insertions(+), 66 deletions(-)
 create mode 100644 apps/navmeshtool/main.cpp.orig
 create mode 100644 apps/openmw/mwrender/postprocessor.cpp.orig
 create mode 100644 apps/openmw/mwrender/renderingmanager.cpp.orig
 create mode 100644 apps/openmw/mwrender/water.cpp.orig
 create mode 100644 files/data/l10n/OMWEngine/en.yaml.orig
 create mode 100644 files/data/mygui/openmw_settings_window.layout.orig
 mode change 100644 => 100755 files/data/shaders/bloomlinear.omwfx
 create mode 100644 files/settings-default.cfg.orig
 mode change 100644 => 100755 files/shaders/compatibility/bs/default.frag
 mode change 100644 => 100755 files/shaders/compatibility/bs/default.vert
 mode change 100644 => 100755 files/shaders/compatibility/bs/nolighting.frag
 mode change 100644 => 100755 files/shaders/compatibility/bs/nolighting.vert
 mode change 100644 => 100755 files/shaders/compatibility/debug.frag
 mode change 100644 => 100755 files/shaders/compatibility/debug.vert
 mode change 100644 => 100755 files/shaders/compatibility/depthclipped.frag
 mode change 100644 => 100755 files/shaders/compatibility/depthclipped.vert
 mode change 100644 => 100755 files/shaders/compatibility/fog.glsl
 mode change 100644 => 100755 files/shaders/compatibility/fullscreen_tri.frag
 mode change 100644 => 100755 files/shaders/compatibility/fullscreen_tri.vert
 mode change 100644 => 100755 files/shaders/compatibility/groundcover.frag
 mode change 100644 => 100755 files/shaders/compatibility/groundcover.vert
 mode change 100644 => 100755 files/shaders/compatibility/gui.frag
 mode change 100644 => 100755 files/shaders/compatibility/gui.vert
 mode change 100644 => 100755 files/shaders/compatibility/luminance/luminance.frag
 mode change 100644 => 100755 files/shaders/compatibility/luminance/resolve.frag
 mode change 100644 => 100755 files/shaders/compatibility/multiview_resolve.frag
 mode change 100644 => 100755 files/shaders/compatibility/multiview_resolve.vert
 mode change 100644 => 100755 files/shaders/compatibility/normals.glsl
 mode change 100644 => 100755 files/shaders/compatibility/objects.frag
 mode change 100644 => 100755 files/shaders/compatibility/objects.vert
 mode change 100644 => 100755 files/shaders/compatibility/ripples_blobber.frag
 mode change 100644 => 100755 files/shaders/compatibility/ripples_simulate.frag
 mode change 100644 => 100755 files/shaders/compatibility/s360.frag
 mode change 100644 => 100755 files/shaders/compatibility/s360.vert
 mode change 100644 => 100755 files/shaders/compatibility/shadowcasting.frag
 mode change 100644 => 100755 files/shaders/compatibility/shadowcasting.vert
 mode change 100644 => 100755 files/shaders/compatibility/shadows_fragment.glsl
 mode change 100644 => 100755 files/shaders/compatibility/shadows_vertex.glsl
 mode change 100644 => 100755 files/shaders/compatibility/sky.frag
 mode change 100644 => 100755 files/shaders/compatibility/sky.vert
 mode change 100644 => 100755 files/shaders/compatibility/terrain.frag
 mode change 100644 => 100755 files/shaders/compatibility/terrain.vert
 mode change 100644 => 100755 files/shaders/compatibility/vertexcolors.glsl
 mode change 100644 => 100755 files/shaders/compatibility/water.frag
 create mode 100755 files/shaders/compatibility/water.frag.orig
 mode change 100644 => 100755 files/shaders/compatibility/water.vert
 mode change 100644 => 100755 files/shaders/core/gui.frag
 mode change 100644 => 100755 files/shaders/core/gui.vert
 mode change 100644 => 100755 files/shaders/core/ripples_blobber.comp
 mode change 100644 => 100755 files/shaders/core/ripples_simulate.comp
 mode change 100644 => 100755 files/shaders/lib/core/fragment.glsl
 mode change 100644 => 100755 files/shaders/lib/core/fragment_multiview.glsl
 mode change 100644 => 100755 files/shaders/lib/core/vertex.glsl
 mode change 100644 => 100755 files/shaders/lib/core/vertex.h.glsl
 mode change 100644 => 100755 files/shaders/lib/core/vertex_multiview.glsl
 mode change 100644 => 100755 files/shaders/lib/light/lighting.glsl
 mode change 100644 => 100755 files/shaders/lib/light/lighting_util.glsl
 mode change 100644 => 100755 files/shaders/lib/luminance/constants.glsl
 mode change 100644 => 100755 files/shaders/lib/material/alpha.glsl
 mode change 100644 => 100755 files/shaders/lib/material/parallax.glsl
 mode change 100644 => 100755 files/shaders/lib/particle/occlusion.glsl
 mode change 100644 => 100755 files/shaders/lib/particle/soft.glsl
 mode change 100644 => 100755 files/shaders/lib/sky/passes.glsl
 mode change 100644 => 100755 files/shaders/lib/util/coordinates.glsl
 mode change 100644 => 100755 files/shaders/lib/util/distortion.glsl
 mode change 100644 => 100755 files/shaders/lib/util/quickstep.glsl
 mode change 100644 => 100755 files/shaders/lib/view/depth.glsl
 mode change 100644 => 100755 files/shaders/lib/water/fresnel.glsl
 mode change 100644 => 100755 files/shaders/lib/water/rain_ripples.glsl
 create mode 100755 files/shaders/lib/water/rain_ripples_old.glsl
 mode change 100644 => 100755 files/shaders/lib/water/ripples.glsl

diff --git a/apps/navmeshtool/CMakeLists.txt b/apps/navmeshtool/CMakeLists.txt
index 9abd8dc2833..35264ae55ce 100644
--- a/apps/navmeshtool/CMakeLists.txt
+++ b/apps/navmeshtool/CMakeLists.txt
@@ -5,7 +5,7 @@ set(NAVMESHTOOL
 )
 source_group(apps\\navmeshtool FILES ${NAVMESHTOOL})
 
-openmw_add_executable(openmw-navmeshtool ${NAVMESHTOOL})
+add_library(openmw-navmeshtool SHARED ${NAVMESHTOOL})
 
 target_link_libraries(openmw-navmeshtool
     ${Boost_PROGRAM_OPTIONS_LIBRARY}
diff --git a/apps/navmeshtool/main.cpp b/apps/navmeshtool/main.cpp
index 3ec34114afb..4095064d47e 100644
--- a/apps/navmeshtool/main.cpp
+++ b/apps/navmeshtool/main.cpp
@@ -51,8 +51,8 @@
 
 namespace NavMeshTool
 {
-    namespace
-    {
+//    namespace
+//    {
         namespace bpo = boost::program_options;
 
         using StringsVector = std::vector<std::string>;
@@ -251,10 +251,12 @@ namespace NavMeshTool
 
             return 0;
         }
-    }
+//    }
 }
 
+/*
 int main(int argc, char* argv[])
 {
     return wrapApplication(NavMeshTool::runNavMeshTool, argc, argv, NavMeshTool::applicationName);
 }
+*/
diff --git a/apps/navmeshtool/main.cpp.orig b/apps/navmeshtool/main.cpp.orig
new file mode 100644
index 00000000000..3ec34114afb
--- /dev/null
+++ b/apps/navmeshtool/main.cpp.orig
@@ -0,0 +1,260 @@
+#include "navmesh.hpp"
+#include "worldspacedata.hpp"
+
+#include <components/debug/debugging.hpp>
+#include <components/debug/debuglog.hpp>
+#include <components/detournavigator/agentbounds.hpp>
+#include <components/detournavigator/collisionshapetype.hpp>
+#include <components/detournavigator/navmeshdb.hpp>
+#include <components/detournavigator/recastglobalallocator.hpp>
+#include <components/detournavigator/settings.hpp>
+#include <components/esm3/readerscache.hpp>
+#include <components/esm3/variant.hpp>
+#include <components/esmloader/esmdata.hpp>
+#include <components/esmloader/load.hpp>
+#include <components/fallback/fallback.hpp>
+#include <components/fallback/validate.hpp>
+#include <components/files/collections.hpp>
+#include <components/files/configurationmanager.hpp>
+#include <components/files/conversion.hpp>
+#include <components/files/multidircollection.hpp>
+#include <components/platform/platform.hpp>
+#include <components/resource/bulletshapemanager.hpp>
+#include <components/resource/imagemanager.hpp>
+#include <components/resource/niffilemanager.hpp>
+#include <components/resource/scenemanager.hpp>
+#include <components/settings/values.hpp>
+#include <components/to_utf8/to_utf8.hpp>
+#include <components/version/version.hpp>
+#include <components/vfs/manager.hpp>
+#include <components/vfs/registerarchives.hpp>
+
+#include <osg/Vec3f>
+
+#include <boost/program_options.hpp>
+
+#include <cstddef>
+#include <cstdint>
+#include <filesystem>
+#include <iostream>
+#include <map>
+#include <string>
+#include <thread>
+#include <type_traits>
+#include <utility>
+#include <vector>
+
+#ifdef WIN32
+#include <fcntl.h>
+#include <io.h>
+#endif
+
+namespace NavMeshTool
+{
+    namespace
+    {
+        namespace bpo = boost::program_options;
+
+        using StringsVector = std::vector<std::string>;
+
+        constexpr std::string_view applicationName = "NavMeshTool";
+
+        bpo::options_description makeOptionsDescription()
+        {
+            using Fallback::FallbackMap;
+
+            bpo::options_description result;
+            auto addOption = result.add_options();
+            addOption("help", "print help message");
+
+            addOption("version", "print version information and quit");
+
+            addOption("data",
+                bpo::value<Files::MaybeQuotedPathContainer>()
+                    ->default_value(Files::MaybeQuotedPathContainer(), "data")
+                    ->multitoken()
+                    ->composing(),
+                "set data directories (later directories have higher priority)");
+
+            addOption("data-local",
+                bpo::value<Files::MaybeQuotedPathContainer::value_type>()->default_value(
+                    Files::MaybeQuotedPathContainer::value_type(), ""),
+                "set local data directory (highest priority)");
+
+            addOption("fallback-archive",
+                bpo::value<StringsVector>()
+                    ->default_value(StringsVector(), "fallback-archive")
+                    ->multitoken()
+                    ->composing(),
+                "set fallback BSA archives (later archives have higher priority)");
+
+            addOption("content",
+                bpo::value<StringsVector>()->default_value(StringsVector(), "")->multitoken()->composing(),
+                "content file(s): esm/esp, or omwgame/omwaddon/omwscripts");
+
+            addOption("encoding", bpo::value<std::string>()->default_value("win1252"),
+                "Character encoding used in OpenMW game messages:\n"
+                "\n\twin1250 - Central and Eastern European such as Polish, Czech, Slovak, Hungarian, Slovene, "
+                "Bosnian, Croatian, Serbian (Latin script), Romanian and Albanian languages\n"
+                "\n\twin1251 - Cyrillic alphabet such as Russian, Bulgarian, Serbian Cyrillic and other languages\n"
+                "\n\twin1252 - Western European (Latin) alphabet, used by default");
+
+            addOption("fallback",
+                bpo::value<Fallback::FallbackMap>()
+                    ->default_value(Fallback::FallbackMap(), "")
+                    ->multitoken()
+                    ->composing(),
+                "fallback values");
+
+            addOption("threads",
+                bpo::value<std::size_t>()->default_value(
+                    std::max<std::size_t>(std::thread::hardware_concurrency() - 1, 1)),
+                "number of threads for parallel processing");
+
+            addOption("process-interior-cells", bpo::value<bool>()->implicit_value(true)->default_value(false),
+                "build navmesh for interior cells");
+
+            addOption("remove-unused-tiles", bpo::value<bool>()->implicit_value(true)->default_value(false),
+                "remove tiles from cache that will not be used with current content profile");
+
+            addOption("write-binary-log", bpo::value<bool>()->implicit_value(true)->default_value(false),
+                "write progress in binary messages to be consumed by the launcher");
+
+            Files::ConfigurationManager::addCommonOptions(result);
+
+            return result;
+        }
+
+        int runNavMeshTool(int argc, char* argv[])
+        {
+            Platform::init();
+
+            bpo::options_description desc = makeOptionsDescription();
+
+            bpo::parsed_options options = bpo::command_line_parser(argc, argv).options(desc).allow_unregistered().run();
+            bpo::variables_map variables;
+
+            bpo::store(options, variables);
+            bpo::notify(variables);
+
+            if (variables.find("help") != variables.end())
+            {
+                getRawStdout() << desc << std::endl;
+                return 0;
+            }
+
+            Files::ConfigurationManager config;
+            config.readConfiguration(variables, desc);
+
+            setupLogging(config.getLogPath(), applicationName);
+
+            const std::string encoding(variables["encoding"].as<std::string>());
+            Log(Debug::Info) << ToUTF8::encodingUsingMessage(encoding);
+            ToUTF8::Utf8Encoder encoder(ToUTF8::calculateEncoding(encoding));
+
+            Files::PathContainer dataDirs(asPathContainer(variables["data"].as<Files::MaybeQuotedPathContainer>()));
+
+            auto local = variables["data-local"].as<Files::MaybeQuotedPathContainer::value_type>();
+            if (!local.empty())
+                dataDirs.push_back(std::move(local));
+
+            config.filterOutNonExistingPaths(dataDirs);
+
+            const auto& resDir = variables["resources"].as<Files::MaybeQuotedPath>();
+            Log(Debug::Info) << Version::getOpenmwVersionDescription();
+            dataDirs.insert(dataDirs.begin(), resDir / "vfs");
+            const Files::Collections fileCollections(dataDirs);
+            const auto& archives = variables["fallback-archive"].as<StringsVector>();
+            const auto& contentFiles = variables["content"].as<StringsVector>();
+            const std::size_t threadsNumber = variables["threads"].as<std::size_t>();
+
+            if (threadsNumber < 1)
+            {
+                std::cerr << "Invalid threads number: " << threadsNumber << ", expected >= 1";
+                return -1;
+            }
+
+            const bool processInteriorCells = variables["process-interior-cells"].as<bool>();
+            const bool removeUnusedTiles = variables["remove-unused-tiles"].as<bool>();
+            const bool writeBinaryLog = variables["write-binary-log"].as<bool>();
+
+#ifdef WIN32
+            if (writeBinaryLog)
+                _setmode(_fileno(stderr), _O_BINARY);
+#endif
+
+            Fallback::Map::init(variables["fallback"].as<Fallback::FallbackMap>().mMap);
+
+            VFS::Manager vfs;
+
+            VFS::registerArchives(&vfs, fileCollections, archives, true);
+
+            Settings::Manager::load(config);
+
+            const DetourNavigator::AgentBounds agentBounds{
+                Settings::game().mActorCollisionShapeType,
+                Settings::game().mDefaultActorPathfindHalfExtents,
+            };
+            const std::uint64_t maxDbFileSize = Settings::navigator().mMaxNavmeshdbFileSize;
+            const auto dbPath = Files::pathToUnicodeString(config.getUserDataPath() / "navmesh.db");
+
+            Log(Debug::Info) << "Using navmeshdb at " << dbPath;
+
+            DetourNavigator::NavMeshDb db(dbPath, maxDbFileSize);
+
+            ESM::ReadersCache readers;
+            EsmLoader::Query query;
+            query.mLoadActivators = true;
+            query.mLoadCells = true;
+            query.mLoadContainers = true;
+            query.mLoadDoors = true;
+            query.mLoadGameSettings = true;
+            query.mLoadLands = true;
+            query.mLoadStatics = true;
+            const EsmLoader::EsmData esmData
+                = EsmLoader::loadEsmData(query, contentFiles, fileCollections, readers, &encoder);
+
+            constexpr double expiryDelay = 0;
+
+            Resource::ImageManager imageManager(&vfs, expiryDelay);
+            Resource::NifFileManager nifFileManager(&vfs, &encoder.getStatelessEncoder());
+            Resource::SceneManager sceneManager(&vfs, &imageManager, &nifFileManager, expiryDelay);
+            Resource::BulletShapeManager bulletShapeManager(&vfs, &sceneManager, &nifFileManager, expiryDelay);
+            DetourNavigator::RecastGlobalAllocator::init();
+            DetourNavigator::Settings navigatorSettings = DetourNavigator::makeSettingsFromSettingsManager();
+            navigatorSettings.mRecast.mSwimHeightScale
+                = EsmLoader::getGameSetting(esmData.mGameSettings, "fSwimHeightScale").getFloat();
+
+            WorldspaceData cellsData = gatherWorldspaceData(
+                navigatorSettings, readers, vfs, bulletShapeManager, esmData, processInteriorCells, writeBinaryLog);
+
+            const Status status = generateAllNavMeshTiles(agentBounds, navigatorSettings, threadsNumber,
+                removeUnusedTiles, writeBinaryLog, cellsData, std::move(db));
+
+            switch (status)
+            {
+                case Status::Ok:
+                    Log(Debug::Info) << "Done";
+                    break;
+                case Status::Cancelled:
+                    Log(Debug::Warning) << "Cancelled";
+                    break;
+                case Status::NotEnoughSpace:
+                    Log(Debug::Warning)
+                        << "Navmesh generation is cancelled due to running out of disk space or limits "
+                        << "for navmesh db. Check disk space at the db location \"" << dbPath
+                        << "\". If there is enough space, adjust \"max navmeshdb file size\" setting (see "
+                        << "https://openmw.readthedocs.io/en/latest/reference/modding/settings/"
+                           "navigator.html?highlight=navmesh#max-navmeshdb-file-size).";
+                    break;
+            }
+
+            return 0;
+        }
+    }
+}
+
+int main(int argc, char* argv[])
+{
+    return wrapApplication(NavMeshTool::runNavMeshTool, argc, argv, NavMeshTool::applicationName);
+}
diff --git a/apps/navmeshtool/navmesh.cpp b/apps/navmeshtool/navmesh.cpp
index 384c9654660..e41a248e6d8 100644
--- a/apps/navmeshtool/navmesh.cpp
+++ b/apps/navmeshtool/navmesh.cpp
@@ -53,6 +53,9 @@ namespace NavMeshTool
             Log(Debug::Info) << provided << "/" << expected << " ("
                              << (static_cast<double>(provided) / static_cast<double>(expected) * 100)
                              << "%) navmesh tiles are generated";
+
+            std::string message = std::to_string((static_cast<double>(provided) / static_cast<double>(expected) * 100));
+            setenv("NAVMESHTOOL_MESSAGE", message.c_str(), true);
         }
 
         template <class T>
diff --git a/apps/navmeshtool/navmesh.hpp b/apps/navmeshtool/navmesh.hpp
index 4e607f4f2b0..47282237644 100644
--- a/apps/navmeshtool/navmesh.hpp
+++ b/apps/navmeshtool/navmesh.hpp
@@ -24,6 +24,8 @@ namespace NavMeshTool
     Status generateAllNavMeshTiles(const DetourNavigator::AgentBounds& agentBounds,
         const DetourNavigator::Settings& settings, std::size_t threadsNumber, bool removeUnusedTiles,
         bool writeBinaryLog, WorldspaceData& cellsData, DetourNavigator::NavMeshDb&& db);
+
+    int runNavMeshTool(int argc, char *argv[]);
 }
 
 #endif
diff --git a/apps/openmw/CMakeLists.txt b/apps/openmw/CMakeLists.txt
index cf9f2657304..c6125d36ff0 100644
--- a/apps/openmw/CMakeLists.txt
+++ b/apps/openmw/CMakeLists.txt
@@ -116,6 +116,10 @@ add_openmw_dir (mwbase
     inputmanager windowmanager statemanager luamanager
     )
 
+add_openmw_dir (.
+    ../navmeshtool/main ../navmeshtool/navmesh ../navmeshtool/worldspacedata
+    )
+
 # Main executable
 
 if (NOT ANDROID)
diff --git a/apps/openmw/engine.cpp b/apps/openmw/engine.cpp
index 75687ff2810..5c718ec52f7 100644
--- a/apps/openmw/engine.cpp
+++ b/apps/openmw/engine.cpp
@@ -467,6 +467,9 @@ void OMW::Engine::setSkipMenu(bool skipMenu, bool newGame)
     mNewGame = newGame;
 }
 
+ // To share the viewer with Android interfaces
+extern osg::ref_ptr<osgViewer::Viewer> g_viewer;
+
 void OMW::Engine::createWindow()
 {
     const int screen = Settings::video().mScreen;
diff --git a/apps/openmw/main.cpp b/apps/openmw/main.cpp
index 5bbc0211c19..1f1c114e717 100644
--- a/apps/openmw/main.cpp
+++ b/apps/openmw/main.cpp
@@ -27,6 +27,9 @@ extern "C" __declspec(dllexport) DWORD AmdPowerXpressRequestHighPerformance = 0x
 #include <unistd.h>
 #endif
 
+// Android navmeshtool hack
+#include "../navmeshtool/navmesh.hpp"
+
 using namespace Fallback;
 
 /**
@@ -226,6 +229,17 @@ int runApplication(int argc, char* argv[])
     Files::ConfigurationManager cfgMgr;
     std::unique_ptr<OMW::Engine> engine = std::make_unique<OMW::Engine>(cfgMgr);
 
+    // Android navmeshtool hack
+    if ( getenv("OPENMW_GENERATE_NAVMESH_CACHE") )
+    {
+        if(NavMeshTool::runNavMeshTool(argc, argv))
+           Log(Debug::Error) << "runNavMeshTool failed";
+        else
+           Log(Debug::Error) << "runNavMeshTool sucess";
+
+        return 0;
+    }
+
     if (parseOptions(argc, argv, *engine, cfgMgr))
     {
         engine->go();
diff --git a/apps/openmw/mwrender/luminancecalculator.cpp b/apps/openmw/mwrender/luminancecalculator.cpp
index 30918db87cc..d2bb2e10496 100644
--- a/apps/openmw/mwrender/luminancecalculator.cpp
+++ b/apps/openmw/mwrender/luminancecalculator.cpp
@@ -26,7 +26,7 @@ namespace MWRender
             buffer.mipmappedSceneLuminanceTex = new osg::Texture2D;
             buffer.mipmappedSceneLuminanceTex->setInternalFormat(GL_R16F);
             buffer.mipmappedSceneLuminanceTex->setSourceFormat(GL_RED);
-            buffer.mipmappedSceneLuminanceTex->setSourceType(GL_FLOAT);
+            buffer.mipmappedSceneLuminanceTex->setSourceType(GL_HALF_FLOAT);
             buffer.mipmappedSceneLuminanceTex->setWrap(osg::Texture::WRAP_S, osg::Texture::CLAMP_TO_EDGE);
             buffer.mipmappedSceneLuminanceTex->setWrap(osg::Texture::WRAP_T, osg::Texture::CLAMP_TO_EDGE);
             buffer.mipmappedSceneLuminanceTex->setFilter(
@@ -37,7 +37,7 @@ namespace MWRender
             buffer.luminanceTex = new osg::Texture2D;
             buffer.luminanceTex->setInternalFormat(GL_R16F);
             buffer.luminanceTex->setSourceFormat(GL_RED);
-            buffer.luminanceTex->setSourceType(GL_FLOAT);
+            buffer.luminanceTex->setSourceType(GL_HALF_FLOAT);
             buffer.luminanceTex->setWrap(osg::Texture::WRAP_S, osg::Texture::CLAMP_TO_EDGE);
             buffer.luminanceTex->setWrap(osg::Texture::WRAP_T, osg::Texture::CLAMP_TO_EDGE);
             buffer.luminanceTex->setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::NEAREST);
diff --git a/apps/openmw/mwrender/npcanimation.cpp b/apps/openmw/mwrender/npcanimation.cpp
index 61260e687e1..3c5bbb7d64d 100644
--- a/apps/openmw/mwrender/npcanimation.cpp
+++ b/apps/openmw/mwrender/npcanimation.cpp
@@ -347,7 +347,7 @@ namespace MWRender
             auto primaryFBO = postProcessor->getPrimaryFbo(frameId);
             primaryFBO->apply(*state);
 
-            postProcessor->getFbo(PostProcessor::FBO_OpaqueDepth, frameId)->apply(*state);
+            //postProcessor->getFbo(PostProcessor::FBO_OpaqueDepth, frameId)->apply(*state);
 
             // depth accumulation pass
             osg::ref_ptr<osg::StateSet> restore = bin->getStateSet();
diff --git a/apps/openmw/mwrender/postprocessor.cpp b/apps/openmw/mwrender/postprocessor.cpp
index 42b2e4e1eec..c02566d40a4 100644
--- a/apps/openmw/mwrender/postprocessor.cpp
+++ b/apps/openmw/mwrender/postprocessor.cpp
@@ -301,7 +301,7 @@ namespace MWRender
         mCanvases[frameId]->setCalculateAvgLum(mHDR);
 
         mCanvases[frameId]->setTextureScene(getTexture(Tex_Scene, frameId));
-        mCanvases[frameId]->setTextureDepth(getTexture(Tex_OpaqueDepth, frameId));
+        mCanvases[frameId]->setTextureDepth(getTexture(Tex_Depth, frameId));
         mCanvases[frameId]->setTextureDistortion(getTexture(Tex_Distortion, frameId));
 
         mTransparentDepthPostPass->mFbo[frameId] = mFbos[frameId][FBO_Primary];
@@ -408,12 +408,12 @@ namespace MWRender
             mPrevPassLights = mPassLights;
 
             mViewer->stopThreading();
-
+/*
             auto& shaderManager = MWBase::Environment::get().getResourceSystem()->getSceneManager()->getShaderManager();
             auto defines = shaderManager.getGlobalDefines();
             defines["disableNormals"] = mNormals ? "0" : "1";
             shaderManager.setGlobalDefines(defines);
-
+*/
             mRendering.getLightRoot()->setCollectPPLights(mPassLights);
             mStateUpdater->bindPointLights(mPassLights ? mRendering.getLightRoot()->getPPLightsBuffer() : nullptr);
             mStateUpdater->reset();
diff --git a/apps/openmw/mwrender/postprocessor.cpp.orig b/apps/openmw/mwrender/postprocessor.cpp.orig
new file mode 100644
index 00000000000..42b2e4e1eec
--- /dev/null
+++ b/apps/openmw/mwrender/postprocessor.cpp.orig
@@ -0,0 +1,840 @@
+#include "postprocessor.hpp"
+
+#include <SDL_opengl_glext.h>
+#include <algorithm>
+#include <chrono>
+#include <thread>
+
+#include <osg/Texture1D>
+#include <osg/Texture2D>
+#include <osg/Texture2DArray>
+#include <osg/Texture2DMultisample>
+#include <osg/Texture3D>
+
+#include <components/files/conversion.hpp>
+#include <components/misc/strings/algorithm.hpp>
+#include <components/misc/strings/lower.hpp>
+#include <components/resource/scenemanager.hpp>
+#include <components/sceneutil/color.hpp>
+#include <components/sceneutil/depth.hpp>
+#include <components/sceneutil/nodecallback.hpp>
+#include <components/settings/values.hpp>
+#include <components/shader/shadermanager.hpp>
+#include <components/stereo/multiview.hpp>
+#include <components/stereo/stereomanager.hpp>
+#include <components/vfs/manager.hpp>
+#include <components/vfs/recursivedirectoryiterator.hpp>
+
+#include "../mwbase/environment.hpp"
+#include "../mwbase/windowmanager.hpp"
+
+#include "../mwgui/postprocessorhud.hpp"
+
+#include "distortion.hpp"
+#include "pingpongcull.hpp"
+#include "renderbin.hpp"
+#include "renderingmanager.hpp"
+#include "sky.hpp"
+#include "transparentpass.hpp"
+#include "vismask.hpp"
+
+namespace
+{
+    struct ResizedCallback : osg::GraphicsContext::ResizedCallback
+    {
+        ResizedCallback(MWRender::PostProcessor* postProcessor)
+            : mPostProcessor(postProcessor)
+        {
+        }
+
+        void resizedImplementation(osg::GraphicsContext* gc, int x, int y, int width, int height) override
+        {
+            gc->resizedImplementation(x, y, width, height);
+
+            mPostProcessor->setRenderTargetSize(width, height);
+            mPostProcessor->resize();
+        }
+
+        MWRender::PostProcessor* mPostProcessor;
+    };
+
+    class HUDCullCallback : public SceneUtil::NodeCallback<HUDCullCallback, osg::Camera*, osgUtil::CullVisitor*>
+    {
+    public:
+        void operator()(osg::Camera* camera, osgUtil::CullVisitor* cv)
+        {
+            osg::ref_ptr<osg::StateSet> stateset = new osg::StateSet;
+            auto& sm = Stereo::Manager::instance();
+            auto* fullViewport = camera->getViewport();
+            if (sm.getEye(cv) == Stereo::Eye::Left)
+                stateset->setAttributeAndModes(
+                    new osg::Viewport(0, 0, fullViewport->width() / 2, fullViewport->height()));
+            if (sm.getEye(cv) == Stereo::Eye::Right)
+                stateset->setAttributeAndModes(
+                    new osg::Viewport(fullViewport->width() / 2, 0, fullViewport->width() / 2, fullViewport->height()));
+
+            cv->pushStateSet(stateset);
+            traverse(camera, cv);
+            cv->popStateSet();
+        }
+    };
+
+    enum class Usage
+    {
+        RENDER_BUFFER,
+        TEXTURE,
+    };
+
+    static osg::FrameBufferAttachment createFrameBufferAttachmentFromTemplate(
+        Usage usage, int width, int height, osg::Texture* template_, int samples)
+    {
+        if (usage == Usage::RENDER_BUFFER && !Stereo::getMultiview())
+        {
+            osg::ref_ptr<osg::RenderBuffer> attachment
+                = new osg::RenderBuffer(width, height, template_->getInternalFormat(), samples);
+            return osg::FrameBufferAttachment(attachment);
+        }
+
+        auto texture = Stereo::createMultiviewCompatibleTexture(width, height, samples);
+        texture->setSourceFormat(template_->getSourceFormat());
+        texture->setSourceType(template_->getSourceType());
+        texture->setInternalFormat(template_->getInternalFormat());
+        texture->setFilter(osg::Texture2D::MIN_FILTER, template_->getFilter(osg::Texture2D::MIN_FILTER));
+        texture->setFilter(osg::Texture2D::MAG_FILTER, template_->getFilter(osg::Texture2D::MAG_FILTER));
+        texture->setWrap(osg::Texture::WRAP_S, template_->getWrap(osg::Texture2D::WRAP_S));
+        texture->setWrap(osg::Texture::WRAP_T, template_->getWrap(osg::Texture2D::WRAP_T));
+
+        return Stereo::createMultiviewCompatibleAttachment(texture);
+    }
+
+    constexpr float DistortionRatio = 0.25;
+}
+
+namespace MWRender
+{
+    PostProcessor::PostProcessor(
+        RenderingManager& rendering, osgViewer::Viewer* viewer, osg::Group* rootNode, const VFS::Manager* vfs)
+        : osg::Group()
+        , mRootNode(rootNode)
+        , mHUDCamera(new osg::Camera)
+        , mRendering(rendering)
+        , mViewer(viewer)
+        , mVFS(vfs)
+        , mUsePostProcessing(Settings::postProcessing().mEnabled)
+        , mSamples(Settings::video().mAntialiasing)
+        , mPingPongCull(new PingPongCull(this))
+        , mDistortionCallback(new DistortionCallback)
+    {
+        auto& shaderManager = mRendering.getResourceSystem()->getSceneManager()->getShaderManager();
+
+        std::shared_ptr<LuminanceCalculator> luminanceCalculator = std::make_shared<LuminanceCalculator>(shaderManager);
+
+        for (auto& canvas : mCanvases)
+            canvas = new PingPongCanvas(shaderManager, luminanceCalculator);
+
+        mHUDCamera->setReferenceFrame(osg::Camera::ABSOLUTE_RF);
+        mHUDCamera->setRenderOrder(osg::Camera::POST_RENDER);
+        mHUDCamera->setClearColor(osg::Vec4(0.45, 0.45, 0.14, 1.0));
+        mHUDCamera->setClearMask(0);
+        mHUDCamera->setProjectionMatrix(osg::Matrix::ortho2D(0, 1, 0, 1));
+        mHUDCamera->setAllowEventFocus(false);
+        mHUDCamera->setViewport(0, 0, mWidth, mHeight);
+        mHUDCamera->setNodeMask(Mask_RenderToTexture);
+        mHUDCamera->getOrCreateStateSet()->setMode(GL_LIGHTING, osg::StateAttribute::OFF);
+        mHUDCamera->getOrCreateStateSet()->setMode(GL_DEPTH_TEST, osg::StateAttribute::OFF);
+        mHUDCamera->addChild(mCanvases[0]);
+        mHUDCamera->addChild(mCanvases[1]);
+        mHUDCamera->setCullCallback(new HUDCullCallback);
+        mViewer->getCamera()->addCullCallback(mPingPongCull);
+
+        // resolves the multisampled depth buffer and optionally draws an additional depth postpass
+        mTransparentDepthPostPass
+            = new TransparentDepthBinCallback(mRendering.getResourceSystem()->getSceneManager()->getShaderManager(),
+                Settings::postProcessing().mTransparentPostpass);
+        osgUtil::RenderBin::getRenderBinPrototype("DepthSortedBin")->setDrawCallback(mTransparentDepthPostPass);
+
+        osg::ref_ptr<osgUtil::RenderBin> distortionRenderBin
+            = new osgUtil::RenderBin(osgUtil::RenderBin::SORT_BACK_TO_FRONT);
+        // This is silly to have to do, but if nothing is drawn then the drawcallback is never called and the distortion
+        // texture will never be cleared
+        osg::ref_ptr<osg::Node> dummyNodeToClear = new osg::Node;
+        dummyNodeToClear->setCullingActive(false);
+        dummyNodeToClear->getOrCreateStateSet()->setRenderBinDetails(RenderBin_Distortion, "Distortion");
+        rootNode->addChild(dummyNodeToClear);
+        distortionRenderBin->setDrawCallback(mDistortionCallback);
+        distortionRenderBin->getStateSet()->setDefine("DISTORTION", "1", osg::StateAttribute::ON);
+
+        // Give the renderbin access to the opaque depth sampler so it can write its occlusion
+        // Distorted geometry is drawn with ALWAYS depth function and depths writes disbled.
+        const int unitSoftEffect
+            = shaderManager.reserveGlobalTextureUnits(Shader::ShaderManager::Slot::OpaqueDepthTexture);
+        distortionRenderBin->getStateSet()->addUniform(new osg::Uniform("opaqueDepthTex", unitSoftEffect));
+
+        osgUtil::RenderBin::addRenderBinPrototype("Distortion", distortionRenderBin);
+
+        auto defines = shaderManager.getGlobalDefines();
+        defines["distorionRTRatio"] = std::to_string(DistortionRatio);
+        shaderManager.setGlobalDefines(defines);
+
+        createObjectsForFrame(0);
+        createObjectsForFrame(1);
+
+        populateTechniqueFiles();
+
+        auto distortion = loadTechnique("internal_distortion");
+        distortion->setInternal(true);
+        distortion->setLocked(true);
+        mInternalTechniques.push_back(distortion);
+
+        osg::GraphicsContext* gc = viewer->getCamera()->getGraphicsContext();
+        osg::GLExtensions* ext = gc->getState()->get<osg::GLExtensions>();
+
+        mWidth = gc->getTraits()->width;
+        mHeight = gc->getTraits()->height;
+
+        if (!ext->glDisablei && ext->glDisableIndexedEXT)
+            ext->glDisablei = ext->glDisableIndexedEXT;
+
+#ifdef ANDROID
+        ext->glDisablei = nullptr;
+#endif
+
+        if (ext->glDisablei)
+            mNormalsSupported = true;
+        else
+            Log(Debug::Error) << "'glDisablei' unsupported, pass normals will not be available to shaders.";
+
+        mGLSLVersion = ext->glslLanguageVersion * 100;
+        mUBO = ext->isUniformBufferObjectSupported && mGLSLVersion >= 330;
+        mStateUpdater = new fx::StateUpdater(mUBO);
+
+        addChild(mHUDCamera);
+        addChild(mRootNode);
+
+        mViewer->setSceneData(this);
+        mViewer->getCamera()->setRenderTargetImplementation(osg::Camera::FRAME_BUFFER_OBJECT);
+        mViewer->getCamera()->getGraphicsContext()->setResizedCallback(new ResizedCallback(this));
+        mViewer->getCamera()->setUserData(this);
+
+        setCullCallback(mStateUpdater);
+
+        if (mUsePostProcessing)
+            enable();
+    }
+
+    PostProcessor::~PostProcessor()
+    {
+        if (auto* bin = osgUtil::RenderBin::getRenderBinPrototype("DepthSortedBin"))
+            bin->setDrawCallback(nullptr);
+    }
+
+    void PostProcessor::resize()
+    {
+        mHUDCamera->resize(mWidth, mHeight);
+        mViewer->getCamera()->resize(mWidth, mHeight);
+        if (Stereo::getStereo())
+            Stereo::Manager::instance().screenResolutionChanged();
+
+        size_t frameId = frame() % 2;
+
+        createObjectsForFrame(frameId);
+
+        mRendering.updateProjectionMatrix();
+        mRendering.setScreenRes(renderWidth(), renderHeight());
+
+        dirtyTechniques(true);
+
+        mDirty = true;
+        mDirtyFrameId = !frameId;
+    }
+
+    void PostProcessor::populateTechniqueFiles()
+    {
+        for (const auto& name : mVFS->getRecursiveDirectoryIterator(fx::Technique::sSubdir))
+        {
+            std::filesystem::path path = Files::pathFromUnicodeString(name);
+            std::string fileExt = Misc::StringUtils::lowerCase(Files::pathToUnicodeString(path.extension()));
+            if (!path.parent_path().has_parent_path() && fileExt == fx::Technique::sExt)
+            {
+                const auto absolutePath = mVFS->getAbsoluteFileName(path);
+                mTechniqueFileMap[Files::pathToUnicodeString(absolutePath.stem())] = absolutePath;
+            }
+        }
+    }
+
+    void PostProcessor::enable()
+    {
+        mReload = true;
+        mUsePostProcessing = true;
+    }
+
+    void PostProcessor::disable()
+    {
+        mUsePostProcessing = false;
+        mRendering.getSkyManager()->setSunglare(true);
+    }
+
+    void PostProcessor::traverse(osg::NodeVisitor& nv)
+    {
+        size_t frameId = nv.getTraversalNumber() % 2;
+
+        if (nv.getVisitorType() == osg::NodeVisitor::CULL_VISITOR)
+            cull(frameId, static_cast<osgUtil::CullVisitor*>(&nv));
+        else if (nv.getVisitorType() == osg::NodeVisitor::UPDATE_VISITOR)
+            update(frameId);
+
+        osg::Group::traverse(nv);
+    }
+
+    void PostProcessor::cull(size_t frameId, osgUtil::CullVisitor* cv)
+    {
+        if (const auto& fbo = getFbo(FBO_Intercept, frameId))
+        {
+            osgUtil::RenderStage* rs = cv->getRenderStage();
+            if (rs && rs->getMultisampleResolveFramebufferObject())
+                rs->setMultisampleResolveFramebufferObject(fbo);
+        }
+
+        mCanvases[frameId]->setPostProcessing(mUsePostProcessing);
+        mCanvases[frameId]->setTextureNormals(mNormals ? getTexture(Tex_Normal, frameId) : nullptr);
+        mCanvases[frameId]->setMask(mUnderwater, mExteriorFlag);
+        mCanvases[frameId]->setCalculateAvgLum(mHDR);
+
+        mCanvases[frameId]->setTextureScene(getTexture(Tex_Scene, frameId));
+        mCanvases[frameId]->setTextureDepth(getTexture(Tex_OpaqueDepth, frameId));
+        mCanvases[frameId]->setTextureDistortion(getTexture(Tex_Distortion, frameId));
+
+        mTransparentDepthPostPass->mFbo[frameId] = mFbos[frameId][FBO_Primary];
+        mTransparentDepthPostPass->mMsaaFbo[frameId] = mFbos[frameId][FBO_Multisample];
+        mTransparentDepthPostPass->mOpaqueFbo[frameId] = mFbos[frameId][FBO_OpaqueDepth];
+
+        mDistortionCallback->setFBO(mFbos[frameId][FBO_Distortion], frameId);
+        mDistortionCallback->setOriginalFBO(mFbos[frameId][FBO_Primary], frameId);
+
+        size_t frame = cv->getTraversalNumber();
+
+        mStateUpdater->setResolution(osg::Vec2f(cv->getViewport()->width(), cv->getViewport()->height()));
+
+        // per-frame data
+        if (frame != mLastFrameNumber)
+        {
+            mLastFrameNumber = frame;
+            auto stamp = cv->getFrameStamp();
+
+            mStateUpdater->setSimulationTime(static_cast<float>(stamp->getSimulationTime()));
+            mStateUpdater->setDeltaSimulationTime(static_cast<float>(stamp->getSimulationTime() - mLastSimulationTime));
+            mLastSimulationTime = stamp->getSimulationTime();
+
+            for (const auto& dispatchNode : mCanvases[frameId]->getPasses())
+            {
+                for (auto& uniform : dispatchNode.mHandle->getUniformMap())
+                {
+                    if (uniform->getType().has_value() && !uniform->mSamplerType)
+                        if (auto* u = dispatchNode.mRootStateSet->getUniform(uniform->mName))
+                            uniform->setUniform(u);
+                }
+            }
+        }
+    }
+
+    void PostProcessor::updateLiveReload()
+    {
+        if (!mEnableLiveReload && !mTriggerShaderReload)
+            return;
+
+        mTriggerShaderReload = false; // Done only once
+
+        for (auto& technique : mTechniques)
+        {
+            if (technique->getStatus() == fx::Technique::Status::File_Not_exists)
+                continue;
+
+            const auto lastWriteTime = std::filesystem::last_write_time(mTechniqueFileMap[technique->getName()]);
+            const bool isDirty = technique->setLastModificationTime(lastWriteTime);
+
+            if (!isDirty)
+                continue;
+
+            // TODO: Temporary workaround to avoid conflicts with external programs saving the file, especially
+            // problematic on Windows.
+            //       If we move to a file watcher using native APIs this should be removed.
+            std::this_thread::sleep_for(std::chrono::milliseconds(5));
+
+            if (technique->compile())
+                Log(Debug::Info) << "Reloaded technique : " << mTechniqueFileMap[technique->getName()];
+
+            mReload = technique->isValid();
+        }
+    }
+
+    void PostProcessor::reloadIfRequired()
+    {
+        if (!mReload)
+            return;
+
+        mReload = false;
+
+        loadChain();
+        resize();
+    }
+
+    void PostProcessor::update(size_t frameId)
+    {
+        while (!mQueuedTemplates.empty())
+        {
+            mTemplates.push_back(std::move(mQueuedTemplates.back()));
+
+            mQueuedTemplates.pop_back();
+        }
+
+        updateLiveReload();
+
+        reloadIfRequired();
+
+        mCanvases[frameId]->setNodeMask(~0u);
+        mCanvases[!frameId]->setNodeMask(0);
+
+        if (mDirty && mDirtyFrameId == frameId)
+        {
+            createObjectsForFrame(frameId);
+
+            mDirty = false;
+            mCanvases[frameId]->setPasses(fx::DispatchArray(mTemplateData));
+        }
+
+        if ((mNormalsSupported && mNormals != mPrevNormals) || (mPassLights != mPrevPassLights))
+        {
+            mPrevNormals = mNormals;
+            mPrevPassLights = mPassLights;
+
+            mViewer->stopThreading();
+
+            auto& shaderManager = MWBase::Environment::get().getResourceSystem()->getSceneManager()->getShaderManager();
+            auto defines = shaderManager.getGlobalDefines();
+            defines["disableNormals"] = mNormals ? "0" : "1";
+            shaderManager.setGlobalDefines(defines);
+
+            mRendering.getLightRoot()->setCollectPPLights(mPassLights);
+            mStateUpdater->bindPointLights(mPassLights ? mRendering.getLightRoot()->getPPLightsBuffer() : nullptr);
+            mStateUpdater->reset();
+
+            mViewer->startThreading();
+
+            createObjectsForFrame(frameId);
+
+            mDirty = true;
+            mDirtyFrameId = !frameId;
+        }
+    }
+
+    void PostProcessor::createObjectsForFrame(size_t frameId)
+    {
+        auto& textures = mTextures[frameId];
+
+        int width = renderWidth();
+        int height = renderHeight();
+
+        for (osg::ref_ptr<osg::Texture>& texture : textures)
+        {
+            if (!texture)
+            {
+                if (Stereo::getMultiview())
+                    texture = new osg::Texture2DArray;
+                else
+                    texture = new osg::Texture2D;
+            }
+            Stereo::setMultiviewCompatibleTextureSize(texture, width, height);
+            texture->setSourceFormat(GL_RGBA);
+            texture->setSourceType(GL_UNSIGNED_BYTE);
+            texture->setInternalFormat(GL_RGBA);
+            texture->setFilter(osg::Texture2D::MIN_FILTER, osg::Texture::LINEAR);
+            texture->setFilter(osg::Texture2D::MAG_FILTER, osg::Texture::LINEAR);
+            texture->setWrap(osg::Texture::WRAP_S, osg::Texture::CLAMP_TO_EDGE);
+            texture->setWrap(osg::Texture::WRAP_T, osg::Texture::CLAMP_TO_EDGE);
+            texture->setResizeNonPowerOfTwoHint(false);
+            Stereo::setMultiviewCompatibleTextureSize(texture, width, height);
+            texture->dirtyTextureObject();
+        }
+
+        textures[Tex_Normal]->setSourceFormat(GL_RGB);
+        textures[Tex_Normal]->setInternalFormat(GL_RGB);
+
+        textures[Tex_Distortion]->setSourceFormat(GL_RGB);
+        textures[Tex_Distortion]->setInternalFormat(GL_RGB);
+
+        Stereo::setMultiviewCompatibleTextureSize(
+            textures[Tex_Distortion], width * DistortionRatio, height * DistortionRatio);
+        textures[Tex_Distortion]->dirtyTextureObject();
+
+        auto setupDepth = [](osg::Texture* tex) {
+            tex->setSourceFormat(GL_DEPTH_STENCIL_EXT);
+            tex->setSourceType(SceneUtil::AutoDepth::depthSourceType());
+            tex->setInternalFormat(SceneUtil::AutoDepth::depthInternalFormat());
+        };
+
+        setupDepth(textures[Tex_Depth]);
+        setupDepth(textures[Tex_OpaqueDepth]);
+        textures[Tex_OpaqueDepth]->setName("opaqueTexMap");
+
+        auto& fbos = mFbos[frameId];
+
+        fbos[FBO_Primary] = new osg::FrameBufferObject;
+        fbos[FBO_Primary]->setAttachment(
+            osg::Camera::COLOR_BUFFER0, Stereo::createMultiviewCompatibleAttachment(textures[Tex_Scene]));
+        if (mNormals && mNormalsSupported)
+            fbos[FBO_Primary]->setAttachment(
+                osg::Camera::COLOR_BUFFER1, Stereo::createMultiviewCompatibleAttachment(textures[Tex_Normal]));
+        fbos[FBO_Primary]->setAttachment(
+            osg::Camera::PACKED_DEPTH_STENCIL_BUFFER, Stereo::createMultiviewCompatibleAttachment(textures[Tex_Depth]));
+
+        fbos[FBO_FirstPerson] = new osg::FrameBufferObject;
+
+        auto fpDepthRb = createFrameBufferAttachmentFromTemplate(
+            Usage::RENDER_BUFFER, width, height, textures[Tex_Depth], mSamples);
+        fbos[FBO_FirstPerson]->setAttachment(osg::FrameBufferObject::BufferComponent::PACKED_DEPTH_STENCIL_BUFFER,
+            osg::FrameBufferAttachment(fpDepthRb));
+
+        if (mSamples > 1)
+        {
+            fbos[FBO_Multisample] = new osg::FrameBufferObject;
+            auto colorRB = createFrameBufferAttachmentFromTemplate(
+                Usage::RENDER_BUFFER, width, height, textures[Tex_Scene], mSamples);
+            if (mNormals && mNormalsSupported)
+            {
+                auto normalRB = createFrameBufferAttachmentFromTemplate(
+                    Usage::RENDER_BUFFER, width, height, textures[Tex_Normal], mSamples);
+                fbos[FBO_Multisample]->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER1, normalRB);
+                fbos[FBO_FirstPerson]->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER1, normalRB);
+            }
+            auto depthRB = createFrameBufferAttachmentFromTemplate(
+                Usage::RENDER_BUFFER, width, height, textures[Tex_Depth], mSamples);
+            fbos[FBO_Multisample]->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER0, colorRB);
+            fbos[FBO_Multisample]->setAttachment(
+                osg::FrameBufferObject::BufferComponent::PACKED_DEPTH_STENCIL_BUFFER, depthRB);
+            fbos[FBO_FirstPerson]->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER0, colorRB);
+
+            fbos[FBO_Intercept] = new osg::FrameBufferObject;
+            fbos[FBO_Intercept]->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER0,
+                Stereo::createMultiviewCompatibleAttachment(textures[Tex_Scene]));
+            fbos[FBO_Intercept]->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER1,
+                Stereo::createMultiviewCompatibleAttachment(textures[Tex_Normal]));
+        }
+        else
+        {
+            fbos[FBO_FirstPerson]->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER0,
+                Stereo::createMultiviewCompatibleAttachment(textures[Tex_Scene]));
+            if (mNormals && mNormalsSupported)
+                fbos[FBO_FirstPerson]->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER1,
+                    Stereo::createMultiviewCompatibleAttachment(textures[Tex_Normal]));
+        }
+
+        fbos[FBO_OpaqueDepth] = new osg::FrameBufferObject;
+        fbos[FBO_OpaqueDepth]->setAttachment(osg::FrameBufferObject::BufferComponent::PACKED_DEPTH_STENCIL_BUFFER,
+            Stereo::createMultiviewCompatibleAttachment(textures[Tex_OpaqueDepth]));
+
+        fbos[FBO_Distortion] = new osg::FrameBufferObject;
+        fbos[FBO_Distortion]->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER0,
+            Stereo::createMultiviewCompatibleAttachment(textures[Tex_Distortion]));
+
+#ifdef __APPLE__
+        if (textures[Tex_OpaqueDepth])
+            fbos[FBO_OpaqueDepth]->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER,
+                osg::FrameBufferAttachment(new osg::RenderBuffer(textures[Tex_OpaqueDepth]->getTextureWidth(),
+                    textures[Tex_OpaqueDepth]->getTextureHeight(), textures[Tex_Scene]->getInternalFormat())));
+#endif
+
+        mCanvases[frameId]->dirty();
+    }
+
+    void PostProcessor::dirtyTechniques(bool dirtyAttachments)
+    {
+        size_t frameId = frame() % 2;
+
+        mDirty = true;
+        mDirtyFrameId = !frameId;
+
+        mTemplateData = {};
+
+        bool sunglare = true;
+        mHDR = false;
+        mNormals = false;
+        mPassLights = false;
+
+        std::vector<fx::Types::RenderTarget> attachmentsToDirty;
+
+        for (const auto& technique : mTechniques)
+        {
+            if (!technique->isValid())
+                continue;
+
+            if (technique->getGLSLVersion() > mGLSLVersion)
+            {
+                Log(Debug::Warning) << "Technique " << technique->getName() << " requires GLSL version "
+                                    << technique->getGLSLVersion() << " which is unsupported by your hardware.";
+                continue;
+            }
+
+            fx::DispatchNode node;
+
+            node.mFlags = technique->getFlags();
+
+            if (technique->getHDR())
+                mHDR = true;
+
+            if (technique->getNormals())
+                mNormals = true;
+
+            if (technique->getLights())
+                mPassLights = true;
+
+            if (node.mFlags & fx::Technique::Flag_Disable_SunGlare)
+                sunglare = false;
+
+            // required default samplers available to every shader pass
+            node.mRootStateSet->addUniform(new osg::Uniform("omw_SamplerLastShader", Unit_LastShader));
+            node.mRootStateSet->addUniform(new osg::Uniform("omw_SamplerLastPass", Unit_LastPass));
+            node.mRootStateSet->addUniform(new osg::Uniform("omw_SamplerDepth", Unit_Depth));
+            node.mRootStateSet->addUniform(new osg::Uniform("omw_SamplerDistortion", Unit_Distortion));
+
+            if (mNormals)
+                node.mRootStateSet->addUniform(new osg::Uniform("omw_SamplerNormals", Unit_Normals));
+
+            if (technique->getHDR())
+                node.mRootStateSet->addUniform(new osg::Uniform("omw_EyeAdaptation", Unit_EyeAdaptation));
+
+            node.mRootStateSet->addUniform(new osg::Uniform("omw_SamplerDistortion", Unit_Distortion));
+
+            int texUnit = Unit_NextFree;
+
+            // user-defined samplers
+            for (const osg::Texture* texture : technique->getTextures())
+            {
+                if (const auto* tex1D = dynamic_cast<const osg::Texture1D*>(texture))
+                    node.mRootStateSet->setTextureAttribute(texUnit, new osg::Texture1D(*tex1D));
+                else if (const auto* tex2D = dynamic_cast<const osg::Texture2D*>(texture))
+                    node.mRootStateSet->setTextureAttribute(texUnit, new osg::Texture2D(*tex2D));
+                else if (const auto* tex3D = dynamic_cast<const osg::Texture3D*>(texture))
+                    node.mRootStateSet->setTextureAttribute(texUnit, new osg::Texture3D(*tex3D));
+
+                node.mRootStateSet->addUniform(new osg::Uniform(texture->getName().c_str(), texUnit++));
+            }
+
+            // user-defined uniforms
+            for (auto& uniform : technique->getUniformMap())
+            {
+                if (uniform->mSamplerType)
+                    continue;
+
+                if (auto type = uniform->getType())
+                    uniform->setUniform(node.mRootStateSet->getOrCreateUniform(
+                        uniform->mName.c_str(), *type, uniform->getNumElements()));
+            }
+
+            for (const auto& pass : technique->getPasses())
+            {
+                int subTexUnit = texUnit;
+                fx::DispatchNode::SubPass subPass;
+
+                pass->prepareStateSet(subPass.mStateSet, technique->getName());
+
+                node.mHandle = technique;
+
+                if (!pass->getTarget().empty())
+                {
+                    auto& renderTarget = technique->getRenderTargetsMap()[pass->getTarget()];
+                    subPass.mSize = renderTarget.mSize;
+                    subPass.mRenderTexture = renderTarget.mTarget;
+                    subPass.mMipMap = renderTarget.mMipMap;
+
+                    subPass.mRenderTarget = new osg::FrameBufferObject;
+                    subPass.mRenderTarget->setAttachment(osg::FrameBufferObject::BufferComponent::COLOR_BUFFER0,
+                        osg::FrameBufferAttachment(subPass.mRenderTexture));
+
+                    const auto [w, h] = renderTarget.mSize.get(renderWidth(), renderHeight());
+                    subPass.mStateSet->setAttributeAndModes(new osg::Viewport(0, 0, w, h));
+
+                    if (std::find_if(attachmentsToDirty.cbegin(), attachmentsToDirty.cend(),
+                            [renderTarget](const auto& rt) { return renderTarget.mTarget == rt.mTarget; })
+                        == attachmentsToDirty.cend())
+                    {
+                        attachmentsToDirty.push_back(fx::Types::RenderTarget(renderTarget));
+                    }
+                }
+
+                for (const auto& name : pass->getRenderTargets())
+                {
+                    if (name.empty())
+                    {
+                        continue;
+                    }
+
+                    auto& renderTarget = technique->getRenderTargetsMap()[name];
+                    subPass.mStateSet->setTextureAttribute(subTexUnit, renderTarget.mTarget);
+                    subPass.mStateSet->addUniform(new osg::Uniform(name.c_str(), subTexUnit));
+
+                    if (std::find_if(attachmentsToDirty.cbegin(), attachmentsToDirty.cend(),
+                            [renderTarget](const auto& rt) { return renderTarget.mTarget == rt.mTarget; })
+                        == attachmentsToDirty.cend())
+                    {
+                        attachmentsToDirty.push_back(fx::Types::RenderTarget(renderTarget));
+                    }
+                    subTexUnit++;
+                }
+
+                node.mPasses.emplace_back(std::move(subPass));
+            }
+
+            node.compile();
+
+            mTemplateData.emplace_back(std::move(node));
+        }
+
+        mCanvases[frameId]->setPasses(fx::DispatchArray(mTemplateData));
+
+        if (auto hud = MWBase::Environment::get().getWindowManager()->getPostProcessorHud())
+            hud->updateTechniques();
+
+        mRendering.getSkyManager()->setSunglare(sunglare);
+
+        if (dirtyAttachments)
+            mCanvases[frameId]->setDirtyAttachments(attachmentsToDirty);
+    }
+
+    PostProcessor::Status PostProcessor::enableTechnique(
+        std::shared_ptr<fx::Technique> technique, std::optional<int> location)
+    {
+        if (!technique || technique->getLocked() || (location.has_value() && location.value() < 0))
+            return Status_Error;
+
+        disableTechnique(technique, false);
+
+        int pos = std::min<int>(location.value_or(mTechniques.size()) + mInternalTechniques.size(), mTechniques.size());
+
+        mTechniques.insert(mTechniques.begin() + pos, technique);
+        dirtyTechniques(Settings::ShaderManager::get().getMode() == Settings::ShaderManager::Mode::Debug);
+
+        return Status_Toggled;
+    }
+
+    PostProcessor::Status PostProcessor::disableTechnique(std::shared_ptr<fx::Technique> technique, bool dirty)
+    {
+        if (technique->getLocked())
+            return Status_Error;
+
+        auto it = std::find(mTechniques.begin(), mTechniques.end(), technique);
+        if (it == std::end(mTechniques))
+            return Status_Unchanged;
+
+        mTechniques.erase(it);
+        if (dirty)
+            dirtyTechniques();
+
+        return Status_Toggled;
+    }
+
+    bool PostProcessor::isTechniqueEnabled(const std::shared_ptr<fx::Technique>& technique) const
+    {
+        if (auto it = std::find(mTechniques.begin(), mTechniques.end(), technique); it == mTechniques.end())
+            return false;
+
+        return technique->isValid();
+    }
+
+    std::shared_ptr<fx::Technique> PostProcessor::loadTechnique(const std::string& name, bool loadNextFrame)
+    {
+        for (const auto& technique : mTemplates)
+            if (Misc::StringUtils::ciEqual(technique->getName(), name))
+                return technique;
+
+        for (const auto& technique : mQueuedTemplates)
+            if (Misc::StringUtils::ciEqual(technique->getName(), name))
+                return technique;
+
+        auto technique = std::make_shared<fx::Technique>(*mVFS, *mRendering.getResourceSystem()->getImageManager(),
+            name, renderWidth(), renderHeight(), mUBO, mNormalsSupported);
+
+        technique->compile();
+
+        if (technique->getStatus() != fx::Technique::Status::File_Not_exists)
+            technique->setLastModificationTime(
+                std::filesystem::last_write_time(mTechniqueFileMap[technique->getName()]));
+
+        if (loadNextFrame)
+        {
+            mQueuedTemplates.push_back(technique);
+            return technique;
+        }
+
+        mTemplates.push_back(std::move(technique));
+
+        return mTemplates.back();
+    }
+
+    void PostProcessor::loadChain()
+    {
+        mTechniques.clear();
+
+        for (const auto& technique : mInternalTechniques)
+        {
+            mTechniques.push_back(technique);
+        }
+
+        for (const std::string& techniqueName : Settings::postProcessing().mChain.get())
+        {
+            if (techniqueName.empty())
+                continue;
+
+            mTechniques.push_back(loadTechnique(techniqueName));
+        }
+
+        dirtyTechniques();
+    }
+
+    void PostProcessor::saveChain()
+    {
+        std::vector<std::string> chain;
+
+        for (const auto& technique : mTechniques)
+        {
+            if (!technique || technique->getDynamic() || technique->getInternal())
+                continue;
+            chain.push_back(technique->getName());
+        }
+
+        Settings::postProcessing().mChain.set(chain);
+    }
+
+    void PostProcessor::toggleMode()
+    {
+        for (auto& technique : mTemplates)
+            technique->compile();
+
+        dirtyTechniques(true);
+    }
+
+    void PostProcessor::disableDynamicShaders()
+    {
+        for (auto& technique : mTechniques)
+            if (technique->getDynamic())
+                disableTechnique(technique);
+    }
+
+    int PostProcessor::renderWidth() const
+    {
+        if (Stereo::getStereo())
+            return Stereo::Manager::instance().eyeResolution().x();
+        return mWidth;
+    }
+
+    int PostProcessor::renderHeight() const
+    {
+        if (Stereo::getStereo())
+            return Stereo::Manager::instance().eyeResolution().y();
+        return mHeight;
+    }
+
+    void PostProcessor::triggerShaderReload()
+    {
+        mTriggerShaderReload = true;
+    }
+}
diff --git a/apps/openmw/mwrender/renderingmanager.cpp b/apps/openmw/mwrender/renderingmanager.cpp
index 224774d1029..0eca81d2470 100644
--- a/apps/openmw/mwrender/renderingmanager.cpp
+++ b/apps/openmw/mwrender/renderingmanager.cpp
@@ -464,8 +464,8 @@ namespace MWRender
 
         mPostProcessor = new PostProcessor(*this, viewer, mRootNode, resourceSystem->getVFS());
         resourceSystem->getSceneManager()->setOpaqueDepthTex(
-            mPostProcessor->getTexture(PostProcessor::Tex_OpaqueDepth, 0),
-            mPostProcessor->getTexture(PostProcessor::Tex_OpaqueDepth, 1));
+            mPostProcessor->getTexture(PostProcessor::Tex_Depth, 0),
+            mPostProcessor->getTexture(PostProcessor::Tex_Depth, 1));
         resourceSystem->getSceneManager()->setSoftParticles(Settings::shaders().mSoftParticles);
         resourceSystem->getSceneManager()->setSupportsNormalsRT(mPostProcessor->getSupportsNormalsRT());
         resourceSystem->getSceneManager()->setWeatherParticleOcclusion(Settings::shaders().mWeatherParticleOcclusion);
diff --git a/apps/openmw/mwrender/renderingmanager.cpp.orig b/apps/openmw/mwrender/renderingmanager.cpp.orig
new file mode 100644
index 00000000000..224774d1029
--- /dev/null
+++ b/apps/openmw/mwrender/renderingmanager.cpp.orig
@@ -0,0 +1,1767 @@
+#include "renderingmanager.hpp"
+
+#include <cstdlib>
+#include <limits>
+
+#include <osg/ClipControl>
+#include <osg/ComputeBoundsVisitor>
+#include <osg/Fog>
+#include <osg/Group>
+#include <osg/Light>
+#include <osg/LightModel>
+#include <osg/Material>
+#include <osg/PolygonMode>
+#include <osg/UserDataContainer>
+
+#include <osgUtil/LineSegmentIntersector>
+
+#include <osgViewer/Viewer>
+
+#include <components/nifosg/nifloader.hpp>
+
+#include <components/debug/debuglog.hpp>
+
+#include <components/stereo/multiview.hpp>
+#include <components/stereo/stereomanager.hpp>
+
+#include <components/resource/imagemanager.hpp>
+#include <components/resource/keyframemanager.hpp>
+#include <components/resource/resourcesystem.hpp>
+
+#include <components/shader/removedalphafunc.hpp>
+#include <components/shader/shadermanager.hpp>
+
+#include <components/settings/values.hpp>
+
+#include <components/sceneutil/cullsafeboundsvisitor.hpp>
+#include <components/sceneutil/depth.hpp>
+#include <components/sceneutil/lightmanager.hpp>
+#include <components/sceneutil/positionattitudetransform.hpp>
+#include <components/sceneutil/rtt.hpp>
+#include <components/sceneutil/shadow.hpp>
+#include <components/sceneutil/statesetupdater.hpp>
+#include <components/sceneutil/visitor.hpp>
+#include <components/sceneutil/workqueue.hpp>
+#include <components/sceneutil/writescene.hpp>
+
+#include <components/misc/constants.hpp>
+
+#include <components/terrain/quadtreeworld.hpp>
+#include <components/terrain/terraingrid.hpp>
+
+#include <components/esm3/loadcell.hpp>
+#include <components/esm4/loadcell.hpp>
+
+#include <components/debug/debugdraw.hpp>
+#include <components/detournavigator/navigator.hpp>
+#include <components/detournavigator/navmeshcacheitem.hpp>
+
+#include "../mwworld/cellstore.hpp"
+#include "../mwworld/class.hpp"
+#include "../mwworld/groundcoverstore.hpp"
+#include "../mwworld/scene.hpp"
+
+#include "../mwgui/postprocessorhud.hpp"
+
+#include "../mwmechanics/actorutil.hpp"
+
+#include "../mwbase/environment.hpp"
+#include "../mwbase/windowmanager.hpp"
+#include "../mwbase/world.hpp"
+
+#include "actorspaths.hpp"
+#include "camera.hpp"
+#include "effectmanager.hpp"
+#include "fogmanager.hpp"
+#include "groundcover.hpp"
+#include "navmesh.hpp"
+#include "npcanimation.hpp"
+#include "objectpaging.hpp"
+#include "pathgrid.hpp"
+#include "postprocessor.hpp"
+#include "recastmesh.hpp"
+#include "screenshotmanager.hpp"
+#include "sky.hpp"
+#include "terrainstorage.hpp"
+#include "util.hpp"
+#include "vismask.hpp"
+#include "water.hpp"
+
+namespace MWRender
+{
+    class PerViewUniformStateUpdater final : public SceneUtil::StateSetUpdater
+    {
+    public:
+        PerViewUniformStateUpdater(Resource::SceneManager* sceneManager)
+            : mSceneManager(sceneManager)
+        {
+            mOpaqueTextureUnit = mSceneManager->getShaderManager().reserveGlobalTextureUnits(
+                Shader::ShaderManager::Slot::OpaqueDepthTexture);
+        }
+
+        void setDefaults(osg::StateSet* stateset) override
+        {
+            stateset->addUniform(new osg::Uniform("projectionMatrix", osg::Matrixf{}));
+            if (mSkyRTT)
+                stateset->addUniform(new osg::Uniform("sky", mSkyTextureUnit));
+        }
+
+        void apply(osg::StateSet* stateset, osg::NodeVisitor* nv) override
+        {
+            stateset->getUniform("projectionMatrix")->set(mProjectionMatrix);
+            if (mSkyRTT && nv->getVisitorType() == osg::NodeVisitor::CULL_VISITOR)
+            {
+                osg::Texture* skyTexture = mSkyRTT->getColorTexture(static_cast<osgUtil::CullVisitor*>(nv));
+                stateset->setTextureAttribute(
+                    mSkyTextureUnit, skyTexture, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
+            }
+
+            stateset->setTextureAttribute(mOpaqueTextureUnit,
+                mSceneManager->getOpaqueDepthTex(nv->getTraversalNumber()), osg::StateAttribute::ON);
+        }
+
+        void applyLeft(osg::StateSet* stateset, osgUtil::CullVisitor* nv) override
+        {
+            stateset->getUniform("projectionMatrix")->set(getEyeProjectionMatrix(0));
+        }
+
+        void applyRight(osg::StateSet* stateset, osgUtil::CullVisitor* nv) override
+        {
+            stateset->getUniform("projectionMatrix")->set(getEyeProjectionMatrix(1));
+        }
+
+        void setProjectionMatrix(const osg::Matrixf& projectionMatrix) { mProjectionMatrix = projectionMatrix; }
+
+        const osg::Matrixf& getProjectionMatrix() const { return mProjectionMatrix; }
+
+        void enableSkyRTT(int skyTextureUnit, SceneUtil::RTTNode* skyRTT)
+        {
+            mSkyTextureUnit = skyTextureUnit;
+            mSkyRTT = skyRTT;
+        }
+
+    private:
+        osg::Matrixf getEyeProjectionMatrix(int view)
+        {
+            return Stereo::Manager::instance().computeEyeProjection(view, SceneUtil::AutoDepth::isReversed());
+        }
+
+        osg::Matrixf mProjectionMatrix;
+        int mSkyTextureUnit = -1;
+        SceneUtil::RTTNode* mSkyRTT = nullptr;
+
+        Resource::SceneManager* mSceneManager;
+        int mOpaqueTextureUnit = -1;
+    };
+
+    class SharedUniformStateUpdater : public SceneUtil::StateSetUpdater
+    {
+    public:
+        SharedUniformStateUpdater()
+            : mNear(0.f)
+            , mFar(0.f)
+            , mWindSpeed(0.f)
+            , mSkyBlendingStartCoef(Settings::fog().mSkyBlendingStart)
+        {
+        }
+
+        void setDefaults(osg::StateSet* stateset) override
+        {
+            stateset->addUniform(new osg::Uniform("near", 0.f));
+            stateset->addUniform(new osg::Uniform("far", 0.f));
+            stateset->addUniform(new osg::Uniform("skyBlendingStart", 0.f));
+            stateset->addUniform(new osg::Uniform("screenRes", osg::Vec2f{}));
+            stateset->addUniform(new osg::Uniform("isReflection", false));
+            stateset->addUniform(new osg::Uniform("windSpeed", 0.0f));
+            stateset->addUniform(new osg::Uniform("playerPos", osg::Vec3f(0.f, 0.f, 0.f)));
+            stateset->addUniform(new osg::Uniform("useTreeAnim", false));
+        }
+
+        void apply(osg::StateSet* stateset, osg::NodeVisitor* nv) override
+        {
+            stateset->getUniform("near")->set(mNear);
+            stateset->getUniform("far")->set(mFar);
+            stateset->getUniform("skyBlendingStart")->set(mFar * mSkyBlendingStartCoef);
+            stateset->getUniform("screenRes")->set(mScreenRes);
+            stateset->getUniform("windSpeed")->set(mWindSpeed);
+            stateset->getUniform("playerPos")->set(mPlayerPos);
+        }
+
+        void setNear(float near) { mNear = near; }
+
+        void setFar(float far) { mFar = far; }
+
+        void setScreenRes(float width, float height) { mScreenRes = osg::Vec2f(width, height); }
+
+        void setWindSpeed(float windSpeed) { mWindSpeed = windSpeed; }
+
+        void setPlayerPos(osg::Vec3f playerPos) { mPlayerPos = playerPos; }
+
+    private:
+        float mNear;
+        float mFar;
+        float mWindSpeed;
+        float mSkyBlendingStartCoef;
+        osg::Vec3f mPlayerPos;
+        osg::Vec2f mScreenRes;
+    };
+
+    class StateUpdater : public SceneUtil::StateSetUpdater
+    {
+    public:
+        StateUpdater()
+            : mFogStart(0.f)
+            , mFogEnd(0.f)
+            , mWireframe(false)
+        {
+        }
+
+        void setDefaults(osg::StateSet* stateset) override
+        {
+            osg::LightModel* lightModel = new osg::LightModel;
+            stateset->setAttribute(lightModel, osg::StateAttribute::ON);
+            osg::Fog* fog = new osg::Fog;
+            fog->setMode(osg::Fog::LINEAR);
+            stateset->setAttributeAndModes(fog, osg::StateAttribute::ON);
+            if (mWireframe)
+            {
+                osg::PolygonMode* polygonmode = new osg::PolygonMode;
+                polygonmode->setMode(osg::PolygonMode::FRONT_AND_BACK, osg::PolygonMode::LINE);
+                stateset->setAttributeAndModes(polygonmode, osg::StateAttribute::ON);
+            }
+            else
+                stateset->removeAttribute(osg::StateAttribute::POLYGONMODE);
+        }
+
+        void apply(osg::StateSet* stateset, osg::NodeVisitor*) override
+        {
+            osg::LightModel* lightModel
+                = static_cast<osg::LightModel*>(stateset->getAttribute(osg::StateAttribute::LIGHTMODEL));
+            lightModel->setAmbientIntensity(mAmbientColor);
+            osg::Fog* fog = static_cast<osg::Fog*>(stateset->getAttribute(osg::StateAttribute::FOG));
+            fog->setColor(mFogColor);
+            fog->setStart(mFogStart);
+            fog->setEnd(mFogEnd);
+        }
+
+        void setAmbientColor(const osg::Vec4f& col) { mAmbientColor = col; }
+
+        void setFogColor(const osg::Vec4f& col) { mFogColor = col; }
+
+        void setFogStart(float start) { mFogStart = start; }
+
+        void setFogEnd(float end) { mFogEnd = end; }
+
+        void setWireframe(bool wireframe)
+        {
+            if (mWireframe != wireframe)
+            {
+                mWireframe = wireframe;
+                reset();
+            }
+        }
+
+        bool getWireframe() const { return mWireframe; }
+
+    private:
+        osg::Vec4f mAmbientColor;
+        osg::Vec4f mFogColor;
+        float mFogStart;
+        float mFogEnd;
+        bool mWireframe;
+    };
+
+    class PreloadCommonAssetsWorkItem : public SceneUtil::WorkItem
+    {
+    public:
+        PreloadCommonAssetsWorkItem(Resource::ResourceSystem* resourceSystem)
+            : mResourceSystem(resourceSystem)
+        {
+        }
+
+        void doWork() override
+        {
+            try
+            {
+                for (std::vector<std::string>::const_iterator it = mModels.begin(); it != mModels.end(); ++it)
+                    mResourceSystem->getSceneManager()->getTemplate(*it);
+                for (std::vector<std::string>::const_iterator it = mTextures.begin(); it != mTextures.end(); ++it)
+                    mResourceSystem->getImageManager()->getImage(*it);
+                for (std::vector<std::string>::const_iterator it = mKeyframes.begin(); it != mKeyframes.end(); ++it)
+                    mResourceSystem->getKeyframeManager()->get(*it);
+            }
+            catch (std::exception&)
+            {
+                // ignore error (will be shown when these are needed proper)
+            }
+        }
+
+        std::vector<std::string> mModels;
+        std::vector<std::string> mTextures;
+        std::vector<std::string> mKeyframes;
+
+    private:
+        Resource::ResourceSystem* mResourceSystem;
+    };
+
+    RenderingManager::RenderingManager(osgViewer::Viewer* viewer, osg::ref_ptr<osg::Group> rootNode,
+        Resource::ResourceSystem* resourceSystem, SceneUtil::WorkQueue* workQueue,
+        DetourNavigator::Navigator& navigator, const MWWorld::GroundcoverStore& groundcoverStore,
+        SceneUtil::UnrefQueue& unrefQueue)
+        : mSkyBlending(Settings::fog().mSkyBlending)
+        , mViewer(viewer)
+        , mRootNode(rootNode)
+        , mResourceSystem(resourceSystem)
+        , mWorkQueue(workQueue)
+        , mNavigator(navigator)
+        , mNightEyeFactor(0.f)
+        // TODO: Near clip should not need to be bounded like this, but too small values break OSG shadow calculations
+        // CPU-side. See issue: #6072
+        , mNearClip(Settings::camera().mNearClip)
+        , mViewDistance(Settings::camera().mViewingDistance)
+        , mFieldOfViewOverridden(false)
+        , mFieldOfViewOverride(0.f)
+        , mFieldOfView(Settings::camera().mFieldOfView)
+        , mFirstPersonFieldOfView(Settings::camera().mFirstPersonFieldOfView)
+        , mGroundCoverStore(groundcoverStore)
+    {
+        bool reverseZ = SceneUtil::AutoDepth::isReversed();
+        const SceneUtil::LightingMethod lightingMethod = Settings::shaders().mLightingMethod;
+
+        resourceSystem->getSceneManager()->setParticleSystemMask(MWRender::Mask_ParticleSystem);
+        // Shadows and radial fog have problems with fixed-function mode.
+        bool forceShaders = Settings::fog().mRadialFog || Settings::fog().mExponentialFog
+            || Settings::shaders().mSoftParticles || Settings::shaders().mForceShaders
+            || Settings::shadows().mEnableShadows || lightingMethod != SceneUtil::LightingMethod::FFP || reverseZ
+            || mSkyBlending || Stereo::getMultiview();
+        resourceSystem->getSceneManager()->setForceShaders(forceShaders);
+
+        // FIXME: calling dummy method because terrain needs to know whether lighting is clamped
+        resourceSystem->getSceneManager()->setClampLighting(Settings::shaders().mClampLighting);
+        resourceSystem->getSceneManager()->setAutoUseNormalMaps(Settings::shaders().mAutoUseObjectNormalMaps);
+        resourceSystem->getSceneManager()->setNormalMapPattern(Settings::shaders().mNormalMapPattern);
+        resourceSystem->getSceneManager()->setNormalHeightMapPattern(Settings::shaders().mNormalHeightMapPattern);
+        resourceSystem->getSceneManager()->setAutoUseSpecularMaps(Settings::shaders().mAutoUseObjectSpecularMaps);
+        resourceSystem->getSceneManager()->setSpecularMapPattern(Settings::shaders().mSpecularMapPattern);
+        resourceSystem->getSceneManager()->setApplyLightingToEnvMaps(
+            Settings::shaders().mApplyLightingToEnvironmentMaps);
+        resourceSystem->getSceneManager()->setConvertAlphaTestToAlphaToCoverage(shouldAddMSAAIntermediateTarget());
+        resourceSystem->getSceneManager()->setAdjustCoverageForAlphaTest(
+            Settings::shaders().mAdjustCoverageForAlphaTest);
+
+        // Let LightManager choose which backend to use based on our hint. For methods besides legacy lighting, this
+        // depends on support for various OpenGL extensions.
+        osg::ref_ptr<SceneUtil::LightManager> sceneRoot = new SceneUtil::LightManager(SceneUtil::LightSettings{
+            .mLightingMethod = lightingMethod,
+            .mMaxLights = Settings::shaders().mMaxLights,
+            .mMaximumLightDistance = Settings::shaders().mMaximumLightDistance,
+            .mLightFadeStart = Settings::shaders().mLightFadeStart,
+            .mLightBoundsMultiplier = Settings::shaders().mLightBoundsMultiplier,
+        });
+        resourceSystem->getSceneManager()->setLightingMethod(sceneRoot->getLightingMethod());
+        resourceSystem->getSceneManager()->setSupportedLightingMethods(sceneRoot->getSupportedLightingMethods());
+
+        sceneRoot->setLightingMask(Mask_Lighting);
+        mSceneRoot = sceneRoot;
+        sceneRoot->setStartLight(1);
+        sceneRoot->setNodeMask(Mask_Scene);
+        sceneRoot->setName("Scene Root");
+
+        int shadowCastingTraversalMask = Mask_Scene;
+        if (Settings::shadows().mActorShadows)
+            shadowCastingTraversalMask |= Mask_Actor;
+        if (Settings::shadows().mPlayerShadows)
+            shadowCastingTraversalMask |= Mask_Player;
+
+        int indoorShadowCastingTraversalMask = shadowCastingTraversalMask;
+        if (Settings::shadows().mObjectShadows)
+            shadowCastingTraversalMask |= (Mask_Object | Mask_Static);
+        if (Settings::shadows().mTerrainShadows)
+            shadowCastingTraversalMask |= Mask_Terrain;
+
+        mShadowManager = std::make_unique<SceneUtil::ShadowManager>(sceneRoot, mRootNode, shadowCastingTraversalMask,
+            indoorShadowCastingTraversalMask, Mask_Terrain | Mask_Object | Mask_Static, Settings::shadows(),
+            mResourceSystem->getSceneManager()->getShaderManager());
+
+        Shader::ShaderManager::DefineMap shadowDefines = mShadowManager->getShadowDefines(Settings::shadows());
+        Shader::ShaderManager::DefineMap lightDefines = sceneRoot->getLightDefines();
+        Shader::ShaderManager::DefineMap globalDefines
+            = mResourceSystem->getSceneManager()->getShaderManager().getGlobalDefines();
+
+        for (auto itr = shadowDefines.begin(); itr != shadowDefines.end(); itr++)
+            globalDefines[itr->first] = itr->second;
+
+        globalDefines["forcePPL"] = Settings::shaders().mForcePerPixelLighting ? "1" : "0";
+        globalDefines["clamp"] = Settings::shaders().mClampLighting ? "1" : "0";
+        globalDefines["preLightEnv"] = Settings::shaders().mApplyLightingToEnvironmentMaps ? "1" : "0";
+        const bool exponentialFog = Settings::fog().mExponentialFog;
+        globalDefines["radialFog"] = (exponentialFog || Settings::fog().mRadialFog) ? "1" : "0";
+        globalDefines["exponentialFog"] = exponentialFog ? "1" : "0";
+        globalDefines["skyBlending"] = mSkyBlending ? "1" : "0";
+        globalDefines["refraction_enabled"] = "0";
+        globalDefines["useGPUShader4"] = "0";
+        globalDefines["useOVR_multiview"] = "0";
+        globalDefines["numViews"] = "1";
+        globalDefines["disableNormals"] = "1";
+
+        for (auto itr = lightDefines.begin(); itr != lightDefines.end(); itr++)
+            globalDefines[itr->first] = itr->second;
+
+        // Refactor this at some point - most shaders don't care about these defines
+        const float groundcoverDistance = Settings::groundcover().mRenderingDistance;
+        globalDefines["groundcoverFadeStart"] = std::to_string(groundcoverDistance * 0.9f);
+        globalDefines["groundcoverFadeEnd"] = std::to_string(groundcoverDistance);
+        globalDefines["groundcoverStompMode"] = std::to_string(Settings::groundcover().mStompMode);
+        globalDefines["groundcoverStompIntensity"] = std::to_string(Settings::groundcover().mStompIntensity);
+
+        globalDefines["reverseZ"] = reverseZ ? "1" : "0";
+
+        // It is unnecessary to stop/start the viewer as no frames are being rendered yet.
+        mResourceSystem->getSceneManager()->getShaderManager().setGlobalDefines(globalDefines);
+
+        mNavMesh = std::make_unique<NavMesh>(mRootNode, mWorkQueue, Settings::navigator().mEnableNavMeshRender,
+            Settings::navigator().mNavMeshRenderMode);
+        mActorsPaths = std::make_unique<ActorsPaths>(mRootNode, Settings::navigator().mEnableAgentsPathsRender);
+        mRecastMesh = std::make_unique<RecastMesh>(mRootNode, Settings::navigator().mEnableRecastMeshRender);
+        mPathgrid = std::make_unique<Pathgrid>(mRootNode);
+
+        mObjects = std::make_unique<Objects>(mResourceSystem, sceneRoot, unrefQueue);
+
+        if (getenv("OPENMW_DONT_PRECOMPILE") == nullptr)
+        {
+            mViewer->setIncrementalCompileOperation(new osgUtil::IncrementalCompileOperation);
+            mViewer->getIncrementalCompileOperation()->setTargetFrameRate(Settings::cells().mTargetFramerate);
+        }
+
+        mDebugDraw
+            = std::make_unique<Debug::DebugDrawer>(mResourceSystem->getSceneManager()->getShaderManager(), mRootNode);
+        mResourceSystem->getSceneManager()->setIncrementalCompileOperation(mViewer->getIncrementalCompileOperation());
+
+        mEffectManager = std::make_unique<EffectManager>(sceneRoot, mResourceSystem);
+
+        const std::string& normalMapPattern = Settings::shaders().mNormalMapPattern;
+        const std::string& heightMapPattern = Settings::shaders().mNormalHeightMapPattern;
+        const std::string& specularMapPattern = Settings::shaders().mTerrainSpecularMapPattern;
+        const bool useTerrainNormalMaps = Settings::shaders().mAutoUseTerrainNormalMaps;
+        const bool useTerrainSpecularMaps = Settings::shaders().mAutoUseTerrainSpecularMaps;
+
+        mTerrainStorage = std::make_unique<TerrainStorage>(mResourceSystem, normalMapPattern, heightMapPattern,
+            useTerrainNormalMaps, specularMapPattern, useTerrainSpecularMaps);
+
+        WorldspaceChunkMgr& chunkMgr = getWorldspaceChunkMgr(ESM::Cell::sDefaultWorldspaceId);
+        mTerrain = chunkMgr.mTerrain.get();
+        mGroundcover = chunkMgr.mGroundcover.get();
+        mObjectPaging = chunkMgr.mObjectPaging.get();
+
+        mStateUpdater = new StateUpdater;
+        sceneRoot->addUpdateCallback(mStateUpdater);
+
+        mSharedUniformStateUpdater = new SharedUniformStateUpdater();
+        rootNode->addUpdateCallback(mSharedUniformStateUpdater);
+
+        mPerViewUniformStateUpdater = new PerViewUniformStateUpdater(mResourceSystem->getSceneManager());
+        rootNode->addCullCallback(mPerViewUniformStateUpdater);
+
+        mPostProcessor = new PostProcessor(*this, viewer, mRootNode, resourceSystem->getVFS());
+        resourceSystem->getSceneManager()->setOpaqueDepthTex(
+            mPostProcessor->getTexture(PostProcessor::Tex_OpaqueDepth, 0),
+            mPostProcessor->getTexture(PostProcessor::Tex_OpaqueDepth, 1));
+        resourceSystem->getSceneManager()->setSoftParticles(Settings::shaders().mSoftParticles);
+        resourceSystem->getSceneManager()->setSupportsNormalsRT(mPostProcessor->getSupportsNormalsRT());
+        resourceSystem->getSceneManager()->setWeatherParticleOcclusion(Settings::shaders().mWeatherParticleOcclusion);
+
+        // water goes after terrain for correct waterculling order
+        mWater = std::make_unique<Water>(
+            sceneRoot->getParent(0), sceneRoot, mResourceSystem, mViewer->getIncrementalCompileOperation());
+
+        mCamera = std::make_unique<Camera>(mViewer->getCamera());
+
+        mScreenshotManager
+            = std::make_unique<ScreenshotManager>(viewer, mRootNode, sceneRoot, mResourceSystem, mWater.get());
+
+        mViewer->setLightingMode(osgViewer::View::NO_LIGHT);
+
+        osg::ref_ptr<osg::LightSource> source = new osg::LightSource;
+        source->setNodeMask(Mask_Lighting);
+        mSunLight = new osg::Light;
+        source->setLight(mSunLight);
+        mSunLight->setDiffuse(osg::Vec4f(0, 0, 0, 1));
+        mSunLight->setAmbient(osg::Vec4f(0, 0, 0, 1));
+        mSunLight->setSpecular(osg::Vec4f(0, 0, 0, 0));
+        mSunLight->setConstantAttenuation(1.f);
+        sceneRoot->setSunlight(mSunLight);
+        sceneRoot->addChild(source);
+
+        sceneRoot->getOrCreateStateSet()->setMode(GL_CULL_FACE, osg::StateAttribute::ON);
+        sceneRoot->getOrCreateStateSet()->setMode(GL_LIGHTING, osg::StateAttribute::ON);
+        sceneRoot->getOrCreateStateSet()->setMode(GL_NORMALIZE, osg::StateAttribute::ON);
+        osg::ref_ptr<osg::Material> defaultMat(new osg::Material);
+        defaultMat->setColorMode(osg::Material::OFF);
+        defaultMat->setAmbient(osg::Material::FRONT_AND_BACK, osg::Vec4f(1, 1, 1, 1));
+        defaultMat->setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4f(1, 1, 1, 1));
+        defaultMat->setSpecular(osg::Material::FRONT_AND_BACK, osg::Vec4f(0.f, 0.f, 0.f, 0.f));
+        sceneRoot->getOrCreateStateSet()->setAttribute(defaultMat);
+        sceneRoot->getOrCreateStateSet()->addUniform(new osg::Uniform("emissiveMult", 1.f));
+        sceneRoot->getOrCreateStateSet()->addUniform(new osg::Uniform("specStrength", 1.f));
+        sceneRoot->getOrCreateStateSet()->addUniform(new osg::Uniform("distortionStrength", 0.f));
+
+        mFog = std::make_unique<FogManager>();
+
+        mSky = std::make_unique<SkyManager>(
+            sceneRoot, mRootNode, mViewer->getCamera(), resourceSystem->getSceneManager(), mSkyBlending);
+        if (mSkyBlending)
+        {
+            int skyTextureUnit = mResourceSystem->getSceneManager()->getShaderManager().reserveGlobalTextureUnits(
+                Shader::ShaderManager::Slot::SkyTexture);
+            mPerViewUniformStateUpdater->enableSkyRTT(skyTextureUnit, mSky->getSkyRTT());
+        }
+
+        source->setStateSetModes(*mRootNode->getOrCreateStateSet(), osg::StateAttribute::ON);
+
+        osg::Camera::CullingMode cullingMode = osg::Camera::DEFAULT_CULLING | osg::Camera::FAR_PLANE_CULLING;
+
+        if (!Settings::camera().mSmallFeatureCulling)
+            cullingMode &= ~(osg::CullStack::SMALL_FEATURE_CULLING);
+        else
+        {
+            mViewer->getCamera()->setSmallFeatureCullingPixelSize(Settings::camera().mSmallFeatureCullingPixelSize);
+            cullingMode |= osg::CullStack::SMALL_FEATURE_CULLING;
+        }
+
+        mViewer->getCamera()->setComputeNearFarMode(osg::Camera::DO_NOT_COMPUTE_NEAR_FAR);
+        mViewer->getCamera()->setCullingMode(cullingMode);
+        mViewer->getCamera()->setName(Constants::SceneCamera);
+
+        auto mask = ~(Mask_UpdateVisitor | Mask_SimpleWater);
+        MWBase::Environment::get().getWindowManager()->setCullMask(mask);
+        NifOsg::Loader::setHiddenNodeMask(Mask_UpdateVisitor);
+        NifOsg::Loader::setIntersectionDisabledNodeMask(Mask_Effect);
+        Nif::Reader::setLoadUnsupportedFiles(Settings::models().mLoadUnsupportedNifFiles);
+        Nif::Reader::setWriteNifDebugLog(Settings::models().mWriteNifDebugLog);
+
+        mStateUpdater->setFogEnd(mViewDistance);
+
+        // Hopefully, anything genuinely requiring the default alpha func of GL_ALWAYS explicitly sets it
+        mRootNode->getOrCreateStateSet()->setAttribute(Shader::RemovedAlphaFunc::getInstance(GL_ALWAYS));
+        // The transparent renderbin sets alpha testing on because that was faster on old GPUs. It's now slower and
+        // breaks things.
+        mRootNode->getOrCreateStateSet()->setMode(GL_ALPHA_TEST, osg::StateAttribute::OFF);
+
+        if (reverseZ)
+        {
+            osg::ref_ptr<osg::ClipControl> clipcontrol
+                = new osg::ClipControl(osg::ClipControl::LOWER_LEFT, osg::ClipControl::ZERO_TO_ONE);
+            mRootNode->getOrCreateStateSet()->setAttributeAndModes(new SceneUtil::AutoDepth, osg::StateAttribute::ON);
+            mRootNode->getOrCreateStateSet()->setAttributeAndModes(clipcontrol, osg::StateAttribute::ON);
+        }
+
+        SceneUtil::setCameraClearDepth(mViewer->getCamera());
+
+        updateProjectionMatrix();
+
+        mViewer->getCamera()->setClearMask(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+    }
+
+    RenderingManager::~RenderingManager()
+    {
+        // let background loading thread finish before we delete anything else
+        mWorkQueue = nullptr;
+    }
+
+    osgUtil::IncrementalCompileOperation* RenderingManager::getIncrementalCompileOperation()
+    {
+        return mViewer->getIncrementalCompileOperation();
+    }
+
+    MWRender::Objects& RenderingManager::getObjects()
+    {
+        return *mObjects.get();
+    }
+
+    Resource::ResourceSystem* RenderingManager::getResourceSystem()
+    {
+        return mResourceSystem;
+    }
+
+    SceneUtil::WorkQueue* RenderingManager::getWorkQueue()
+    {
+        return mWorkQueue.get();
+    }
+
+    Terrain::World* RenderingManager::getTerrain()
+    {
+        return mTerrain;
+    }
+
+    void RenderingManager::preloadCommonAssets()
+    {
+        osg::ref_ptr<PreloadCommonAssetsWorkItem> workItem(new PreloadCommonAssetsWorkItem(mResourceSystem));
+        mSky->listAssetsToPreload(workItem->mModels, workItem->mTextures);
+        mWater->listAssetsToPreload(workItem->mTextures);
+
+        workItem->mModels.push_back(Settings::models().mXbaseanim);
+        workItem->mModels.push_back(Settings::models().mXbaseanim1st);
+        workItem->mModels.push_back(Settings::models().mXbaseanimfemale);
+        workItem->mModels.push_back(Settings::models().mXargonianswimkna);
+
+        workItem->mKeyframes.push_back(Settings::models().mXbaseanimkf);
+        workItem->mKeyframes.push_back(Settings::models().mXbaseanim1stkf);
+        workItem->mKeyframes.push_back(Settings::models().mXbaseanimfemalekf);
+        workItem->mKeyframes.push_back(Settings::models().mXargonianswimknakf);
+
+        workItem->mTextures.emplace_back("textures/_land_default.dds");
+
+        mWorkQueue->addWorkItem(std::move(workItem));
+    }
+
+    double RenderingManager::getReferenceTime() const
+    {
+        return mViewer->getFrameStamp()->getReferenceTime();
+    }
+
+    SceneUtil::LightManager* RenderingManager::getLightRoot()
+    {
+        return mSceneRoot.get();
+    }
+
+    void RenderingManager::setNightEyeFactor(float factor)
+    {
+        if (factor != mNightEyeFactor)
+        {
+            mNightEyeFactor = factor;
+            updateAmbient();
+        }
+    }
+
+    void RenderingManager::setAmbientColour(const osg::Vec4f& colour)
+    {
+        mAmbientColor = colour;
+        updateAmbient();
+    }
+
+    void RenderingManager::skySetDate(int day, int month)
+    {
+        mSky->setDate(day, month);
+    }
+
+    int RenderingManager::skyGetMasserPhase() const
+    {
+        return mSky->getMasserPhase();
+    }
+
+    int RenderingManager::skyGetSecundaPhase() const
+    {
+        return mSky->getSecundaPhase();
+    }
+
+    void RenderingManager::skySetMoonColour(bool red)
+    {
+        mSky->setMoonColour(red);
+    }
+
+    void RenderingManager::configureAmbient(const MWWorld::Cell& cell)
+    {
+        bool isInterior = !cell.isExterior() && !cell.isQuasiExterior();
+        bool needsAdjusting = false;
+        if (mResourceSystem->getSceneManager()->getLightingMethod() != SceneUtil::LightingMethod::FFP)
+            needsAdjusting = isInterior;
+
+        osg::Vec4f ambient = SceneUtil::colourFromRGB(cell.getMood().mAmbiantColor);
+
+        if (needsAdjusting)
+        {
+            constexpr float pR = 0.2126;
+            constexpr float pG = 0.7152;
+            constexpr float pB = 0.0722;
+
+            // we already work in linear RGB so no conversions are needed for the luminosity function
+            float relativeLuminance = pR * ambient.r() + pG * ambient.g() + pB * ambient.b();
+            const float minimumAmbientLuminance = Settings::shaders().mMinimumInteriorBrightness;
+            if (relativeLuminance < minimumAmbientLuminance)
+            {
+                // brighten ambient so it reaches the minimum threshold but no more, we want to mess with content data
+                // as least we can
+                if (ambient.r() == 0.f && ambient.g() == 0.f && ambient.b() == 0.f)
+                    ambient = osg::Vec4(
+                        minimumAmbientLuminance, minimumAmbientLuminance, minimumAmbientLuminance, ambient.a());
+                else
+                    ambient *= minimumAmbientLuminance / relativeLuminance;
+            }
+        }
+
+        setAmbientColour(ambient);
+
+        osg::Vec4f diffuse = SceneUtil::colourFromRGB(cell.getMood().mDirectionalColor);
+
+        setSunColour(diffuse, diffuse, 1.f);
+        // This is total nonsense but it's what Morrowind uses
+        static const osg::Vec4f interiorSunPos
+            = osg::Vec4f(-1.f, osg::DegreesToRadians(45.f), osg::DegreesToRadians(45.f), 0.f);
+        mPostProcessor->getStateUpdater()->setSunPos(interiorSunPos, false);
+        mSunLight->setPosition(interiorSunPos);
+    }
+
+    void RenderingManager::setSunColour(const osg::Vec4f& diffuse, const osg::Vec4f& specular, float sunVis)
+    {
+        // need to wrap this in a StateUpdater?
+        mSunLight->setDiffuse(diffuse);
+        mSunLight->setSpecular(osg::Vec4f(specular.x(), specular.y(), specular.z(), specular.w() * sunVis));
+
+        mPostProcessor->getStateUpdater()->setSunColor(diffuse);
+        mPostProcessor->getStateUpdater()->setSunVis(sunVis);
+    }
+
+    void RenderingManager::setSunDirection(const osg::Vec3f& direction)
+    {
+        osg::Vec3 position = direction * -1;
+        // need to wrap this in a StateUpdater?
+        mSunLight->setPosition(osg::Vec4(position.x(), position.y(), position.z(), 0));
+
+        // The sun is not synchronized with the sunlight because sunlight origin can't reach the horizon
+        // This is based on exterior sun orbit and won't make sense for interiors, see WeatherManager::update
+        position.z() = 400.f - std::abs(position.x());
+        mSky->setSunDirection(position);
+
+        mPostProcessor->getStateUpdater()->setSunPos(osg::Vec4f(position, 0.f), mNight);
+    }
+
+    void RenderingManager::addCell(const MWWorld::CellStore* store)
+    {
+        mPathgrid->addCell(store);
+
+        mWater->changeCell(store);
+
+        if (store->getCell()->isExterior())
+        {
+            enableTerrain(true, store->getCell()->getWorldSpace());
+            mTerrain->loadCell(store->getCell()->getGridX(), store->getCell()->getGridY());
+        }
+    }
+    void RenderingManager::removeCell(const MWWorld::CellStore* store)
+    {
+        mPathgrid->removeCell(store);
+        mActorsPaths->removeCell(store);
+        mObjects->removeCell(store);
+
+        if (store->getCell()->isExterior())
+        {
+            getWorldspaceChunkMgr(store->getCell()->getWorldSpace())
+                .mTerrain->unloadCell(store->getCell()->getGridX(), store->getCell()->getGridY());
+        }
+
+        mWater->removeCell(store);
+    }
+
+    void RenderingManager::enableTerrain(bool enable, ESM::RefId worldspace)
+    {
+        if (!enable)
+            mWater->setCullCallback(nullptr);
+        else
+        {
+            WorldspaceChunkMgr& newChunks = getWorldspaceChunkMgr(worldspace);
+            if (newChunks.mTerrain.get() != mTerrain)
+            {
+                mTerrain->enable(false);
+                mTerrain = newChunks.mTerrain.get();
+                mGroundcover = newChunks.mGroundcover.get();
+                mObjectPaging = newChunks.mObjectPaging.get();
+            }
+        }
+        mTerrain->enable(enable);
+    }
+
+    void RenderingManager::setSkyEnabled(bool enabled)
+    {
+        mSky->setEnabled(enabled);
+        if (enabled)
+            mShadowManager->enableOutdoorMode();
+        else
+            mShadowManager->enableIndoorMode(Settings::shadows());
+        mPostProcessor->getStateUpdater()->setIsInterior(!enabled);
+    }
+
+    bool RenderingManager::toggleBorders()
+    {
+        bool borders = !mTerrain->getBordersVisible();
+        mTerrain->setBordersVisible(borders);
+        return borders;
+    }
+
+    bool RenderingManager::toggleRenderMode(RenderMode mode)
+    {
+        if (mode == Render_CollisionDebug || mode == Render_Pathgrid)
+            return mPathgrid->toggleRenderMode(mode);
+        else if (mode == Render_Wireframe)
+        {
+            bool wireframe = !mStateUpdater->getWireframe();
+            mStateUpdater->setWireframe(wireframe);
+            return wireframe;
+        }
+        else if (mode == Render_Water)
+        {
+            return mWater->toggle();
+        }
+        else if (mode == Render_Scene)
+        {
+            const auto wm = MWBase::Environment::get().getWindowManager();
+            unsigned int mask = wm->getCullMask();
+            bool enabled = !(mask & sToggleWorldMask);
+            if (enabled)
+                mask |= sToggleWorldMask;
+            else
+                mask &= ~sToggleWorldMask;
+            mWater->showWorld(enabled);
+            wm->setCullMask(mask);
+            return enabled;
+        }
+        else if (mode == Render_NavMesh)
+        {
+            return mNavMesh->toggle();
+        }
+        else if (mode == Render_ActorsPaths)
+        {
+            return mActorsPaths->toggle();
+        }
+        else if (mode == Render_RecastMesh)
+        {
+            return mRecastMesh->toggle();
+        }
+        return false;
+    }
+
+    void RenderingManager::configureFog(const MWWorld::Cell& cell)
+    {
+        mFog->configure(mViewDistance, cell);
+    }
+
+    void RenderingManager::configureFog(
+        float fogDepth, float underwaterFog, float dlFactor, float dlOffset, const osg::Vec4f& color)
+    {
+        mFog->configure(mViewDistance, fogDepth, underwaterFog, dlFactor, dlOffset, color);
+    }
+
+    SkyManager* RenderingManager::getSkyManager()
+    {
+        return mSky.get();
+    }
+
+    void RenderingManager::update(float dt, bool paused)
+    {
+        reportStats();
+
+        mResourceSystem->getSceneManager()->getShaderManager().update(*mViewer);
+
+        float rainIntensity = mSky->getPrecipitationAlpha();
+        mWater->setRainIntensity(rainIntensity);
+        mWater->setRainRipplesEnabled(mSky->getRainRipplesEnabled());
+
+        mWater->update(dt, paused);
+        if (!paused)
+        {
+            mEffectManager->update(dt);
+            mSky->update(dt);
+
+            const MWWorld::Ptr& player = mPlayerAnimation->getPtr();
+            osg::Vec3f playerPos(player.getRefData().getPosition().asVec3());
+
+            float windSpeed = mSky->getBaseWindSpeed();
+            mSharedUniformStateUpdater->setWindSpeed(windSpeed);
+            mSharedUniformStateUpdater->setPlayerPos(playerPos);
+        }
+
+        updateNavMesh();
+        updateRecastMesh();
+
+        if (mUpdateProjectionMatrix)
+        {
+            mUpdateProjectionMatrix = false;
+            updateProjectionMatrix();
+        }
+        mCamera->update(dt, paused);
+
+        bool isUnderwater = mWater->isUnderwater(mCamera->getPosition());
+
+        float fogStart = mFog->getFogStart(isUnderwater);
+        float fogEnd = mFog->getFogEnd(isUnderwater);
+        osg::Vec4f fogColor = mFog->getFogColor(isUnderwater);
+
+        mStateUpdater->setFogStart(fogStart);
+        mStateUpdater->setFogEnd(fogEnd);
+        setFogColor(fogColor);
+
+        auto world = MWBase::Environment::get().getWorld();
+        const auto& stateUpdater = mPostProcessor->getStateUpdater();
+
+        stateUpdater->setFogRange(fogStart, fogEnd);
+        stateUpdater->setNearFar(mNearClip, mViewDistance);
+        stateUpdater->setIsUnderwater(isUnderwater);
+        stateUpdater->setFogColor(fogColor);
+        stateUpdater->setGameHour(world->getTimeStamp().getHour());
+        stateUpdater->setWeatherId(world->getCurrentWeather());
+        stateUpdater->setNextWeatherId(world->getNextWeather());
+        stateUpdater->setWeatherTransition(world->getWeatherTransition());
+        stateUpdater->setWindSpeed(world->getWindSpeed());
+        stateUpdater->setSkyColor(mSky->getSkyColor());
+        mPostProcessor->setUnderwaterFlag(isUnderwater);
+    }
+
+    void RenderingManager::updatePlayerPtr(const MWWorld::Ptr& ptr)
+    {
+        if (mPlayerAnimation.get())
+        {
+            setupPlayer(ptr);
+            mPlayerAnimation->updatePtr(ptr);
+        }
+        mCamera->attachTo(ptr);
+    }
+
+    void RenderingManager::removePlayer(const MWWorld::Ptr& player)
+    {
+        mWater->removeEmitter(player);
+    }
+
+    void RenderingManager::rotateObject(const MWWorld::Ptr& ptr, const osg::Quat& rot)
+    {
+        if (ptr == mCamera->getTrackingPtr() && !mCamera->isVanityOrPreviewModeEnabled())
+        {
+            mCamera->rotateCameraToTrackingPtr();
+        }
+
+        ptr.getRefData().getBaseNode()->setAttitude(rot);
+    }
+
+    void RenderingManager::moveObject(const MWWorld::Ptr& ptr, const osg::Vec3f& pos)
+    {
+        ptr.getRefData().getBaseNode()->setPosition(pos);
+    }
+
+    void RenderingManager::scaleObject(const MWWorld::Ptr& ptr, const osg::Vec3f& scale)
+    {
+        ptr.getRefData().getBaseNode()->setScale(scale);
+
+        if (ptr == mCamera->getTrackingPtr()) // update height of camera
+            mCamera->processViewChange();
+    }
+
+    void RenderingManager::removeObject(const MWWorld::Ptr& ptr)
+    {
+        mActorsPaths->remove(ptr);
+        mObjects->removeObject(ptr);
+        mWater->removeEmitter(ptr);
+    }
+
+    void RenderingManager::setWaterEnabled(bool enabled)
+    {
+        mWater->setEnabled(enabled);
+        mSky->setWaterEnabled(enabled);
+
+        mPostProcessor->getStateUpdater()->setIsWaterEnabled(enabled);
+    }
+
+    void RenderingManager::setWaterHeight(float height)
+    {
+        mWater->setCullCallback(mTerrain->getHeightCullCallback(height, Mask_Water));
+        mWater->setHeight(height);
+        mSky->setWaterHeight(height);
+
+        mPostProcessor->getStateUpdater()->setWaterHeight(height);
+    }
+
+    void RenderingManager::screenshot(osg::Image* image, int w, int h)
+    {
+        mScreenshotManager->screenshot(image, w, h);
+    }
+
+    bool RenderingManager::screenshot360(osg::Image* image)
+    {
+        if (mCamera->isVanityOrPreviewModeEnabled())
+        {
+            Log(Debug::Warning) << "Spherical screenshots are not allowed in preview mode.";
+            return false;
+        }
+
+        mScreenshotManager->screenshot360(image);
+
+        return true;
+    }
+
+    osg::Vec4f RenderingManager::getScreenBounds(const osg::BoundingBox& worldbb)
+    {
+        if (!worldbb.valid())
+            return osg::Vec4f();
+        osg::Matrix viewProj = mViewer->getCamera()->getViewMatrix() * mViewer->getCamera()->getProjectionMatrix();
+        float min_x = 1.0f, max_x = 0.0f, min_y = 1.0f, max_y = 0.0f;
+        for (int i = 0; i < 8; ++i)
+        {
+            osg::Vec3f corner = worldbb.corner(i);
+            corner = corner * viewProj;
+
+            float x = (corner.x() + 1.f) * 0.5f;
+            float y = (corner.y() - 1.f) * (-0.5f);
+
+            if (x < min_x)
+                min_x = x;
+
+            if (x > max_x)
+                max_x = x;
+
+            if (y < min_y)
+                min_y = y;
+
+            if (y > max_y)
+                max_y = y;
+        }
+
+        return osg::Vec4f(min_x, min_y, max_x, max_y);
+    }
+
+    RenderingManager::RayResult getIntersectionResult(osgUtil::LineSegmentIntersector* intersector,
+        const osg::ref_ptr<osgUtil::IntersectionVisitor>& visitor, std::span<const MWWorld::Ptr> ignoreList = {})
+    {
+        RenderingManager::RayResult result;
+        result.mHit = false;
+        result.mRatio = 0;
+
+        if (!intersector->containsIntersections())
+            return result;
+
+        auto test = [&](const osgUtil::LineSegmentIntersector::Intersection& intersection) {
+            PtrHolder* ptrHolder = nullptr;
+            std::vector<RefnumMarker*> refnumMarkers;
+            for (osg::NodePath::const_iterator it = intersection.nodePath.begin(); it != intersection.nodePath.end();
+                 ++it)
+            {
+                osg::UserDataContainer* userDataContainer = (*it)->getUserDataContainer();
+                if (!userDataContainer)
+                    continue;
+                for (unsigned int i = 0; i < userDataContainer->getNumUserObjects(); ++i)
+                {
+                    if (PtrHolder* p = dynamic_cast<PtrHolder*>(userDataContainer->getUserObject(i)))
+                    {
+                        if (std::find(ignoreList.begin(), ignoreList.end(), p->mPtr) == ignoreList.end())
+                        {
+                            ptrHolder = p;
+                        }
+                    }
+                    if (RefnumMarker* r = dynamic_cast<RefnumMarker*>(userDataContainer->getUserObject(i)))
+                    {
+                        refnumMarkers.push_back(r);
+                    }
+                }
+            }
+
+            if (ptrHolder)
+                result.mHitObject = ptrHolder->mPtr;
+
+            unsigned int vertexCounter = 0;
+            for (unsigned int i = 0; i < refnumMarkers.size(); ++i)
+            {
+                unsigned int intersectionIndex = intersection.indexList.empty() ? 0 : intersection.indexList[0];
+                if (!refnumMarkers[i]->mNumVertices
+                    || (intersectionIndex >= vertexCounter
+                        && intersectionIndex < vertexCounter + refnumMarkers[i]->mNumVertices))
+                {
+                    auto it = std::find_if(
+                        ignoreList.begin(), ignoreList.end(), [target = refnumMarkers[i]->mRefnum](const auto& ptr) {
+                            return target == ptr.getCellRef().getRefNum();
+                        });
+
+                    if (it == ignoreList.end())
+                    {
+                        result.mHitRefnum = refnumMarkers[i]->mRefnum;
+                    }
+
+                    break;
+                }
+                vertexCounter += refnumMarkers[i]->mNumVertices;
+            }
+
+            if (!result.mHitObject.isEmpty() || result.mHitRefnum.isSet())
+            {
+                result.mHit = true;
+                result.mHitPointWorld = intersection.getWorldIntersectPoint();
+                result.mHitNormalWorld = intersection.getWorldIntersectNormal();
+                result.mRatio = intersection.ratio;
+            }
+        };
+
+        if (ignoreList.empty() || intersector->getIntersectionLimit() != osgUtil::LineSegmentIntersector::NO_LIMIT)
+        {
+            test(intersector->getFirstIntersection());
+        }
+        else
+        {
+            for (const auto& intersection : intersector->getIntersections())
+            {
+                test(intersection);
+
+                if (result.mHit)
+                {
+                    break;
+                }
+            }
+        }
+
+        return result;
+    }
+
+    class IntersectionVisitorWithIgnoreList : public osgUtil::IntersectionVisitor
+    {
+    public:
+        bool skipTransform(osg::Transform& transform)
+        {
+            if (mContainsPagedRefs)
+                return false;
+
+            osg::UserDataContainer* userDataContainer = transform.getUserDataContainer();
+            if (!userDataContainer)
+                return false;
+
+            for (unsigned int i = 0; i < userDataContainer->getNumUserObjects(); ++i)
+            {
+                if (PtrHolder* p = dynamic_cast<PtrHolder*>(userDataContainer->getUserObject(i)))
+                {
+                    if (std::find(mIgnoreList.begin(), mIgnoreList.end(), p->mPtr) != mIgnoreList.end())
+                    {
+                        return true;
+                    }
+                }
+            }
+
+            return false;
+        }
+
+        void apply(osg::Transform& transform) override
+        {
+            if (skipTransform(transform))
+            {
+                return;
+            }
+            osgUtil::IntersectionVisitor::apply(transform);
+        }
+
+        void setIgnoreList(std::span<const MWWorld::Ptr> ignoreList) { mIgnoreList = ignoreList; }
+        void setContainsPagedRefs(bool contains) { mContainsPagedRefs = contains; }
+
+    private:
+        std::span<const MWWorld::Ptr> mIgnoreList;
+        bool mContainsPagedRefs = false;
+    };
+
+    osg::ref_ptr<osgUtil::IntersectionVisitor> RenderingManager::getIntersectionVisitor(
+        osgUtil::Intersector* intersector, bool ignorePlayer, bool ignoreActors,
+        std::span<const MWWorld::Ptr> ignoreList)
+    {
+        if (!mIntersectionVisitor)
+            mIntersectionVisitor = new IntersectionVisitorWithIgnoreList;
+
+        mIntersectionVisitor->setIgnoreList(ignoreList);
+        mIntersectionVisitor->setContainsPagedRefs(false);
+
+        MWWorld::Scene* worldScene = MWBase::Environment::get().getWorldScene();
+        for (const auto& ptr : ignoreList)
+        {
+            if (worldScene->isPagedRef(ptr))
+            {
+                mIntersectionVisitor->setContainsPagedRefs(true);
+                intersector->setIntersectionLimit(osgUtil::LineSegmentIntersector::NO_LIMIT);
+                break;
+            }
+        }
+
+        mIntersectionVisitor->setTraversalNumber(mViewer->getFrameStamp()->getFrameNumber());
+        mIntersectionVisitor->setFrameStamp(mViewer->getFrameStamp());
+        mIntersectionVisitor->setIntersector(intersector);
+
+        unsigned int mask = ~0u;
+        mask &= ~(Mask_RenderToTexture | Mask_Sky | Mask_Debug | Mask_Effect | Mask_Water | Mask_SimpleWater
+            | Mask_Groundcover);
+        if (ignorePlayer)
+            mask &= ~(Mask_Player);
+        if (ignoreActors)
+            mask &= ~(Mask_Actor | Mask_Player);
+
+        mIntersectionVisitor->setTraversalMask(mask);
+        return mIntersectionVisitor;
+    }
+
+    RenderingManager::RayResult RenderingManager::castRay(const osg::Vec3f& origin, const osg::Vec3f& dest,
+        bool ignorePlayer, bool ignoreActors, std::span<const MWWorld::Ptr> ignoreList)
+    {
+        osg::ref_ptr<osgUtil::LineSegmentIntersector> intersector(
+            new osgUtil::LineSegmentIntersector(osgUtil::LineSegmentIntersector::MODEL, origin, dest));
+        intersector->setIntersectionLimit(osgUtil::LineSegmentIntersector::LIMIT_NEAREST);
+
+        mRootNode->accept(*getIntersectionVisitor(intersector, ignorePlayer, ignoreActors, ignoreList));
+
+        return getIntersectionResult(intersector, mIntersectionVisitor, ignoreList);
+    }
+
+    RenderingManager::RayResult RenderingManager::castCameraToViewportRay(
+        const float nX, const float nY, float maxDistance, bool ignorePlayer, bool ignoreActors)
+    {
+        osg::ref_ptr<osgUtil::LineSegmentIntersector> intersector(new osgUtil::LineSegmentIntersector(
+            osgUtil::LineSegmentIntersector::PROJECTION, nX * 2.f - 1.f, nY * (-2.f) + 1.f));
+
+        osg::Vec3d dist(0.f, 0.f, -maxDistance);
+
+        dist = dist * mViewer->getCamera()->getProjectionMatrix();
+
+        osg::Vec3d end = intersector->getEnd();
+        end.z() = dist.z();
+        intersector->setEnd(end);
+        intersector->setIntersectionLimit(osgUtil::LineSegmentIntersector::LIMIT_NEAREST);
+
+        mViewer->getCamera()->accept(*getIntersectionVisitor(intersector, ignorePlayer, ignoreActors));
+
+        return getIntersectionResult(intersector, mIntersectionVisitor);
+    }
+
+    void RenderingManager::updatePtr(const MWWorld::Ptr& old, const MWWorld::Ptr& updated)
+    {
+        mObjects->updatePtr(old, updated);
+        mActorsPaths->updatePtr(old, updated);
+    }
+
+    void RenderingManager::spawnEffect(const std::string& model, std::string_view texture,
+        const osg::Vec3f& worldPosition, float scale, bool isMagicVFX)
+    {
+        mEffectManager->addEffect(model, texture, worldPosition, scale, isMagicVFX);
+    }
+
+    void RenderingManager::notifyWorldSpaceChanged()
+    {
+        mEffectManager->clear();
+        mWater->clearRipples();
+    }
+
+    void RenderingManager::clear()
+    {
+        mSky->setMoonColour(false);
+
+        notifyWorldSpaceChanged();
+        if (mObjectPaging)
+            mObjectPaging->clear();
+    }
+
+    MWRender::Animation* RenderingManager::getAnimation(const MWWorld::Ptr& ptr)
+    {
+        if (mPlayerAnimation.get() && ptr == mPlayerAnimation->getPtr())
+            return mPlayerAnimation.get();
+
+        return mObjects->getAnimation(ptr);
+    }
+
+    const MWRender::Animation* RenderingManager::getAnimation(const MWWorld::ConstPtr& ptr) const
+    {
+        if (mPlayerAnimation.get() && ptr == mPlayerAnimation->getPtr())
+            return mPlayerAnimation.get();
+
+        return mObjects->getAnimation(ptr);
+    }
+
+    PostProcessor* RenderingManager::getPostProcessor()
+    {
+        return mPostProcessor;
+    }
+
+    void RenderingManager::setupPlayer(const MWWorld::Ptr& player)
+    {
+        if (!mPlayerNode)
+        {
+            mPlayerNode = new SceneUtil::PositionAttitudeTransform;
+            mPlayerNode->setNodeMask(Mask_Player);
+            mPlayerNode->setName("Player Root");
+            mSceneRoot->addChild(mPlayerNode);
+        }
+
+        mPlayerNode->setUserDataContainer(new osg::DefaultUserDataContainer);
+        mPlayerNode->getUserDataContainer()->addUserObject(new PtrHolder(player));
+
+        player.getRefData().setBaseNode(mPlayerNode);
+
+        mWater->removeEmitter(player);
+        mWater->addEmitter(player);
+    }
+
+    void RenderingManager::renderPlayer(const MWWorld::Ptr& player)
+    {
+        mPlayerAnimation = new NpcAnimation(player, player.getRefData().getBaseNode(), mResourceSystem, 0,
+            NpcAnimation::VM_Normal, mFirstPersonFieldOfView);
+
+        mCamera->setAnimation(mPlayerAnimation.get());
+        mCamera->attachTo(player);
+    }
+
+    void RenderingManager::rebuildPtr(const MWWorld::Ptr& ptr)
+    {
+        NpcAnimation* anim = nullptr;
+        if (ptr == mPlayerAnimation->getPtr())
+            anim = mPlayerAnimation.get();
+        else
+            anim = dynamic_cast<NpcAnimation*>(mObjects->getAnimation(ptr));
+        if (anim)
+        {
+            anim->rebuild();
+            if (mCamera->getTrackingPtr() == ptr)
+            {
+                mCamera->attachTo(ptr);
+                mCamera->setAnimation(anim);
+            }
+        }
+    }
+
+    void RenderingManager::addWaterRippleEmitter(const MWWorld::Ptr& ptr)
+    {
+        mWater->addEmitter(ptr);
+    }
+
+    void RenderingManager::removeWaterRippleEmitter(const MWWorld::Ptr& ptr)
+    {
+        mWater->removeEmitter(ptr);
+    }
+
+    void RenderingManager::emitWaterRipple(const osg::Vec3f& pos)
+    {
+        mWater->emitRipple(pos);
+    }
+
+    void RenderingManager::updateProjectionMatrix()
+    {
+        if (mNearClip < 0.0f)
+            throw std::runtime_error("Near clip is less than zero");
+        if (mViewDistance < mNearClip)
+            throw std::runtime_error("Viewing distance is less than near clip");
+
+        const double width = Settings::video().mResolutionX;
+        const double height = Settings::video().mResolutionY;
+
+        double aspect = (height == 0.0) ? 1.0 : width / height;
+        float fov = mFieldOfView;
+        if (mFieldOfViewOverridden)
+            fov = mFieldOfViewOverride;
+
+        mViewer->getCamera()->setProjectionMatrixAsPerspective(fov, aspect, mNearClip, mViewDistance);
+
+        if (SceneUtil::AutoDepth::isReversed())
+        {
+            mPerViewUniformStateUpdater->setProjectionMatrix(
+                SceneUtil::getReversedZProjectionMatrixAsPerspective(fov, aspect, mNearClip, mViewDistance));
+        }
+        else
+            mPerViewUniformStateUpdater->setProjectionMatrix(mViewer->getCamera()->getProjectionMatrix());
+
+        mSharedUniformStateUpdater->setNear(mNearClip);
+        mSharedUniformStateUpdater->setFar(mViewDistance);
+        if (Stereo::getStereo())
+        {
+            auto res = Stereo::Manager::instance().eyeResolution();
+            mSharedUniformStateUpdater->setScreenRes(res.x(), res.y());
+            Stereo::Manager::instance().setMasterProjectionMatrix(mPerViewUniformStateUpdater->getProjectionMatrix());
+        }
+        else
+        {
+            mSharedUniformStateUpdater->setScreenRes(width, height);
+        }
+
+        // Since our fog is not radial yet, we should take FOV in account, otherwise terrain near viewing distance may
+        // disappear. Limit FOV here just for sure, otherwise viewing distance can be too high.
+        float distanceMult = std::cos(osg::DegreesToRadians(std::min(fov, 140.f)) / 2.f);
+        mTerrain->setViewDistance(mViewDistance * (distanceMult ? 1.f / distanceMult : 1.f));
+
+        if (mPostProcessor)
+        {
+            mPostProcessor->getStateUpdater()->setProjectionMatrix(mPerViewUniformStateUpdater->getProjectionMatrix());
+            mPostProcessor->getStateUpdater()->setFov(fov);
+        }
+    }
+
+    void RenderingManager::setScreenRes(int width, int height)
+    {
+        mSharedUniformStateUpdater->setScreenRes(width, height);
+    }
+
+    void RenderingManager::updateTextureFiltering()
+    {
+        mViewer->stopThreading();
+
+        mResourceSystem->getSceneManager()->setFilterSettings(Settings::general().mTextureMagFilter,
+            Settings::general().mTextureMinFilter, Settings::general().mTextureMipmap, Settings::general().mAnisotropy);
+
+        mTerrain->updateTextureFiltering();
+        mWater->processChangedSettings({});
+
+        mViewer->startThreading();
+    }
+
+    void RenderingManager::updateAmbient()
+    {
+        osg::Vec4f color = mAmbientColor;
+
+        if (mNightEyeFactor > 0.f)
+            color += osg::Vec4f(0.7, 0.7, 0.7, 0.0) * mNightEyeFactor;
+
+        mPostProcessor->getStateUpdater()->setAmbientColor(color);
+        mStateUpdater->setAmbientColor(color);
+    }
+
+    void RenderingManager::setFogColor(const osg::Vec4f& color)
+    {
+        mViewer->getCamera()->setClearColor(color);
+
+        mStateUpdater->setFogColor(color);
+    }
+
+    RenderingManager::WorldspaceChunkMgr& RenderingManager::getWorldspaceChunkMgr(ESM::RefId worldspace)
+    {
+        auto existingChunkMgr = mWorldspaceChunks.find(worldspace);
+        if (existingChunkMgr != mWorldspaceChunks.end())
+            return existingChunkMgr->second;
+        RenderingManager::WorldspaceChunkMgr newChunkMgr;
+
+        const float lodFactor = Settings::terrain().mLodFactor;
+        const bool groundcover = Settings::groundcover().mEnabled;
+        const bool distantTerrain = Settings::terrain().mDistantTerrain;
+        const double expiryDelay = Settings::cells().mCacheExpiryDelay;
+        if (distantTerrain || groundcover)
+        {
+            const int compMapResolution = Settings::terrain().mCompositeMapResolution;
+            const int compMapPower = Settings::terrain().mCompositeMapLevel;
+            const float compMapLevel = std::pow(2, compMapPower);
+            const int vertexLodMod = Settings::terrain().mVertexLodMod;
+            const float maxCompGeometrySize = Settings::terrain().mMaxCompositeGeometrySize;
+            const bool debugChunks = Settings::terrain().mDebugChunks;
+            auto quadTreeWorld = std::make_unique<Terrain::QuadTreeWorld>(mSceneRoot, mRootNode, mResourceSystem,
+                mTerrainStorage.get(), Mask_Terrain, Mask_PreCompile, Mask_Debug, compMapResolution, compMapLevel,
+                lodFactor, vertexLodMod, maxCompGeometrySize, debugChunks, worldspace, expiryDelay);
+            if (Settings::terrain().mObjectPaging)
+            {
+                newChunkMgr.mObjectPaging
+                    = std::make_unique<ObjectPaging>(mResourceSystem->getSceneManager(), worldspace);
+                quadTreeWorld->addChunkManager(newChunkMgr.mObjectPaging.get());
+                mResourceSystem->addResourceManager(newChunkMgr.mObjectPaging.get());
+            }
+            if (groundcover)
+            {
+                const float groundcoverDistance = Settings::groundcover().mRenderingDistance;
+                const float density = Settings::groundcover().mDensity;
+
+                newChunkMgr.mGroundcover = std::make_unique<Groundcover>(
+                    mResourceSystem->getSceneManager(), density, groundcoverDistance, mGroundCoverStore);
+                quadTreeWorld->addChunkManager(newChunkMgr.mGroundcover.get());
+                mResourceSystem->addResourceManager(newChunkMgr.mGroundcover.get());
+            }
+            newChunkMgr.mTerrain = std::move(quadTreeWorld);
+        }
+        else
+            newChunkMgr.mTerrain = std::make_unique<Terrain::TerrainGrid>(mSceneRoot, mRootNode, mResourceSystem,
+                mTerrainStorage.get(), Mask_Terrain, worldspace, expiryDelay, Mask_PreCompile, Mask_Debug);
+
+        newChunkMgr.mTerrain->setTargetFrameRate(Settings::cells().mTargetFramerate);
+        float distanceMult = std::cos(osg::DegreesToRadians(std::min(mFieldOfView, 140.f)) / 2.f);
+        newChunkMgr.mTerrain->setViewDistance(mViewDistance * (distanceMult ? 1.f / distanceMult : 1.f));
+
+        return mWorldspaceChunks.emplace(worldspace, std::move(newChunkMgr)).first->second;
+    }
+
+    void RenderingManager::reportStats() const
+    {
+        osg::Stats* stats = mViewer->getViewerStats();
+        unsigned int frameNumber = mViewer->getFrameStamp()->getFrameNumber();
+        if (stats->collectStats("resource"))
+        {
+            mTerrain->reportStats(frameNumber, stats);
+        }
+    }
+
+    void RenderingManager::processChangedSettings(const Settings::CategorySettingVector& changed)
+    {
+        // Only perform a projection matrix update once if a relevant setting is changed.
+        bool updateProjection = false;
+
+        for (Settings::CategorySettingVector::const_iterator it = changed.begin(); it != changed.end(); ++it)
+        {
+            if (it->first == "Camera" && it->second == "field of view")
+            {
+                mFieldOfView = Settings::camera().mFieldOfView;
+                updateProjection = true;
+            }
+            else if (it->first == "Video" && (it->second == "resolution x" || it->second == "resolution y"))
+            {
+                updateProjection = true;
+            }
+            else if (it->first == "Camera" && it->second == "viewing distance")
+            {
+                setViewDistance(Settings::camera().mViewingDistance);
+            }
+            else if (it->first == "General"
+                && (it->second == "texture filter" || it->second == "texture mipmap" || it->second == "anisotropy"))
+            {
+                updateTextureFiltering();
+            }
+            else if (it->first == "Water")
+            {
+                mWater->processChangedSettings(changed);
+            }
+            else if (it->first == "Shaders" && it->second == "minimum interior brightness")
+            {
+                if (MWMechanics::getPlayer().isInCell())
+                    configureAmbient(*MWMechanics::getPlayer().getCell()->getCell());
+            }
+            else if (it->first == "Shaders"
+                && (it->second == "light bounds multiplier" || it->second == "maximum light distance"
+                    || it->second == "light fade start" || it->second == "max lights"))
+            {
+                auto* lightManager = getLightRoot();
+
+                lightManager->processChangedSettings(Settings::shaders().mLightBoundsMultiplier,
+                    Settings::shaders().mMaximumLightDistance, Settings::shaders().mLightFadeStart);
+
+                if (it->second == "max lights" && !lightManager->usingFFP())
+                {
+                    mViewer->stopThreading();
+
+                    lightManager->updateMaxLights(Settings::shaders().mMaxLights);
+
+                    auto defines = mResourceSystem->getSceneManager()->getShaderManager().getGlobalDefines();
+                    for (const auto& [name, key] : lightManager->getLightDefines())
+                        defines[name] = key;
+                    mResourceSystem->getSceneManager()->getShaderManager().setGlobalDefines(defines);
+
+                    mStateUpdater->reset();
+
+                    mViewer->startThreading();
+                }
+            }
+            else if (it->first == "Post Processing" && it->second == "enabled")
+            {
+                if (Settings::postProcessing().mEnabled)
+                    mPostProcessor->enable();
+                else
+                {
+                    mPostProcessor->disable();
+                    if (auto* hud = MWBase::Environment::get().getWindowManager()->getPostProcessorHud())
+                        hud->setVisible(false);
+                }
+            }
+        }
+
+        if (updateProjection)
+        {
+            updateProjectionMatrix();
+        }
+    }
+
+    void RenderingManager::setViewDistance(float distance, bool delay)
+    {
+        mViewDistance = distance;
+
+        if (delay)
+        {
+            mUpdateProjectionMatrix = true;
+            return;
+        }
+
+        updateProjectionMatrix();
+    }
+
+    float RenderingManager::getTerrainHeightAt(const osg::Vec3f& pos, ESM::RefId worldspace)
+    {
+        return getWorldspaceChunkMgr(worldspace).mTerrain->getHeightAt(pos);
+    }
+
+    void RenderingManager::overrideFieldOfView(float val)
+    {
+        if (mFieldOfViewOverridden != true || mFieldOfViewOverride != val)
+        {
+            mFieldOfViewOverridden = true;
+            mFieldOfViewOverride = val;
+            updateProjectionMatrix();
+        }
+    }
+
+    void RenderingManager::setFieldOfView(float val)
+    {
+        mFieldOfView = val;
+        mUpdateProjectionMatrix = true;
+    }
+
+    float RenderingManager::getFieldOfView() const
+    {
+        return mFieldOfViewOverridden ? mFieldOfViewOverridden : mFieldOfView;
+    }
+
+    osg::Vec3f RenderingManager::getHalfExtents(const MWWorld::ConstPtr& object) const
+    {
+        osg::Vec3f halfExtents(0, 0, 0);
+        std::string modelName = object.getClass().getCorrectedModel(object);
+        if (modelName.empty())
+            return halfExtents;
+
+        osg::ref_ptr<const osg::Node> node = mResourceSystem->getSceneManager()->getTemplate(modelName);
+        osg::ComputeBoundsVisitor computeBoundsVisitor;
+        computeBoundsVisitor.setTraversalMask(~(MWRender::Mask_ParticleSystem | MWRender::Mask_Effect));
+        const_cast<osg::Node*>(node.get())->accept(computeBoundsVisitor);
+        osg::BoundingBox bounds = computeBoundsVisitor.getBoundingBox();
+
+        if (bounds.valid())
+        {
+            halfExtents[0] = std::abs(bounds.xMax() - bounds.xMin()) / 2.f;
+            halfExtents[1] = std::abs(bounds.yMax() - bounds.yMin()) / 2.f;
+            halfExtents[2] = std::abs(bounds.zMax() - bounds.zMin()) / 2.f;
+        }
+
+        return halfExtents;
+    }
+
+    osg::BoundingBox RenderingManager::getCullSafeBoundingBox(const MWWorld::Ptr& ptr) const
+    {
+        const std::string model = ptr.getClass().getCorrectedModel(ptr);
+        if (model.empty())
+            return {};
+
+        osg::ref_ptr<SceneUtil::PositionAttitudeTransform> rootNode = new SceneUtil::PositionAttitudeTransform;
+        // Hack even used by osg internally, osg's NodeVisitor won't accept const qualified nodes
+        rootNode->addChild(const_cast<osg::Node*>(mResourceSystem->getSceneManager()->getTemplate(model).get()));
+
+        const float refScale = ptr.getCellRef().getScale();
+        rootNode->setScale({ refScale, refScale, refScale });
+        rootNode->setPosition(osg::Vec3(0, 0, 0));
+
+        osg::ref_ptr<Animation> animation = nullptr;
+
+        if (ptr.getClass().isNpc())
+        {
+            rootNode->setNodeMask(Mask_Actor);
+            animation = new NpcAnimation(ptr, osg::ref_ptr<osg::Group>(rootNode), mResourceSystem);
+        }
+
+        SceneUtil::CullSafeBoundsVisitor computeBounds;
+        computeBounds.setTraversalMask(~(MWRender::Mask_ParticleSystem | MWRender::Mask_Effect));
+        rootNode->accept(computeBounds);
+
+        return computeBounds.mBoundingBox;
+    }
+
+    void RenderingManager::resetFieldOfView()
+    {
+        if (mFieldOfViewOverridden == true)
+        {
+            mFieldOfViewOverridden = false;
+
+            updateProjectionMatrix();
+        }
+    }
+    void RenderingManager::exportSceneGraph(
+        const MWWorld::Ptr& ptr, const std::filesystem::path& filename, const std::string& format)
+    {
+        osg::Node* node = mViewer->getSceneData();
+        if (!ptr.isEmpty())
+            node = ptr.getRefData().getBaseNode();
+
+        SceneUtil::writeScene(node, filename, format);
+    }
+
+    LandManager* RenderingManager::getLandManager() const
+    {
+        return mTerrainStorage->getLandManager();
+    }
+
+    void RenderingManager::updateActorPath(const MWWorld::ConstPtr& actor, const std::deque<osg::Vec3f>& path,
+        const DetourNavigator::AgentBounds& agentBounds, const osg::Vec3f& start, const osg::Vec3f& end) const
+    {
+        mActorsPaths->update(actor, path, agentBounds, start, end, mNavigator.getSettings());
+    }
+
+    void RenderingManager::removeActorPath(const MWWorld::ConstPtr& actor) const
+    {
+        mActorsPaths->remove(actor);
+    }
+
+    void RenderingManager::setNavMeshNumber(const std::size_t value)
+    {
+        mNavMeshNumber = value;
+    }
+
+    void RenderingManager::updateNavMesh()
+    {
+        if (!mNavMesh->isEnabled())
+            return;
+
+        const auto navMeshes = mNavigator.getNavMeshes();
+
+        auto it = navMeshes.begin();
+        for (std::size_t i = 0; it != navMeshes.end() && i < mNavMeshNumber; ++i)
+            ++it;
+        if (it == navMeshes.end())
+        {
+            mNavMesh->reset();
+        }
+        else
+        {
+            try
+            {
+                mNavMesh->update(it->second, mNavMeshNumber, mNavigator.getSettings());
+            }
+            catch (const std::exception& e)
+            {
+                Log(Debug::Error) << "NavMesh render update exception: " << e.what();
+            }
+        }
+    }
+
+    void RenderingManager::updateRecastMesh()
+    {
+        if (!mRecastMesh->isEnabled())
+            return;
+
+        mRecastMesh->update(mNavigator.getRecastMeshTiles(), mNavigator.getSettings());
+    }
+
+    void RenderingManager::setActiveGrid(const osg::Vec4i& grid)
+    {
+        mTerrain->setActiveGrid(grid);
+    }
+    bool RenderingManager::pagingEnableObject(int type, const MWWorld::ConstPtr& ptr, bool enabled)
+    {
+        if (!ptr.isInCell() || !ptr.getCell()->isExterior() || !mObjectPaging)
+            return false;
+        if (mObjectPaging->enableObject(type, ptr.getCellRef().getRefNum(), ptr.getCellRef().getPosition().asVec3(),
+                osg::Vec2i(ptr.getCell()->getCell()->getGridX(), ptr.getCell()->getCell()->getGridY()), enabled))
+        {
+            mTerrain->rebuildViews();
+            return true;
+        }
+        return false;
+    }
+    void RenderingManager::pagingBlacklistObject(int type, const MWWorld::ConstPtr& ptr)
+    {
+        if (!ptr.isInCell() || !ptr.getCell()->isExterior() || !mObjectPaging)
+            return;
+        ESM::RefNum refnum = ptr.getCellRef().getRefNum();
+        if (!refnum.hasContentFile())
+            return;
+        if (mObjectPaging->blacklistObject(type, refnum, ptr.getCellRef().getPosition().asVec3(),
+                osg::Vec2i(ptr.getCell()->getCell()->getGridX(), ptr.getCell()->getCell()->getGridY())))
+            mTerrain->rebuildViews();
+    }
+    bool RenderingManager::pagingUnlockCache()
+    {
+        if (mObjectPaging && mObjectPaging->unlockCache())
+        {
+            mTerrain->rebuildViews();
+            return true;
+        }
+        return false;
+    }
+    void RenderingManager::getPagedRefnums(const osg::Vec4i& activeGrid, std::vector<ESM::RefNum>& out)
+    {
+        if (mObjectPaging)
+            mObjectPaging->getPagedRefnums(activeGrid, out);
+    }
+
+    void RenderingManager::setNavMeshMode(Settings::NavMeshRenderMode value)
+    {
+        mNavMesh->setMode(value);
+    }
+}
diff --git a/apps/openmw/mwrender/transparentpass.cpp b/apps/openmw/mwrender/transparentpass.cpp
index ce53b1c2193..cdda1d4fe39 100644
--- a/apps/openmw/mwrender/transparentpass.cpp
+++ b/apps/openmw/mwrender/transparentpass.cpp
@@ -92,8 +92,9 @@ namespace MWRender
         else
         {
             opaqueFbo->apply(state, osg::FrameBufferObject::DRAW_FRAMEBUFFER);
-            ext->glBlitFramebuffer(0, 0, tex->getTextureWidth(), tex->getTextureHeight(), 0, 0, tex->getTextureWidth(),
-                tex->getTextureHeight(), GL_DEPTH_BUFFER_BIT, GL_NEAREST);
+            //ext->glBlitFramebuffer(0, 0, tex->getTextureWidth(), tex->getTextureHeight(), 0, 0, tex->getTextureWidth(),
+                //tex->getTextureHeight(), GL_DEPTH_BUFFER_BIT, GL_NEAREST);
+            glClear(GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
         }
 
         msaaFbo ? msaaFbo->apply(state, osg::FrameBufferObject::DRAW_FRAMEBUFFER)
@@ -105,7 +106,7 @@ namespace MWRender
         if (!mPostPass)
             return;
 
-        opaqueFbo->apply(state, osg::FrameBufferObject::DRAW_FRAMEBUFFER);
+        //opaqueFbo->apply(state, osg::FrameBufferObject::DRAW_FRAMEBUFFER);
 
         // draw transparent post-pass to populate a postprocess friendly depth texture with alpha-clipped geometry
 
diff --git a/apps/openmw/mwrender/water.cpp b/apps/openmw/mwrender/water.cpp
index 9fdb0583a21..6f32f3a237b 100644
--- a/apps/openmw/mwrender/water.cpp
+++ b/apps/openmw/mwrender/water.cpp
@@ -555,9 +555,12 @@ namespace MWRender
                 mParent->addChild(mRefraction);
             }
 
-            mRipples = new Ripples(mResourceSystem);
-            mSimulation->setRipples(mRipples);
-            mParent->addChild(mRipples);
+            if(Settings::Manager::getBool("shader ripples", "Water")
+            {
+                mRipples = new Ripples(mResourceSystem);
+                mSimulation->setRipples(mRipples);
+                mParent->addChild(mRipples);
+            }
 
             showWorld(mShowWorld);
 
@@ -706,6 +709,7 @@ namespace MWRender
         defineMap["rain_ripple_detail"] = std::to_string(rippleDetail);
         defineMap["ripple_map_world_scale"] = std::to_string(RipplesSurface::mWorldScaleFactor);
         defineMap["ripple_map_size"] = std::to_string(RipplesSurface::mRTTSize) + ".0";
+        defineMap["shader_ripples"] = Settings::Manager::getBool("shader ripples", "Water") ? "1" : "0";
 
         Stereo::shaderStereoDefines(defineMap);
 
diff --git a/apps/openmw/mwrender/water.cpp.orig b/apps/openmw/mwrender/water.cpp.orig
new file mode 100644
index 00000000000..9fdb0583a21
--- /dev/null
+++ b/apps/openmw/mwrender/water.cpp.orig
@@ -0,0 +1,907 @@
+#include "water.hpp"
+
+#include <sstream>
+
+#include <osg/ClipNode>
+#include <osg/Depth>
+#include <osg/Fog>
+#include <osg/FrontFace>
+#include <osg/Geometry>
+#include <osg/Group>
+#include <osg/Material>
+#include <osg/PositionAttitudeTransform>
+#include <osg/ViewportIndexed>
+
+#include <osgUtil/CullVisitor>
+#include <osgUtil/IncrementalCompileOperation>
+
+#include <components/resource/imagemanager.hpp>
+#include <components/resource/resourcesystem.hpp>
+#include <components/resource/scenemanager.hpp>
+
+#include <components/sceneutil/depth.hpp>
+#include <components/sceneutil/rtt.hpp>
+#include <components/sceneutil/shadow.hpp>
+#include <components/sceneutil/waterutil.hpp>
+
+#include <components/misc/constants.hpp>
+#include <components/stereo/stereomanager.hpp>
+
+#include <components/nifosg/controller.hpp>
+
+#include <components/shader/shadermanager.hpp>
+
+#include <components/esm3/loadcell.hpp>
+
+#include <components/fallback/fallback.hpp>
+
+#include <components/settings/values.hpp>
+
+#include "../mwworld/cellstore.hpp"
+
+#include "renderbin.hpp"
+#include "ripples.hpp"
+#include "ripplesimulation.hpp"
+#include "util.hpp"
+#include "vismask.hpp"
+
+namespace MWRender
+{
+
+    // --------------------------------------------------------------------------------------------------------------------------------
+
+    /// @brief Allows to cull and clip meshes that are below a plane. Useful for reflection & refraction camera effects.
+    /// Also handles flipping of the plane when the eye point goes below it.
+    /// To use, simply create the scene as subgraph of this node, then do setPlane(const osg::Plane& plane);
+    class ClipCullNode : public osg::Group
+    {
+        class PlaneCullCallback : public SceneUtil::NodeCallback<PlaneCullCallback, osg::Node*, osgUtil::CullVisitor*>
+        {
+        public:
+            /// @param cullPlane The culling plane (in world space).
+            PlaneCullCallback(const osg::Plane* cullPlane)
+                : mCullPlane(cullPlane)
+            {
+            }
+
+            void operator()(osg::Node* node, osgUtil::CullVisitor* cv)
+            {
+                osg::Polytope::PlaneList origPlaneList
+                    = cv->getProjectionCullingStack().back().getFrustum().getPlaneList();
+
+                osg::Plane plane = *mCullPlane;
+                plane.transform(*cv->getCurrentRenderStage()->getInitialViewMatrix());
+
+                osg::Vec3d eyePoint = cv->getEyePoint();
+                if (mCullPlane->intersect(osg::BoundingSphere(osg::Vec3d(0, 0, eyePoint.z()), 0)) > 0)
+                    plane.flip();
+
+                cv->getProjectionCullingStack().back().getFrustum().add(plane);
+
+                traverse(node, cv);
+
+                // undo
+                cv->getProjectionCullingStack().back().getFrustum().set(origPlaneList);
+            }
+
+        private:
+            const osg::Plane* mCullPlane;
+        };
+
+        class FlipCallback : public SceneUtil::NodeCallback<FlipCallback, osg::Node*, osgUtil::CullVisitor*>
+        {
+        public:
+            FlipCallback(const osg::Plane* cullPlane)
+                : mCullPlane(cullPlane)
+            {
+            }
+
+            void operator()(osg::Node* node, osgUtil::CullVisitor* cv)
+            {
+                osg::Vec3d eyePoint = cv->getEyePoint();
+
+                osg::RefMatrix* modelViewMatrix = new osg::RefMatrix(*cv->getModelViewMatrix());
+
+                // apply the height of the plane
+                // we can't apply this height in the addClipPlane() since the "flip the below graph" function would
+                // otherwise flip the height as well
+                modelViewMatrix->preMultTranslate(mCullPlane->getNormal() * ((*mCullPlane)[3] * -1));
+
+                // flip the below graph if the eye point is above the plane
+                if (mCullPlane->intersect(osg::BoundingSphere(osg::Vec3d(0, 0, eyePoint.z()), 0)) > 0)
+                {
+                    modelViewMatrix->preMultScale(osg::Vec3(1, 1, -1));
+                }
+
+                // move the plane back along its normal a little bit to prevent bleeding at the water shore
+                float fov = Settings::camera().mFieldOfView;
+                const float clipFudgeMin = 2.5; // minimum offset of clip plane
+                const float clipFudgeScale = -15000.0;
+                float clipFudge = abs(abs((*mCullPlane)[3]) - eyePoint.z()) * fov / clipFudgeScale - clipFudgeMin;
+                modelViewMatrix->preMultTranslate(mCullPlane->getNormal() * clipFudge);
+
+                cv->pushModelViewMatrix(modelViewMatrix, osg::Transform::RELATIVE_RF);
+                traverse(node, cv);
+                cv->popModelViewMatrix();
+            }
+
+        private:
+            const osg::Plane* mCullPlane;
+        };
+
+    public:
+        ClipCullNode()
+        {
+            addCullCallback(new PlaneCullCallback(&mPlane));
+
+            mClipNodeTransform = new osg::Group;
+            mClipNodeTransform->addCullCallback(new FlipCallback(&mPlane));
+            osg::Group::addChild(mClipNodeTransform);
+
+            mClipNode = new osg::ClipNode;
+
+            mClipNodeTransform->addChild(mClipNode);
+        }
+
+        void setPlane(const osg::Plane& plane)
+        {
+            if (plane == mPlane)
+                return;
+            mPlane = plane;
+
+            mClipNode->getClipPlaneList().clear();
+            mClipNode->addClipPlane(
+                new osg::ClipPlane(0, osg::Plane(mPlane.getNormal(), 0))); // mPlane.d() applied in FlipCallback
+            mClipNode->setStateSetModes(*getOrCreateStateSet(), osg::StateAttribute::ON);
+            mClipNode->setCullingActive(false);
+        }
+
+    private:
+        osg::ref_ptr<osg::Group> mClipNodeTransform;
+        osg::ref_ptr<osg::ClipNode> mClipNode;
+
+        osg::Plane mPlane;
+    };
+
+    /// This callback on the Camera has the effect of a RELATIVE_RF_INHERIT_VIEWPOINT transform mode (which does not
+    /// exist in OSG). We want to keep the View Point of the parent camera so we will not have to recreate LODs.
+    class InheritViewPointCallback
+        : public SceneUtil::NodeCallback<InheritViewPointCallback, osg::Node*, osgUtil::CullVisitor*>
+    {
+    public:
+        InheritViewPointCallback() {}
+
+        void operator()(osg::Node* node, osgUtil::CullVisitor* cv)
+        {
+            osg::ref_ptr<osg::RefMatrix> modelViewMatrix = new osg::RefMatrix(*cv->getModelViewMatrix());
+            cv->popModelViewMatrix();
+            cv->pushModelViewMatrix(modelViewMatrix, osg::Transform::ABSOLUTE_RF_INHERIT_VIEWPOINT);
+            traverse(node, cv);
+        }
+    };
+
+    /// Moves water mesh away from the camera slightly if the camera gets too close on the Z axis.
+    /// The offset works around graphics artifacts that occurred with the GL_DEPTH_CLAMP when the camera gets extremely
+    /// close to the mesh (seen on NVIDIA at least). Must be added as a Cull callback.
+    class FudgeCallback : public SceneUtil::NodeCallback<FudgeCallback, osg::Node*, osgUtil::CullVisitor*>
+    {
+    public:
+        void operator()(osg::Node* node, osgUtil::CullVisitor* cv)
+        {
+            const float fudge = 0.2;
+            if (std::abs(cv->getEyeLocal().z()) < fudge)
+            {
+                float diff = fudge - cv->getEyeLocal().z();
+                osg::RefMatrix* modelViewMatrix = new osg::RefMatrix(*cv->getModelViewMatrix());
+
+                if (cv->getEyeLocal().z() > 0)
+                    modelViewMatrix->preMultTranslate(osg::Vec3f(0, 0, -diff));
+                else
+                    modelViewMatrix->preMultTranslate(osg::Vec3f(0, 0, diff));
+
+                cv->pushModelViewMatrix(modelViewMatrix, osg::Transform::RELATIVE_RF);
+                traverse(node, cv);
+                cv->popModelViewMatrix();
+            }
+            else
+                traverse(node, cv);
+        }
+    };
+
+    class RainSettingsUpdater : public SceneUtil::StateSetUpdater
+    {
+    public:
+        RainSettingsUpdater()
+            : mRainIntensity(0.f)
+            , mEnableRipples(false)
+        {
+        }
+
+        void setRainIntensity(float rainIntensity) { mRainIntensity = rainIntensity; }
+        void setRipplesEnabled(bool enableRipples) { mEnableRipples = enableRipples; }
+
+    protected:
+        void setDefaults(osg::StateSet* stateset) override
+        {
+            osg::ref_ptr<osg::Uniform> rainIntensityUniform = new osg::Uniform("rainIntensity", 0.0f);
+            stateset->addUniform(rainIntensityUniform.get());
+            osg::ref_ptr<osg::Uniform> enableRainRipplesUniform = new osg::Uniform("enableRainRipples", false);
+            stateset->addUniform(enableRainRipplesUniform.get());
+        }
+
+        void apply(osg::StateSet* stateset, osg::NodeVisitor* /*nv*/) override
+        {
+            osg::ref_ptr<osg::Uniform> rainIntensityUniform = stateset->getUniform("rainIntensity");
+            if (rainIntensityUniform != nullptr)
+                rainIntensityUniform->set(mRainIntensity);
+            osg::ref_ptr<osg::Uniform> enableRainRipplesUniform = stateset->getUniform("enableRainRipples");
+            if (enableRainRipplesUniform != nullptr)
+                enableRainRipplesUniform->set(mEnableRipples);
+        }
+
+    private:
+        float mRainIntensity;
+        bool mEnableRipples;
+    };
+
+    class Refraction : public SceneUtil::RTTNode
+    {
+    public:
+        Refraction(uint32_t rttSize)
+            : RTTNode(rttSize, rttSize, 0, false, 1, StereoAwareness::Aware, shouldAddMSAAIntermediateTarget())
+            , mNodeMask(Refraction::sDefaultCullMask)
+        {
+            setDepthBufferInternalFormat(GL_DEPTH24_STENCIL8);
+            mClipCullNode = new ClipCullNode;
+        }
+
+        void setDefaults(osg::Camera* camera) override
+        {
+            camera->setReferenceFrame(osg::Camera::RELATIVE_RF);
+            camera->setSmallFeatureCullingPixelSize(Settings::water().mSmallFeatureCullingPixelSize);
+            camera->setName("RefractionCamera");
+            camera->addCullCallback(new InheritViewPointCallback);
+            camera->setComputeNearFarMode(osg::CullSettings::DO_NOT_COMPUTE_NEAR_FAR);
+
+            // No need for fog here, we are already applying fog on the water surface itself as well as underwater fog
+            // assign large value to effectively turn off fog
+            // shaders don't respect glDisable(GL_FOG)
+            osg::ref_ptr<osg::Fog> fog(new osg::Fog);
+            fog->setStart(10000000);
+            fog->setEnd(10000000);
+            camera->getOrCreateStateSet()->setAttributeAndModes(
+                fog, osg::StateAttribute::OFF | osg::StateAttribute::OVERRIDE);
+
+            camera->addChild(mClipCullNode);
+            camera->setNodeMask(Mask_RenderToTexture);
+
+            if (Settings::water().mRefractionScale != 1) // TODO: to be removed with issue #5709
+                SceneUtil::ShadowManager::disableShadowsForStateSet(
+                    Settings::shadows(), *camera->getOrCreateStateSet());
+        }
+
+        void apply(osg::Camera* camera) override
+        {
+            camera->setViewMatrix(mViewMatrix);
+            camera->setCullMask(mNodeMask);
+        }
+
+        void setScene(osg::Node* scene)
+        {
+            if (mScene)
+                mClipCullNode->removeChild(mScene);
+            mScene = scene;
+            mClipCullNode->addChild(scene);
+        }
+
+        void setWaterLevel(float waterLevel)
+        {
+            const float refractionScale = Settings::water().mRefractionScale;
+
+            mViewMatrix = osg::Matrix::scale(1, 1, refractionScale)
+                * osg::Matrix::translate(0, 0, (1.0 - refractionScale) * waterLevel);
+
+            mClipCullNode->setPlane(osg::Plane(osg::Vec3d(0, 0, -1), osg::Vec3d(0, 0, waterLevel)));
+        }
+
+        void showWorld(bool show)
+        {
+            if (show)
+                mNodeMask = Refraction::sDefaultCullMask;
+            else
+                mNodeMask = Refraction::sDefaultCullMask & ~sToggleWorldMask;
+        }
+
+    private:
+        osg::ref_ptr<ClipCullNode> mClipCullNode;
+        osg::ref_ptr<osg::Node> mScene;
+        osg::Matrix mViewMatrix{ osg::Matrix::identity() };
+
+        unsigned int mNodeMask;
+
+        static constexpr unsigned int sDefaultCullMask = Mask_Effect | Mask_Scene | Mask_Object | Mask_Static
+            | Mask_Terrain | Mask_Actor | Mask_ParticleSystem | Mask_Sky | Mask_Sun | Mask_Player | Mask_Lighting
+            | Mask_Groundcover;
+    };
+
+    class Reflection : public SceneUtil::RTTNode
+    {
+    public:
+        Reflection(uint32_t rttSize, bool isInterior)
+            : RTTNode(rttSize, rttSize, 0, false, 0, StereoAwareness::Aware, shouldAddMSAAIntermediateTarget())
+        {
+            setInterior(isInterior);
+            setDepthBufferInternalFormat(GL_DEPTH24_STENCIL8);
+            mClipCullNode = new ClipCullNode;
+        }
+
+        void setDefaults(osg::Camera* camera) override
+        {
+            camera->setReferenceFrame(osg::Camera::RELATIVE_RF);
+            camera->setSmallFeatureCullingPixelSize(Settings::water().mSmallFeatureCullingPixelSize);
+            camera->setName("ReflectionCamera");
+            camera->addCullCallback(new InheritViewPointCallback);
+
+            // Inform the shader that we're in a reflection
+            camera->getOrCreateStateSet()->addUniform(new osg::Uniform("isReflection", true));
+
+            // XXX: should really flip the FrontFace on each renderable instead of forcing clockwise.
+            osg::ref_ptr<osg::FrontFace> frontFace(new osg::FrontFace);
+            frontFace->setMode(osg::FrontFace::CLOCKWISE);
+            camera->getOrCreateStateSet()->setAttributeAndModes(frontFace, osg::StateAttribute::ON);
+
+            camera->addChild(mClipCullNode);
+            camera->setNodeMask(Mask_RenderToTexture);
+
+            SceneUtil::ShadowManager::disableShadowsForStateSet(Settings::shadows(), *camera->getOrCreateStateSet());
+        }
+
+        void apply(osg::Camera* camera) override
+        {
+            camera->setViewMatrix(mViewMatrix);
+            camera->setCullMask(mNodeMask);
+        }
+
+        void setInterior(bool isInterior)
+        {
+            mInterior = isInterior;
+            mNodeMask = calcNodeMask();
+        }
+
+        void setWaterLevel(float waterLevel)
+        {
+            mViewMatrix = osg::Matrix::scale(1, 1, -1) * osg::Matrix::translate(0, 0, 2 * waterLevel);
+            mClipCullNode->setPlane(osg::Plane(osg::Vec3d(0, 0, 1), osg::Vec3d(0, 0, waterLevel)));
+        }
+
+        void setScene(osg::Node* scene)
+        {
+            if (mScene)
+                mClipCullNode->removeChild(mScene);
+            mScene = scene;
+            mClipCullNode->addChild(scene);
+        }
+
+        void showWorld(bool show)
+        {
+            if (show)
+                mNodeMask = calcNodeMask();
+            else
+                mNodeMask = calcNodeMask() & ~sToggleWorldMask;
+        }
+
+    private:
+        unsigned int calcNodeMask()
+        {
+            int reflectionDetail = Settings::water().mReflectionDetail;
+            reflectionDetail = std::clamp(reflectionDetail, mInterior ? 2 : 0, 5);
+            unsigned int extraMask = 0;
+            if (reflectionDetail >= 1)
+                extraMask |= Mask_Terrain;
+            if (reflectionDetail >= 2)
+                extraMask |= Mask_Static;
+            if (reflectionDetail >= 3)
+                extraMask |= Mask_Effect | Mask_ParticleSystem | Mask_Object;
+            if (reflectionDetail >= 4)
+                extraMask |= Mask_Player | Mask_Actor;
+            if (reflectionDetail >= 5)
+                extraMask |= Mask_Groundcover;
+            return Mask_Scene | Mask_Sky | Mask_Lighting | extraMask;
+        }
+
+        osg::ref_ptr<ClipCullNode> mClipCullNode;
+        osg::ref_ptr<osg::Node> mScene;
+        osg::Node::NodeMask mNodeMask;
+        osg::Matrix mViewMatrix{ osg::Matrix::identity() };
+        bool mInterior;
+    };
+
+    /// DepthClampCallback enables GL_DEPTH_CLAMP for the current draw, if supported.
+    class DepthClampCallback : public osg::Drawable::DrawCallback
+    {
+    public:
+        void drawImplementation(osg::RenderInfo& renderInfo, const osg::Drawable* drawable) const override
+        {
+            static bool supported = osg::isGLExtensionOrVersionSupported(
+                renderInfo.getState()->getContextID(), "GL_ARB_depth_clamp", 3.3);
+            if (!supported)
+            {
+                drawable->drawImplementation(renderInfo);
+                return;
+            }
+
+            glEnable(GL_DEPTH_CLAMP);
+
+            drawable->drawImplementation(renderInfo);
+
+            // restore default
+            glDisable(GL_DEPTH_CLAMP);
+        }
+    };
+
+    Water::Water(osg::Group* parent, osg::Group* sceneRoot, Resource::ResourceSystem* resourceSystem,
+        osgUtil::IncrementalCompileOperation* ico)
+        : mRainSettingsUpdater(nullptr)
+        , mParent(parent)
+        , mSceneRoot(sceneRoot)
+        , mResourceSystem(resourceSystem)
+        , mEnabled(true)
+        , mToggled(true)
+        , mTop(0)
+        , mInterior(false)
+        , mShowWorld(true)
+        , mCullCallback(nullptr)
+        , mShaderWaterStateSetUpdater(nullptr)
+    {
+        mSimulation = std::make_unique<RippleSimulation>(mSceneRoot, resourceSystem);
+
+        mWaterGeom = SceneUtil::createWaterGeometry(Constants::CellSizeInUnits * 150, 40, 900);
+        mWaterGeom->setDrawCallback(new DepthClampCallback);
+        mWaterGeom->setNodeMask(Mask_Water);
+        mWaterGeom->setDataVariance(osg::Object::STATIC);
+        mWaterGeom->setName("Water Geometry");
+
+        mWaterNode = new osg::PositionAttitudeTransform;
+        mWaterNode->setName("Water Root");
+        mWaterNode->addChild(mWaterGeom);
+        mWaterNode->addCullCallback(new FudgeCallback);
+
+        // simple water fallback for the local map
+        osg::ref_ptr<osg::Geometry> geom2(osg::clone(mWaterGeom.get(), osg::CopyOp::DEEP_COPY_NODES));
+        createSimpleWaterStateSet(geom2, Fallback::Map::getFloat("Water_Map_Alpha"));
+        geom2->setNodeMask(Mask_SimpleWater);
+        geom2->setName("Simple Water Geometry");
+        mWaterNode->addChild(geom2);
+
+        mSceneRoot->addChild(mWaterNode);
+
+        setHeight(mTop);
+
+        updateWaterMaterial();
+
+        if (ico)
+            ico->add(mWaterNode);
+    }
+
+    void Water::setCullCallback(osg::Callback* callback)
+    {
+        if (mCullCallback)
+        {
+            mWaterNode->removeCullCallback(mCullCallback);
+            if (mReflection)
+                mReflection->removeCullCallback(mCullCallback);
+            if (mRefraction)
+                mRefraction->removeCullCallback(mCullCallback);
+        }
+
+        mCullCallback = callback;
+
+        if (callback)
+        {
+            mWaterNode->addCullCallback(callback);
+            if (mReflection)
+                mReflection->addCullCallback(callback);
+            if (mRefraction)
+                mRefraction->addCullCallback(callback);
+        }
+    }
+
+    void Water::updateWaterMaterial()
+    {
+        if (mShaderWaterStateSetUpdater)
+        {
+            mWaterNode->removeCullCallback(mShaderWaterStateSetUpdater);
+            mShaderWaterStateSetUpdater = nullptr;
+        }
+        if (mReflection)
+        {
+            mParent->removeChild(mReflection);
+            mReflection = nullptr;
+        }
+        if (mRefraction)
+        {
+            mParent->removeChild(mRefraction);
+            mRefraction = nullptr;
+        }
+        if (mRipples)
+        {
+            mParent->removeChild(mRipples);
+            mRipples = nullptr;
+            mSimulation->setRipples(nullptr);
+        }
+
+        mWaterNode->setStateSet(nullptr);
+        mWaterGeom->setStateSet(nullptr);
+        mWaterGeom->setUpdateCallback(nullptr);
+
+        if (Settings::water().mShader)
+        {
+            const unsigned int rttSize = Settings::water().mRttSize;
+
+            mReflection = new Reflection(rttSize, mInterior);
+            mReflection->setWaterLevel(mTop);
+            mReflection->setScene(mSceneRoot);
+            if (mCullCallback)
+                mReflection->addCullCallback(mCullCallback);
+            mParent->addChild(mReflection);
+
+            if (Settings::water().mRefraction)
+            {
+                mRefraction = new Refraction(rttSize);
+                mRefraction->setWaterLevel(mTop);
+                mRefraction->setScene(mSceneRoot);
+                if (mCullCallback)
+                    mRefraction->addCullCallback(mCullCallback);
+                mParent->addChild(mRefraction);
+            }
+
+            mRipples = new Ripples(mResourceSystem);
+            mSimulation->setRipples(mRipples);
+            mParent->addChild(mRipples);
+
+            showWorld(mShowWorld);
+
+            createShaderWaterStateSet(mWaterNode);
+        }
+        else
+            createSimpleWaterStateSet(mWaterGeom, Fallback::Map::getFloat("Water_World_Alpha"));
+
+        updateVisible();
+    }
+
+    osg::Node* Water::getReflectionNode()
+    {
+        return mReflection;
+    }
+
+    osg::Node* Water::getRefractionNode()
+    {
+        return mRefraction;
+    }
+
+    osg::Vec3d Water::getPosition() const
+    {
+        return mWaterNode->getPosition();
+    }
+
+    void Water::createSimpleWaterStateSet(osg::Node* node, float alpha)
+    {
+        osg::ref_ptr<osg::StateSet> stateset = SceneUtil::createSimpleWaterStateSet(alpha, MWRender::RenderBin_Water);
+
+        node->setStateSet(stateset);
+        node->setUpdateCallback(nullptr);
+        mRainSettingsUpdater = nullptr;
+
+        // Add animated textures
+        std::vector<osg::ref_ptr<osg::Texture2D>> textures;
+        const int frameCount = std::clamp(Fallback::Map::getInt("Water_SurfaceFrameCount"), 0, 320);
+        std::string_view texture = Fallback::Map::getString("Water_SurfaceTexture");
+        for (int i = 0; i < frameCount; ++i)
+        {
+            std::ostringstream texname;
+            texname << "textures/water/" << texture << std::setw(2) << std::setfill('0') << i << ".dds";
+            osg::ref_ptr<osg::Texture2D> tex(
+                new osg::Texture2D(mResourceSystem->getImageManager()->getImage(texname.str())));
+            tex->setWrap(osg::Texture::WRAP_S, osg::Texture::REPEAT);
+            tex->setWrap(osg::Texture::WRAP_T, osg::Texture::REPEAT);
+            mResourceSystem->getSceneManager()->applyFilterSettings(tex);
+            textures.push_back(tex);
+        }
+
+        if (textures.empty())
+            return;
+
+        float fps = Fallback::Map::getFloat("Water_SurfaceFPS");
+
+        osg::ref_ptr<NifOsg::FlipController> controller(new NifOsg::FlipController(0, 1.f / fps, textures));
+        controller->setSource(std::make_shared<SceneUtil::FrameTimeSource>());
+        node->setUpdateCallback(controller);
+
+        stateset->setTextureAttributeAndModes(0, textures[0], osg::StateAttribute::ON);
+
+        // use a shader to render the simple water, ensuring that fog is applied per pixel as required.
+        // this could be removed if a more detailed water mesh, using some sort of paging solution, is implemented.
+        Resource::SceneManager* sceneManager = mResourceSystem->getSceneManager();
+        bool oldValue = sceneManager->getForceShaders();
+        sceneManager->setForceShaders(true);
+        sceneManager->recreateShaders(node);
+        sceneManager->setForceShaders(oldValue);
+    }
+
+    class ShaderWaterStateSetUpdater : public SceneUtil::StateSetUpdater
+    {
+    public:
+        ShaderWaterStateSetUpdater(Water* water, Reflection* reflection, Refraction* refraction, Ripples* ripples,
+            osg::ref_ptr<osg::Program> program, osg::ref_ptr<osg::Texture2D> normalMap)
+            : mWater(water)
+            , mReflection(reflection)
+            , mRefraction(refraction)
+            , mRipples(ripples)
+            , mProgram(std::move(program))
+            , mNormalMap(std::move(normalMap))
+        {
+        }
+
+        void setDefaults(osg::StateSet* stateset) override
+        {
+            stateset->addUniform(new osg::Uniform("normalMap", 0));
+            stateset->setTextureAttributeAndModes(0, mNormalMap, osg::StateAttribute::ON);
+            stateset->setMode(GL_CULL_FACE, osg::StateAttribute::OFF);
+            stateset->setAttributeAndModes(mProgram, osg::StateAttribute::ON);
+
+            stateset->addUniform(new osg::Uniform("reflectionMap", 1));
+            if (mRefraction)
+            {
+                stateset->addUniform(new osg::Uniform("refractionMap", 2));
+                stateset->addUniform(new osg::Uniform("refractionDepthMap", 3));
+                stateset->setRenderBinDetails(MWRender::RenderBin_Default, "RenderBin");
+            }
+            else
+            {
+                stateset->setMode(GL_BLEND, osg::StateAttribute::ON);
+                stateset->setRenderBinDetails(MWRender::RenderBin_Water, "RenderBin");
+                osg::ref_ptr<osg::Depth> depth = new SceneUtil::AutoDepth;
+                depth->setWriteMask(false);
+                stateset->setAttributeAndModes(depth, osg::StateAttribute::ON);
+            }
+            if (mRipples)
+            {
+                stateset->addUniform(new osg::Uniform("rippleMap", 4));
+            }
+            stateset->addUniform(new osg::Uniform("nodePosition", osg::Vec3f(mWater->getPosition())));
+        }
+
+        void apply(osg::StateSet* stateset, osg::NodeVisitor* nv) override
+        {
+            osgUtil::CullVisitor* cv = static_cast<osgUtil::CullVisitor*>(nv);
+            stateset->setTextureAttributeAndModes(1, mReflection->getColorTexture(cv), osg::StateAttribute::ON);
+
+            if (mRefraction)
+            {
+                stateset->setTextureAttributeAndModes(2, mRefraction->getColorTexture(cv), osg::StateAttribute::ON);
+                stateset->setTextureAttributeAndModes(3, mRefraction->getDepthTexture(cv), osg::StateAttribute::ON);
+            }
+            if (mRipples)
+            {
+                stateset->setTextureAttributeAndModes(4, mRipples->getColorTexture(), osg::StateAttribute::ON);
+            }
+            stateset->getUniform("nodePosition")->set(osg::Vec3f(mWater->getPosition()));
+        }
+
+    private:
+        Water* mWater;
+        Reflection* mReflection;
+        Refraction* mRefraction;
+        Ripples* mRipples;
+        osg::ref_ptr<osg::Program> mProgram;
+        osg::ref_ptr<osg::Texture2D> mNormalMap;
+    };
+
+    void Water::createShaderWaterStateSet(osg::Node* node)
+    {
+        // use a define map to conditionally compile the shader
+        std::map<std::string, std::string> defineMap;
+        defineMap["refraction_enabled"] = std::string(mRefraction ? "1" : "0");
+        const int rippleDetail = Settings::water().mRainRippleDetail;
+        defineMap["rain_ripple_detail"] = std::to_string(rippleDetail);
+        defineMap["ripple_map_world_scale"] = std::to_string(RipplesSurface::mWorldScaleFactor);
+        defineMap["ripple_map_size"] = std::to_string(RipplesSurface::mRTTSize) + ".0";
+
+        Stereo::shaderStereoDefines(defineMap);
+
+        Shader::ShaderManager& shaderMgr = mResourceSystem->getSceneManager()->getShaderManager();
+        osg::ref_ptr<osg::Program> program = shaderMgr.getProgram("water", defineMap);
+
+        osg::ref_ptr<osg::Texture2D> normalMap(
+            new osg::Texture2D(mResourceSystem->getImageManager()->getImage("textures/omw/water_nm.png")));
+        if (normalMap->getImage())
+            normalMap->getImage()->flipVertical();
+        normalMap->setWrap(osg::Texture::WRAP_S, osg::Texture::REPEAT);
+        normalMap->setWrap(osg::Texture::WRAP_T, osg::Texture::REPEAT);
+        normalMap->setMaxAnisotropy(16);
+        normalMap->setFilter(osg::Texture::MIN_FILTER, osg::Texture::LINEAR_MIPMAP_LINEAR);
+        normalMap->setFilter(osg::Texture::MAG_FILTER, osg::Texture::LINEAR);
+
+        mRainSettingsUpdater = new RainSettingsUpdater();
+        node->setUpdateCallback(mRainSettingsUpdater);
+
+        mShaderWaterStateSetUpdater = new ShaderWaterStateSetUpdater(
+            this, mReflection, mRefraction, mRipples, std::move(program), std::move(normalMap));
+        node->addCullCallback(mShaderWaterStateSetUpdater);
+    }
+
+    void Water::processChangedSettings(const Settings::CategorySettingVector& settings)
+    {
+        updateWaterMaterial();
+    }
+
+    Water::~Water()
+    {
+        mParent->removeChild(mWaterNode);
+
+        if (mReflection)
+        {
+            mParent->removeChild(mReflection);
+            mReflection = nullptr;
+        }
+        if (mRefraction)
+        {
+            mParent->removeChild(mRefraction);
+            mRefraction = nullptr;
+        }
+        if (mRipples)
+        {
+            mParent->removeChild(mRipples);
+            mRipples = nullptr;
+            mSimulation->setRipples(nullptr);
+        }
+    }
+
+    void Water::listAssetsToPreload(std::vector<std::string>& textures)
+    {
+        const int frameCount = std::clamp(Fallback::Map::getInt("Water_SurfaceFrameCount"), 0, 320);
+        std::string_view texture = Fallback::Map::getString("Water_SurfaceTexture");
+        for (int i = 0; i < frameCount; ++i)
+        {
+            std::ostringstream texname;
+            texname << "textures/water/" << texture << std::setw(2) << std::setfill('0') << i << ".dds";
+            textures.push_back(texname.str());
+        }
+    }
+
+    void Water::setEnabled(bool enabled)
+    {
+        mEnabled = enabled;
+        updateVisible();
+    }
+
+    void Water::changeCell(const MWWorld::CellStore* store)
+    {
+        bool isInterior = !store->getCell()->isExterior();
+        bool wasInterior = mInterior;
+        if (!isInterior)
+        {
+            mWaterNode->setPosition(
+                getSceneNodeCoordinates(store->getCell()->getGridX(), store->getCell()->getGridY()));
+            mInterior = false;
+        }
+        else
+        {
+            mWaterNode->setPosition(osg::Vec3f(0, 0, mTop));
+            mInterior = true;
+        }
+        if (mInterior != wasInterior && mReflection)
+            mReflection->setInterior(mInterior);
+    }
+
+    void Water::setHeight(const float height)
+    {
+        mTop = height;
+
+        mSimulation->setWaterHeight(height);
+
+        osg::Vec3f pos = mWaterNode->getPosition();
+        pos.z() = height;
+        mWaterNode->setPosition(pos);
+
+        if (mReflection)
+            mReflection->setWaterLevel(mTop);
+        if (mRefraction)
+            mRefraction->setWaterLevel(mTop);
+    }
+
+    void Water::setRainIntensity(float rainIntensity)
+    {
+        if (mRainSettingsUpdater)
+            mRainSettingsUpdater->setRainIntensity(rainIntensity);
+    }
+
+    void Water::setRainRipplesEnabled(bool enableRipples)
+    {
+        if (mRainSettingsUpdater)
+            mRainSettingsUpdater->setRipplesEnabled(enableRipples);
+    }
+
+    void Water::update(float dt, bool paused)
+    {
+        if (!paused)
+        {
+            mSimulation->update(dt);
+        }
+
+        if (mRipples)
+        {
+            mRipples->setPaused(paused);
+        }
+    }
+
+    void Water::updateVisible()
+    {
+        bool visible = mEnabled && mToggled;
+        mWaterNode->setNodeMask(visible ? ~0u : 0u);
+        if (mRefraction)
+            mRefraction->setNodeMask(visible ? Mask_RenderToTexture : 0u);
+        if (mReflection)
+            mReflection->setNodeMask(visible ? Mask_RenderToTexture : 0u);
+        if (mRipples)
+            mRipples->setNodeMask(visible ? Mask_RenderToTexture : 0u);
+    }
+
+    bool Water::toggle()
+    {
+        mToggled = !mToggled;
+        updateVisible();
+        return mToggled;
+    }
+
+    bool Water::isUnderwater(const osg::Vec3f& pos) const
+    {
+        return pos.z() < mTop && mToggled && mEnabled;
+    }
+
+    osg::Vec3f Water::getSceneNodeCoordinates(int gridX, int gridY)
+    {
+        return osg::Vec3f(static_cast<float>(gridX * Constants::CellSizeInUnits + (Constants::CellSizeInUnits / 2)),
+            static_cast<float>(gridY * Constants::CellSizeInUnits + (Constants::CellSizeInUnits / 2)), mTop);
+    }
+
+    void Water::addEmitter(const MWWorld::Ptr& ptr, float scale, float force)
+    {
+        mSimulation->addEmitter(ptr, scale, force);
+    }
+
+    void Water::removeEmitter(const MWWorld::Ptr& ptr)
+    {
+        mSimulation->removeEmitter(ptr);
+    }
+
+    void Water::updateEmitterPtr(const MWWorld::Ptr& old, const MWWorld::Ptr& ptr)
+    {
+        mSimulation->updateEmitterPtr(old, ptr);
+    }
+
+    void Water::emitRipple(const osg::Vec3f& pos)
+    {
+        mSimulation->emitRipple(pos);
+    }
+
+    void Water::removeCell(const MWWorld::CellStore* store)
+    {
+        mSimulation->removeCell(store);
+    }
+
+    void Water::clearRipples()
+    {
+        mSimulation->clear();
+    }
+
+    void Water::showWorld(bool show)
+    {
+        if (mReflection)
+            mReflection->showWorld(show);
+        if (mRefraction)
+            mRefraction->showWorld(show);
+        mShowWorld = show;
+    }
+
+}
diff --git a/components/debug/debugging.cpp b/components/debug/debugging.cpp
index d170cf1929b..e94b8d3f943 100644
--- a/components/debug/debugging.cpp
+++ b/components/debug/debugging.cpp
@@ -323,6 +323,8 @@ void setupLogging(const std::filesystem::path& logDir, std::string_view appName,
 #endif
 }
 
+osg::ref_ptr<osgViewer::Viewer> g_viewer;
+
 int wrapApplication(int (*innerApplication)(int argc, char* argv[]), int argc, char* argv[], std::string_view appName)
 {
 #if defined _WIN32
diff --git a/components/fx/parse_constants.hpp b/components/fx/parse_constants.hpp
index 9be54ed3a76..55585f8106d 100644
--- a/components/fx/parse_constants.hpp
+++ b/components/fx/parse_constants.hpp
@@ -35,7 +35,7 @@ namespace fx
             { "bgra", GL_BGRA },
         } };
 
-        constexpr std::array<std::pair<std::string_view, int>, 9> SourceType = { {
+        constexpr std::array<std::pair<std::string_view, int>, 10> SourceType = { {
             { "byte", GL_BYTE },
             { "unsigned_byte", GL_UNSIGNED_BYTE },
             { "short", GL_SHORT },
@@ -44,6 +44,7 @@ namespace fx
             { "unsigned_int", GL_UNSIGNED_INT },
             { "unsigned_int_24_8", GL_UNSIGNED_INT_24_8 },
             { "float", GL_FLOAT },
+            { "half_float", GL_HALF_FLOAT },
             { "double", GL_DOUBLE },
         } };
 
@@ -129,4 +130,4 @@ namespace fx
     }
 }
 
-#endif
\ No newline at end of file
+#endif
diff --git a/components/fx/pass.cpp b/components/fx/pass.cpp
index cf50d20fe22..20d090ef6cf 100644
--- a/components/fx/pass.cpp
+++ b/components/fx/pass.cpp
@@ -89,7 +89,7 @@ namespace fx
 
 uniform @builtinSampler omw_SamplerLastShader;
 uniform @builtinSampler omw_SamplerLastPass;
-uniform @builtinSampler omw_SamplerDepth;
+uniform highp @builtinSampler omw_SamplerDepth;
 uniform @builtinSampler omw_SamplerNormals;
 uniform @builtinSampler omw_SamplerDistortion;
 
diff --git a/components/settings/categories/water.hpp b/components/settings/categories/water.hpp
index 2e041142449..29ecb2f4700 100644
--- a/components/settings/categories/water.hpp
+++ b/components/settings/categories/water.hpp
@@ -19,6 +19,7 @@ namespace Settings
         using WithIndex::WithIndex;
 
         SettingValue<bool> mShader{ mIndex, "Water", "shader" };
+        SettingValue<bool> mShaderRipples{ "Water", "shader ripples" };
         SettingValue<int> mRttSize{ mIndex, "Water", "rtt size", makeMaxSanitizerInt(1) };
         SettingValue<bool> mRefraction{ mIndex, "Water", "refraction" };
         SettingValue<int> mReflectionDetail{ mIndex, "Water", "reflection detail", makeClampSanitizerInt(0, 5) };
diff --git a/components/shader/shadervisitor.cpp b/components/shader/shadervisitor.cpp
index e281f644480..3f09e833d1e 100644
--- a/components/shader/shadervisitor.cpp
+++ b/components/shader/shadervisitor.cpp
@@ -32,6 +32,9 @@
 #include "removedalphafunc.hpp"
 #include "shadermanager.hpp"
 
+#include <components/settings/values.hpp>
+#include <components/sceneutil/depth.hpp>
+
 namespace Shader
 {
     /**
@@ -730,6 +733,13 @@ namespace Shader
             updateRemovedState(*writableUserData, removedState);
         }
 
+        if (reqs.mAlphaBlend && Settings::postProcessing().mTransparentPostpass && Settings::postProcessing().mEnabled)
+        {
+            osg::ref_ptr<osg::Depth> depth = new SceneUtil::AutoDepth;
+            depth->setWriteMask(false);
+            writableStateSet->setAttributeAndModes(depth, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);
+        }
+
         defineMap["softParticles"] = reqs.mSoftParticles ? "1" : "0";
 
         Stereo::shaderStereoDefines(defineMap);
diff --git a/files/data/l10n/OMWEngine/en.yaml b/files/data/l10n/OMWEngine/en.yaml
index f6ad2373942..c23937d6ac4 100644
--- a/files/data/l10n/OMWEngine/en.yaml
+++ b/files/data/l10n/OMWEngine/en.yaml
@@ -171,6 +171,7 @@ VSync: "VSync"
 VSyncAdaptive: "Adaptive"
 Water: "Water"
 WaterShader: "Water shader"
+WaterShaderRipples: "Water shader ripples"
 WaterShaderTextureQuality: "Texture quality"
 WindowBorder: "Window Border"
 WindowMode: "Window Mode"
diff --git a/files/data/l10n/OMWEngine/en.yaml.orig b/files/data/l10n/OMWEngine/en.yaml.orig
new file mode 100644
index 00000000000..f6ad2373942
--- /dev/null
+++ b/files/data/l10n/OMWEngine/en.yaml.orig
@@ -0,0 +1,180 @@
+# Console
+
+ConsoleWindow: "Console"
+
+# Debug window
+
+DebugWindow: "Debug"
+LogViewer: "Log Viewer"
+LuaProfiler: "Lua Profiler"
+PhysicsProfiler: "Physics Profiler"
+
+
+# Messages
+
+AskLoadLastSave: "The most recent save is '%s'. Do you want to load it?"
+BuildingNavigationMesh: "Building navigation mesh"
+InitializingData: "Initializing Data..."
+LoadingExterior: "Loading Area"
+LoadingFailed: "Failed to load saved game"
+LoadingInterior: "Loading Area"
+LoadingInProgress: "Loading Save Game"
+LoadingRequiresNewVersionError: |-
+    This save file was created using a newer version of OpenMW and is thus not supported.
+    Please upgrade to the newest OpenMW version to load this file.
+LoadingRequiresOldVersionError: |-
+    This save file was created using an older version of OpenMW in a format that is no longer supported.
+    Load and save this file using {version} to upgrade it.
+NewGameConfirmation: "Do you want to start a new game and lose the current one?"
+QuitGameConfirmation: "Quit the game?"
+SaveGameDenied: "The game cannot be saved right now."
+SavingInProgress: "Saving..."
+ScreenshotFailed: "Failed to save screenshot"
+ScreenshotMade: "%s has been saved"
+
+
+# Save game menu
+
+DeleteGame: "Delete Game"
+DeleteGameConfirmation: "Are you sure you want to delete this saved game?"
+EmptySaveNameError: "Game can not be saved without a name!"
+LoadGameConfirmation: "Do you want to load a saved game and lose the current one?"
+MissingContentFilesConfirmation: |-
+    The currently selected content files do not match the ones used by this save game.
+    Errors may occur during load or game play.
+    Do you wish to continue?
+MissingContentFilesList: |-
+  {files, plural,
+    one{\n\nFound missing file: }
+    few{\n\nFound {files} missing files:\n}
+    other{\n\nFound {files} missing files:\n}
+  }
+MissingContentFilesListCopy: |-
+  {files, plural,
+    one{\n\nPress Copy to place its name to the clipboard.}
+    few{\n\nPress Copy to place their names to the clipboard.}
+    other{\n\nPress Copy to place their names to the clipboard.}
+  }
+OverwriteGameConfirmation: "Are you sure you want to overwrite this saved game?"
+SelectCharacter: "Select Character..."
+TimePlayed: "Time played"
+
+
+# Settings menu
+
+ActorsProcessingRange: "Actors Processing Range"
+Anisotropy: "Anisotropy"
+Audio: "Audio"
+AudioEffects: "Effects"
+AudioFootsteps: "Footsteps"
+AudioMaster: "Master"
+AudioMusic: "Music"
+AudioVoice: "Voice"
+CameraSensitivity: "Camera Sensitivity"
+CameraZoomIn: "Zoom Camera In"
+CameraZoomOut: "Zoom Camera Out"
+ChangeRequiresRestart: "This change requires a restart to take effect."
+ConfirmResetBindings: "Reset all controls to the default?"
+ConfirmResolution: "New resolution will be applied immediately. Do you want to continue?"
+Controller: "Controller"
+Controls: "Controls"
+DelayLow: "Fast"
+DelayHigh: "Slow"
+DetailLevel: "Detail Level"
+Difficulty: "Difficulty"
+DifficultyEasy: "Easy"
+DifficultyHard: "Hard"
+DistanceHigh: "Far"
+DistanceLow: "Near"
+EnableController: "Enable Controller"
+FieldOfView: "Field of View"
+FieldOfViewHigh: "High"
+FieldOfViewLow: "Low"
+FrameRateHint: "Hint: press F3 to show\nthe current frame rate."
+GammaCorrection: "Gamma Correction"
+GammaDark: "Dark"
+GammaLight: "Light"
+GmstOverridesL10n: "Strings from ESM files have priority"
+InvertXAxis: "Invert X Axis"
+InvertYAxis: "Invert Y Axis"
+Language: "Language"
+LanguageNote: "Note: these settings do not affect strings from ESM files."
+LightingMethod: "Lighting Method"
+LightingMethodLegacy: "Legacy"
+LightingMethodShaders: "Shaders"
+LightingMethodShadersCompatibility: "Shaders (compatibility)"
+LightingResetToDefaults: "Resets to default values, would you like to continue? Changes to lighting method will require a restart."
+Lights: "Lights"
+LightsBoundingSphereMultiplier: "Bounding Sphere Multiplier"
+LightsBoundingSphereMultiplierTooltip: "Default: 1.65\nMultipler for bounding sphere of lights.\nHigher numbers allows for smooth falloff but require an increase in number of max lights.\n\nDoes not effect the illumination or strength of lights."
+LightsFadeStartMultiplier: "Fade Start Multiplier"
+LightsFadeStartMultiplierTooltip: "Default: 0.85\nFraction of maximum distance at which lights will start to fade.\n\nSet this to a low value for slower transitions or a high value for quicker transitions."
+LightsLightingMethodTooltip: "Set the internal handling of light sources.\n\n
+    \"Legacy\" always uses 8 lights per object and provides a lighting closest to an original game.\n\n
+    \"Shaders (compatibility)\" removes the 8 light limit. This mode also enables lighting on groundcover and a configurable light fade. It is recommended to use this with older hardware and a light limit closer to 8.\n\n
+    \"Shaders\" carries all of the benefits that \"Shaders (compatibility)\" does, but uses a modern approach that allows for a higher max lights count with little to no performance penalties on modern hardware."
+LightsMaximumDistance: "Maximum Light Distance"
+LightsMaximumDistanceTooltip: "Default: 8192\nMaximum distance at which lights will appear (measured in units).\n\nSet this to 0 to use an unlimited distance."
+LightsMinimumInteriorBrightness: "Minimum Interior Brightness"
+LightsMinimumInteriorBrightnessTooltip: "Default: 0.08\nMinimum ambient interior brightness.\n\nIncrease this if you feel interiors are too dark."
+MaxLights: "Max Lights"
+MaxLightsTooltip: "Default: 8\nMaximum number of lights per object.\n\nA low number near default will cause light popping similar to what you would see with legacy lighting."
+MenuHelpDelay: "Menu Help Delay"
+MenuTransparency: "Menu Transparency"
+MouseAndKeyboard: "Mouse/Keyboard"
+PostProcessing: "Post Processing"
+PostProcessingIsNotEnabled: "Postprocessor is not enabled"
+PostProcessingTooltip: "Tweaked via Post Processor HUD, see input bindings."
+Preferences: "Prefs"
+PrimaryLanguage: "Primary Language"
+PrimaryLanguageTooltip: "Localization files for this language have the highest priority."
+QualityHigh: "High"
+QualityLow: "Low"
+QualityMedium: "Medium"
+RainRippleDetail: "Rain ripple detail"
+RainRippleDetailDense: "Dense"
+RainRippleDetailSimple: "Simple"
+RainRippleDetailSparse: "Sparse"
+RebindAction: "Press a key or button to rebind this control."
+ReflectionShaderDetail: "Reflection shader detail"
+ReflectionShaderDetailActors: "Actors"
+ReflectionShaderDetailGroundcover: "Groundcover"
+ReflectionShaderDetailObjects: "Objects"
+ReflectionShaderDetailSky: "Sky"
+ReflectionShaderDetailTerrain: "Terrain"
+ReflectionShaderDetailWorld: "World"
+Refraction: "Refraction"
+ResetControls: "Reset Controls"
+Screenshot: "Screenshot"
+Scripts: "Scripts"
+ScriptsDisabled: "Load a game to access script settings."
+SecondaryLanguage: "Secondary Language"
+SecondaryLanguageTooltip: "Localization files for this language may be used if the primary language files lack the necessary lines."
+SensitivityHigh: "High"
+SensitivityLow: "Low"
+SettingsWindow: "Options"
+Subtitles: "Subtitles"
+TestingExteriorCells: "Testing exterior cells"
+TestingInteriorCells: "Testing interior cells"
+TextureFiltering: "Texture Filtering"
+TextureFilteringBilinear: "Bilinear"
+TextureFilteringDisabled: "None"
+TextureFilteringOther: "Other"
+TextureFilteringTrilinear: "Trilinear"
+ToggleHUD: "Toggle HUD"
+TogglePostProcessorHUD: "Toggle Post Processor HUD"
+TransparencyFull: "Full"
+TransparencyNone: "None"
+Video: "Video"
+ViewDistance: "View Distance"
+VSync: "VSync"
+VSyncAdaptive: "Adaptive"
+Water: "Water"
+WaterShader: "Water shader"
+WaterShaderTextureQuality: "Texture quality"
+WindowBorder: "Window Border"
+WindowMode: "Window Mode"
+WindowModeFullscreen: "Fullscreen"
+WindowModeHint: "Hint: Windowed Fullscreen mode\nalways uses the native display resolution."
+WindowModeWindowed: "Windowed"
+WindowModeWindowedFullscreen: "Windowed Fullscreen"
diff --git a/files/data/mygui/openmw_settings_window.layout b/files/data/mygui/openmw_settings_window.layout
index 27298b9756a..3a548aa9a98 100644
--- a/files/data/mygui/openmw_settings_window.layout
+++ b/files/data/mygui/openmw_settings_window.layout
@@ -453,6 +453,20 @@
                                 </Widget>
                             </Widget>
 
+                            <Widget type="HBox" align="Stretch">
+                                <UserString key="HStretch" value="true"/>
+                                <UserString key="VStretch" value="false"/>
+
+                                <Widget type="AutoSizedButton" skin="MW_Button">
+                                    <UserString key="SettingCategory" value="Water"/>
+                                    <UserString key="SettingName" value="shader ripples"/>
+                                    <UserString key="SettingType" value="CheckButton"/>
+                                </Widget>
+                                <Widget type="AutoSizedTextBox" skin="SandText">
+                                    <Property key="Caption" value="#{OMWEngine:WaterShaderRipples}"/>
+                                </Widget>
+                            </Widget>
+
                             <Widget type="HBox" align="Stretch">
                                 <UserString key="HStretch" value="true"/>
                                 <UserString key="VStretch" value="false"/>
diff --git a/files/data/mygui/openmw_settings_window.layout.orig b/files/data/mygui/openmw_settings_window.layout.orig
new file mode 100644
index 00000000000..27298b9756a
--- /dev/null
+++ b/files/data/mygui/openmw_settings_window.layout.orig
@@ -0,0 +1,729 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<MyGUI type="Layout" version="3.2.0">
+    <Widget type="Window" skin="MW_Window" position="0 0 400 485" layer="MainMenu" name="_Main">
+        <Property key="MinSize" value="640 490"/>
+        <Widget type="TabControl" skin="TabControl" position="8 8 368 405" align="Stretch" name="SettingsTab">
+            <Property key="ButtonAutoWidth" value="true"/>
+            <Widget type="TabItem">
+                <Property key="Caption" value=" #{OMWEngine:Preferences} "/>
+                <Widget type="Widget" position="4 4 352 54" align="Left Top HStretch">
+                    <Widget type="TextBox" skin="NormalText" position="0 0 352 16" align="Left Top">
+                        <Property key="Caption" value="#{OMWEngine:MenuTransparency}"/>
+                    </Widget>
+                    <Widget type="ScrollBar" skin="MW_HScroll" position="0 20 352 14" align="Left Top HStretch">
+                        <Property key="Range" value="10000"/>
+                        <Property key="Page" value="300"/>
+                        <UserString key="SettingType" value="Slider"/>
+                        <UserString key="SettingCategory" value="GUI"/>
+                        <UserString key="SettingName" value="menu transparency"/>
+                        <UserString key="SettingValueType" value="Float"/>
+                    </Widget>
+                    <Widget type="TextBox" skin="SandText" position="0 38 352 16" align="Left Top">
+                        <Property key="Caption" value="#{OMWEngine:TransparencyFull}"/>
+                        <Property key="TextAlign" value="Left"/>
+                    </Widget>
+                    <Widget type="TextBox" skin="SandText" position="0 38 352 16" align="Right Top">
+                        <Property key="Caption" value="#{OMWEngine:TransparencyNone}"/>
+                        <Property key="TextAlign" value="Right"/>
+                    </Widget>
+                </Widget>
+                <Widget type="Widget" position="4 64 352 54" align="Left Top HStretch">
+                    <Widget type="TextBox" skin="NormalText" position="0 0 352 16" align="Left Top">
+                        <Property key="Caption" value="#{OMWEngine:MenuHelpDelay}"/>
+                    </Widget>
+                    <Widget type="ScrollBar" skin="MW_HScroll" position="0 20 352 14" align="Left Top HStretch">
+                        <Property key="Range" value="10000"/>
+                        <Property key="Page" value="300"/>
+                        <UserString key="SettingType" value="Slider"/>
+                        <UserString key="SettingCategory" value="GUI"/>
+                        <UserString key="SettingName" value="tooltip delay"/>
+                        <UserString key="SettingValueType" value="Float"/>
+                    </Widget>
+                    <Widget type="TextBox" skin="SandText" position="0 38 352 16" align="Left Top">
+                        <Property key="Caption" value="#{OMWEngine:DelayLow}"/>
+                        <Property key="TextAlign" value="Left"/>
+                    </Widget>
+                    <Widget type="TextBox" skin="SandText" position="0 38 352 16" align="Right Top">
+                        <Property key="Caption" value="#{OMWEngine:DelayHigh}"/>
+                        <Property key="TextAlign" value="Right"/>
+                    </Widget>
+                </Widget>
+                <Widget type="Widget" position="4 124 352 54" align="Left Top HStretch">
+                    <Widget type="TextBox" skin="NormalText" position="0 0 352 16" align="Left Top" name="DifficultyText">
+                        <Property key="Caption" value="#{OMWEngine:Difficulty}"/>
+                    </Widget>
+                    <Widget type="ScrollBar" skin="MW_HScroll" position="0 20 352 14" align="Left Top HStretch">
+                        <Property key="Range" value="201"/>
+                        <Property key="Page" value="1"/>
+                        <UserString key="SettingType" value="Slider"/>
+                        <UserString key="SettingCategory" value="Game"/>
+                        <UserString key="SettingName" value="difficulty"/>
+                        <UserString key="SettingValueType" value="Integer"/>
+                        <UserString key="SettingMin" value="-100"/>
+                        <UserString key="SettingMax" value="100"/>
+                        <UserString key="SettingLabelWidget" value="DifficultyText"/>
+                        <UserString key="SettingLabelCaption" value="#{OMWEngine:Difficulty} (%s)"/>
+                    </Widget>
+                    <Widget type="TextBox" skin="SandText" position="0 38 352 16" align="Left Top">
+                        <Property key="Caption" value="#{OMWEngine:DifficultyEasy}"/>
+                        <Property key="TextAlign" value="Left"/>
+                    </Widget>
+                    <Widget type="TextBox" skin="SandText" position="0 38 352 16" align="Right Top">
+                        <Property key="Caption" value="#{OMWEngine:DifficultyHard}"/>
+                        <Property key="TextAlign" value="Right"/>
+                    </Widget>
+                </Widget>
+                <Widget type="Widget" position="4 184 400 54" align="Left Top HStretch">
+                    <Widget type="TextBox" skin="NormalText" position="0 0 400 16" align="Left Top" name="ActorProcessingText">
+                        <Property key="Caption" value="#{OMWEngine:ActorsProcessingRange}"/>
+                    </Widget>
+                    <Widget type="ScrollBar" skin="MW_HScroll" position="0 20 352 14" align="Left Top HStretch">
+                        <Property key="Range" value="3584"/>
+                        <Property key="Page" value="300"/>
+                        <UserString key="SettingType" value="Slider"/>
+                        <UserString key="SettingCategory" value="Game"/>
+                        <UserString key="SettingName" value="actors processing range"/>
+                        <UserString key="SettingValueType" value="Integer"/>
+                        <UserString key="SettingMin" value="3584"/>
+                        <UserString key="SettingMax" value="7168"/>
+                        <UserString key="SettingLabelWidget" value="ActorProcessingText"/>
+                        <UserString key="SettingLabelCaption" value="#{OMWEngine:ActorsProcessingRange} (%s)"/>
+                    </Widget>
+                    <Widget type="TextBox" skin="SandText" position="0 38 352 16" align="Left Top">
+                        <Property key="Caption" value="#{OMWEngine:DistanceLow}"/>
+                        <Property key="TextAlign" value="Left"/>
+                    </Widget>
+                    <Widget type="TextBox" skin="SandText" position="0 38 352 16" align="Right Top">
+                        <Property key="Caption" value="#{OMWEngine:DistanceHigh}"/>
+                        <Property key="TextAlign" value="Right"/>
+                    </Widget>
+                </Widget>
+                <Widget type="HBox" position="4 250 260 28">
+                    <Widget type="AutoSizedButton" skin="MW_Button" position="0 0 24 24" align="Left Top">
+                        <UserString key="SettingCategory" value="Saves"/>
+                        <UserString key="SettingName" value="autosave"/>
+                        <UserString key="SettingType" value="CheckButton"/>
+                    </Widget>
+                    <Widget type="AutoSizedTextBox" skin="SandText" position="28 4 95 16" align="Left Top">
+                        <Property key="Caption" value="#{sQuick_Save}"/>
+                    </Widget>
+                </Widget>
+                <Widget type="HBox" position="4 280 260 28">
+                    <Widget type="AutoSizedButton" skin="MW_Button" position="0 0 24 24" align="Left Top">
+                        <UserString key="SettingCategory" value="Game"/>
+                        <UserString key="SettingName" value="best attack"/>
+                        <UserString key="SettingType" value="CheckButton"/>
+                    </Widget>
+                    <Widget type="AutoSizedTextBox" skin="SandText" position="28 4 89 16" align="Left Top">
+                        <Property key="Caption" value="#{sBestAttack}"/>
+                    </Widget>
+                </Widget>
+                <Widget type="HBox" position="4 310 260 28">
+                    <Widget type="AutoSizedButton" skin="MW_Button" position="0 0 24 24" align="Left Top">
+                        <UserString key="SettingCategory" value="GUI"/>
+                        <UserString key="SettingName" value="subtitles"/>
+                        <UserString key="SettingType" value="CheckButton"/>
+                    </Widget>
+                    <Widget type="AutoSizedTextBox" skin="SandText" position="28 4 71 16" align="Left Top">
+                        <Property key="Caption" value="#{OMWEngine:Subtitles}"/>
+                    </Widget>
+                </Widget>
+                <Widget type="HBox" position="4 340 260 28">
+                    <Widget type="AutoSizedButton" skin="MW_Button" position="0 0 24 24" align="Left Top">
+                        <UserString key="SettingCategory" value="HUD"/>
+                        <UserString key="SettingName" value="crosshair"/>
+                        <UserString key="SettingType" value="CheckButton"/>
+                    </Widget>
+                    <Widget type="AutoSizedTextBox" skin="SandText" position="28 4 80 16" align="Left Top">
+                        <Property key="Caption" value="#{sCursorOff}"/>
+                    </Widget>
+                </Widget>
+            </Widget>
+            <Widget type="TabItem">
+                <Property key="Caption" value=" #{OMWEngine:Audio} "/>
+                <Widget type="TextBox" skin="NormalText" position="4 4 352 18" align="Left Top">
+                    <Property key="Caption" value="#{OMWEngine:AudioMaster}"/>
+                </Widget>
+                <Widget type="ScrollBar" skin="MW_HScroll" position="4 28 352 18" align="HStretch Top">
+                    <Property key="Range" value="10000"/>
+                    <Property key="Page" value="300"/>
+                    <UserString key="SettingType" value="Slider"/>
+                    <UserString key="SettingCategory" value="Sound"/>
+                    <UserString key="SettingName" value="master volume"/>
+                    <UserString key="SettingValueType" value="Float"/>
+                </Widget>
+                <Widget type="TextBox" skin="NormalText" position="4 54 352 18" align="Left Top">
+                    <Property key="Caption" value="#{OMWEngine:AudioVoice}"/>
+                </Widget>
+                <Widget type="ScrollBar" skin="MW_HScroll" position="4 78 352 18" align="HStretch Top">
+                    <Property key="Range" value="10000"/>
+                    <Property key="Page" value="300"/>
+                    <UserString key="SettingType" value="Slider"/>
+                    <UserString key="SettingCategory" value="Sound"/>
+                    <UserString key="SettingName" value="voice volume"/>
+                    <UserString key="SettingValueType" value="Float"/>
+                </Widget>
+                <Widget type="TextBox" skin="NormalText" position="4 104 352 18" align="Left Top">
+                    <Property key="Caption" value="#{OMWEngine:AudioEffects}"/>
+                </Widget>
+                <Widget type="ScrollBar" skin="MW_HScroll" position="4 128 352 18" align="HStretch Top">
+                    <Property key="Range" value="10000"/>
+                    <Property key="Page" value="300"/>
+                    <UserString key="SettingType" value="Slider"/>
+                    <UserString key="SettingCategory" value="Sound"/>
+                    <UserString key="SettingName" value="sfx volume"/>
+                    <UserString key="SettingValueType" value="Float"/>
+                </Widget>
+                <Widget type="TextBox" skin="NormalText" position="4 154 352 18" align="Left Top">
+                    <Property key="Caption" value="#{OMWEngine:AudioFootsteps}"/>
+                </Widget>
+                <Widget type="ScrollBar" skin="MW_HScroll" position="4 178 352 18" align="HStretch Top">
+                    <Property key="Range" value="10000"/>
+                    <Property key="Page" value="300"/>
+                    <UserString key="SettingType" value="Slider"/>
+                    <UserString key="SettingCategory" value="Sound"/>
+                    <UserString key="SettingName" value="footsteps volume"/>
+                    <UserString key="SettingValueType" value="Float"/>
+                </Widget>
+                <Widget type="TextBox" skin="NormalText" position="4 204 352 18" align="Left Top">
+                    <Property key="Caption" value="#{OMWEngine:AudioMusic}"/>
+                </Widget>
+                <Widget type="ScrollBar" skin="MW_HScroll" position="4 228 352 18" align="HStretch Top">
+                    <Property key="Range" value="10000"/>
+                    <Property key="Page" value="300"/>
+                    <UserString key="SettingType" value="Slider"/>
+                    <UserString key="SettingCategory" value="Sound"/>
+                    <UserString key="SettingName" value="music volume"/>
+                    <UserString key="SettingValueType" value="Float"/>
+                </Widget>
+            </Widget>
+            <Widget type="TabItem">
+                <Property key="Caption" value=" #{OMWEngine:Controls} "/>
+
+                <Widget type="HBox" position="4 4 360 28">
+                    <Property key="Padding" value="0"/>
+                    <Property key="Spacing" value="4"/>
+                    <Widget type="AutoSizedButton" skin="MW_Button" name="KeyboardButton">
+                        <Property key="Caption" value="#{OMWEngine:MouseAndKeyboard}"/>
+                    </Widget>
+                    <Widget type="AutoSizedButton" skin="MW_Button" name="ControllerButton">
+                        <Property key="Caption" value="#{OMWEngine:Controller}"/>
+                    </Widget>
+                </Widget>
+
+                <Widget type="Widget" skin="MW_Box" position="4 38 352 154" align="Stretch">
+                    <Widget type="ScrollView" skin="MW_ScrollView" position="4 4 344 146" align="Stretch" name="ControlsBox">
+                        <Property key="CanvasAlign" value="Left Top"/>
+                    </Widget>
+                </Widget>
+                <Widget type="AutoSizedButton" skin="MW_Button" position="4 198 137 24" align="Left Bottom" name="ResetControlsButton">
+                    <Property key="Caption" value="#{OMWEngine:ResetControls}"/>
+                </Widget>
+                <Widget type="HBox" position="4 228 600 28" align="Left Bottom">
+                    <Widget type="AutoSizedButton" skin="MW_Button">
+                        <UserString key="SettingCategory" value="Input"/>
+                        <UserString key="SettingName" value="invert x axis"/>
+                        <UserString key="SettingType" value="CheckButton"/>
+                    </Widget>
+                    <Widget type="AutoSizedTextBox" skin="SandText">
+                        <Property key="Caption" value="#{OMWEngine:InvertXAxis} "/>
+                    </Widget>
+                    <Widget type="AutoSizedButton" skin="MW_Button">
+                        <UserString key="SettingCategory" value="Input"/>
+                        <UserString key="SettingName" value="invert y axis"/>
+                        <UserString key="SettingType" value="CheckButton"/>
+                    </Widget>
+                    <Widget type="AutoSizedTextBox" skin="SandText" position="56 4 78 16" align="Left Bottom">
+                        <Property key="Caption" value="#{OMWEngine:InvertYAxis}"/>
+                    </Widget>
+                </Widget>
+                <Widget type="TextBox" skin="NormalText" position="4 258 352 18" align="Left Bottom">
+                    <Property key="Caption" value="#{OMWEngine:CameraSensitivity}"/>
+                </Widget>
+                <Widget type="ScrollBar" skin="MW_HScroll" position="4 282 352 18" align="HStretch Bottom">
+                    <Property key="Range" value="10000"/>
+                    <Property key="Page" value="300"/>
+                    <UserString key="SettingType" value="Slider"/>
+                    <UserString key="SettingCategory" value="Input"/>
+                    <UserString key="SettingName" value="camera sensitivity"/>
+                    <UserString key="SettingValueType" value="Float"/>
+                    <UserString key="SettingMin" value="0.2"/>
+                    <UserString key="SettingMax" value="5.0"/>
+                </Widget>
+                <Widget type="TextBox" skin="SandText" position="4 306 352 18" align="Left Bottom">
+                    <Property key="Caption" value="#{OMWEngine:SensitivityLow}"/>
+                    <Property key="TextAlign" value="Left"/>
+                </Widget>
+                <Widget type="TextBox" skin="SandText" position="4 306 352 18" align="Right Bottom">
+                    <Property key="Caption" value="#{OMWEngine:SensitivityHigh}"/>
+                    <Property key="TextAlign" value="Right"/>
+                </Widget>
+                <Widget type="HBox" position="4 328 352 28" align="Left Bottom">
+                    <Widget type="AutoSizedButton" skin="MW_Button" position="0 0 24 24" align="Left Bottom">
+                        <UserString key="SettingCategory" value="Input"/>
+                        <UserString key="SettingName" value="enable controller"/>
+                        <UserString key="SettingType" value="CheckButton"/>
+                    </Widget>
+                    <Widget type="AutoSizedTextBox" skin="SandText" position="28 4 78 16" align="Left Bottom">
+                        <Property key="Caption" value="#{OMWEngine:EnableController}"/>
+                    </Widget>
+                </Widget>
+            </Widget>
+            <Widget type="TabItem">
+                <Property key="Caption" value=" #{OMWEngine:Video} "/>
+                <Widget type="TabControl" skin="TabControlInner" position="4 4 352 390" align="Stretch">
+                    <Property key="ButtonAutoWidth" value="true"/>
+                    <Widget type="TabItem">
+                        <Property key="Caption" value=" #{OMWEngine:Video} "/>
+                        <Widget type="ListBox" skin="MW_List" position="0 4 195 225" align="Left Top" name="ResolutionList"/>
+                        <Widget type="TextBox" skin="NormalText" position="207 4 250 18" align="Left Top">
+                            <Property key="Caption" value="#{OMWEngine:WindowMode}"/>
+                        </Widget>
+                        <Widget type="HBox" position="207 24 400 24">
+                            <Widget type="ComboBox" skin="MW_ComboBox" position="0 0 200 24" align="Left Top" name="WindowModeList">
+                                <Property key="AddItem" value="#{OMWEngine:WindowModeFullscreen}"/>
+                                <Property key="AddItem" value="#{OMWEngine:WindowModeWindowedFullscreen}"/>
+                                <Property key="AddItem" value="#{OMWEngine:WindowModeWindowed}"/>
+                            </Widget>
+                        </Widget>
+                        <Widget type="TextBox" skin="NormalText" position="207 54 250 18" align="Left Top">
+                            <Property key="Caption" value="#{OMWEngine:VSync}"/>
+                        </Widget>
+                        <Widget type="HBox" position="207 74 400 28">
+                            <Widget type="ComboBox" skin="MW_ComboBox" position="0 0 200 24" align="Left Top" name="VSyncModeList">
+                                <Property key="AddItem" value="#{Interface:Off}"/>
+                                <Property key="AddItem" value="#{Interface:On}"/>
+                                <Property key="AddItem" value="#{OMWEngine:VSyncAdaptive}"/>
+                            </Widget>
+                        </Widget>
+                        <Widget type="HBox" position="207 108 300 28">
+                            <Widget type="AutoSizedButton" skin="MW_Button" position="0 0 24 24" align="Left Top" name="WindowBorderButton">
+                                <UserString key="SettingCategory" value="Video"/>
+                                <UserString key="SettingName" value="window border"/>
+                                <UserString key="SettingType" value="CheckButton"/>
+                            </Widget>
+                            <Widget type="AutoSizedTextBox" skin="SandText" position="28 4 48 16" align="Left Top">
+                                <Property key="Caption" value="#{OMWEngine:WindowBorder}"/>
+                            </Widget>
+                        </Widget>
+                        <Widget type="HBox" position="207 142 300 28">
+                            <Widget type="AutoSizedButton" skin="MW_Button" position="0 0 24 24" align="Left Top" name="WindowBorderButton">
+                                <UserString key="SettingCategory" value="Post Processing"/>
+                                <UserString key="SettingName" value="enabled"/>
+                                <UserString key="SettingType" value="CheckButton"/>
+                            </Widget>
+                            <Widget type="AutoSizedTextBox" skin="SandText" position="28 4 48 16" align="Left Top">
+                                <Property key="Caption" value="#{OMWEngine:PostProcessing}"/>
+                                <UserString key="ToolTipType" value="Layout"/>
+                                <UserString key="ToolTipLayout" value="TextToolTip"/>
+                                <UserString key="Caption_Text" value="#{OMWEngine:PostProcessingTooltip}"/>
+                            </Widget>
+                        </Widget>
+
+                        <Widget type="AutoSizedTextBox" skin="SandText" position="207 174 300 32" align="Left Top">
+                            <Property key="Caption" value="#{OMWEngine:FrameRateHint}"/>
+                        </Widget>
+                        <Widget type="AutoSizedTextBox" skin="SandText" position="207 216 300 32" align="Left Top" name="WindowModeHint">
+                            <Property key="Caption" value="#{OMWEngine:WindowModeHint}"/>
+                        </Widget>
+
+                        <Widget type="TextBox" skin="NormalText" position="0 238 352 18" align="Left Top" name="FovText">
+                        </Widget>
+                        <Widget type="ScrollBar" skin="MW_HScroll" position="0 262 352 18" align="HStretch Top">
+                            <Property key="Range" value="81"/>
+                            <Property key="Page" value="1"/>
+                            <UserString key="SettingType" value="Slider"/>
+                            <UserString key="SettingCategory" value="Camera"/>
+                            <UserString key="SettingName" value="field of view"/>
+                            <UserString key="SettingValueType" value="Float"/>
+                            <UserString key="SettingMin" value="30"/>
+                            <UserString key="SettingMax" value="110"/>
+                            <UserString key="SettingLabelWidget" value="FovText"/>
+                            <UserString key="SettingLabelCaption" value="#{OMWEngine:FieldOfView} (%s)"/>
+                        </Widget>
+                        <Widget type="TextBox" skin="SandText" position="0 286 352 18" align="Left Top">
+                            <Property key="Caption" value="#{OMWEngine:FieldOfViewLow}"/>
+                            <Property key="TextAlign" value="Left"/>
+                        </Widget>
+                        <Widget type="TextBox" skin="SandText" position="0 286 352 18" align="Right Top">
+                            <Property key="Caption" value="#{OMWEngine:FieldOfViewHigh}"/>
+                            <Property key="TextAlign" value="Right"/>
+                        </Widget>
+                        <Widget type="TextBox" skin="NormalText" position="0 308 352 18" align="Left Top" name="GammaText">
+                            <Property key="Caption" value="#{OMWEngine:GammaCorrection}"/>
+                        </Widget>
+                        <Widget type="ScrollBar" skin="MW_HScroll" position="0 332 352 18" align="HStretch Top" name="GammaSlider">
+                            <Property key="Range" value="10000"/>
+                            <Property key="Page" value="300"/>
+                            <UserString key="SettingType" value="Slider"/>
+                            <UserString key="SettingCategory" value="Video"/>
+                            <UserString key="SettingName" value="gamma"/>
+                            <UserString key="SettingValueType" value="Float"/>
+                            <UserString key="SettingMin" value="0.1"/>
+                            <UserString key="SettingMax" value="3.0"/>
+                        </Widget>
+                        <Widget type="TextBox" skin="SandText" position="0 356 352 18" align="Left Top" name="GammaTextDark">
+                            <Property key="Caption" value="#{OMWEngine:GammaDark}"/>
+                            <Property key="TextAlign" value="Left"/>
+                        </Widget>
+                        <Widget type="TextBox" skin="SandText" position="0 356 352 18" align="Right Top" name="GammaTextLight">
+                            <Property key="Caption" value="#{OMWEngine:GammaLight}"/>
+                            <Property key="TextAlign" value="Right"/>
+                        </Widget>
+                    </Widget>
+                    <Widget type="TabItem">
+                        <Property key="Caption" value=" #{OMWEngine:DetailLevel} "/>
+
+                        <Widget type="AutoSizedTextBox" skin="NormalText" align="Left Top">
+                            <Property key="Caption" value="#{OMWEngine:TextureFiltering}"/>
+                            <UserString key="VStretch" value="false"/>
+                            <UserString key="HStretch" value="false"/>
+                        </Widget>
+                        <Widget type="ComboBox" align="Left Top" skin="MW_ComboBox" position="0 28 200 24" name="TextureFilteringButton">
+                            <Property key="AddItem" value="#{OMWEngine:TextureFilteringBilinear}"/>
+                            <Property key="AddItem" value="#{OMWEngine:TextureFilteringTrilinear}"/>
+                        </Widget>
+
+                        <Widget type="AutoSizedTextBox" skin="NormalText" position="0 58 200 18" name="AnisotropyLabel">
+                            <Property key="Caption" value="#{OMWEngine:Anisotropy}"/>
+                        </Widget>
+                        <Widget type="ScrollBar" skin="MW_HScroll" position="0 80 352 18" align="HStretch Top">
+                            <Property key="Range" value="17"/>
+                            <Property key="Page" value="1"/>
+                            <UserString key="SettingType" value="Slider"/>
+                            <UserString key="SettingCategory" value="General"/>
+                            <UserString key="SettingName" value="anisotropy"/>
+                            <UserString key="SettingLabelWidget" value="AnisotropyLabel"/>
+                            <UserString key="SettingLabelCaption" value="#{OMWEngine:Anisotropy} (%s)"/>
+                        </Widget>
+
+                        <Widget type="AutoSizedTextBox" skin="NormalText" position="0 104 0 18" align="Left Top" name="RenderDistanceLabel">
+                            <Property key="Caption" value="#{OMWEngine:ViewDistance}"/>
+                        </Widget>
+                        <Widget type="ScrollBar" skin="MW_HScroll" position="0 126 352 18" align="HStretch Top" name="RenderingDistanceSlider">
+                            <Property key="Range" value="4669"/>
+                            <Property key="Page" value="128"/>
+                            <UserString key="SettingType" value="Slider"/>
+                            <UserString key="SettingCategory" value="Camera"/>
+                            <UserString key="SettingName" value="viewing distance"/>
+                            <UserString key="SettingValueType" value="Float"/>
+                            <UserString key="SettingMin" value="2500"/>
+                            <UserString key="SettingMax" value="7168"/>
+                            <UserString key="SettingLabelWidget" value="RenderDistanceLabel"/>
+                            <UserString key="SettingLabelCaption" value="#{OMWEngine:ViewDistance} (%s)"/>
+                        </Widget>
+                        <Widget type="ScrollBar" skin="MW_HScroll" position="0 126 352 18" align="HStretch Top" name="LargeRenderingDistanceSlider">
+                            <Property key="Range" value="79421"/>
+                            <Property key="Page" value="2048"/>
+                            <UserString key="SettingType" value="Slider"/>
+                            <UserString key="SettingCategory" value="Camera"/>
+                            <UserString key="SettingName" value="viewing distance"/>
+                            <UserString key="SettingValueType" value="Cell"/>
+                            <UserString key="SettingMin" value="2500"/>
+                            <UserString key="SettingMax" value="81920"/>
+                            <UserString key="SettingLabelWidget" value="RenderDistanceLabel"/>
+                            <UserString key="SettingLabelCaption" value="#{OMWEngine:ViewDistance} (x%s)"/>
+                        </Widget>
+                        <Widget type="TextBox" skin="SandText" position="0 148 352 18" align="Left Top">
+                            <Property key="Caption" value="#{OMWEngine:DistanceLow}"/>
+                            <Property key="TextAlign" value="Left"/>
+                        </Widget>
+                        <Widget type="TextBox" skin="SandText" position="0 148 352 18" align="Right Top">
+                            <Property key="Caption" value="#{OMWEngine:DistanceHigh}"/>
+                            <Property key="TextAlign" value="Right"/>
+                        </Widget>
+
+                    </Widget>
+                    <Widget type="TabItem">
+                        <Property key="Caption" value=" #{OMWEngine:Water} "/>
+
+                        <Widget type="VBox" position_real="0 0 1 1" align="Stretch">
+
+                            <Widget type="HBox" align="Stretch">
+                                <UserString key="HStretch" value="true"/>
+                                <UserString key="VStretch" value="false"/>
+
+                                <Widget type="AutoSizedButton" skin="MW_Button">
+                                    <UserString key="SettingCategory" value="Water"/>
+                                    <UserString key="SettingName" value="shader"/>
+                                    <UserString key="SettingType" value="CheckButton"/>
+                                </Widget>
+                                <Widget type="AutoSizedTextBox" skin="SandText">
+                                    <Property key="Caption" value="#{OMWEngine:WaterShader}"/>
+                                </Widget>
+                            </Widget>
+
+                            <Widget type="HBox" align="Stretch">
+                                <UserString key="HStretch" value="true"/>
+                                <UserString key="VStretch" value="false"/>
+
+                                <Widget type="AutoSizedButton" skin="MW_Button">
+                                    <UserString key="SettingCategory" value="Water"/>
+                                    <UserString key="SettingName" value="refraction"/>
+                                    <UserString key="SettingType" value="CheckButton"/>
+                                </Widget>
+                                <Widget type="AutoSizedTextBox" skin="SandText">
+                                    <Property key="Caption" value="#{OMWEngine:Refraction}"/>
+                                </Widget>
+                            </Widget>
+
+                            <Widget type="Widget" position="0 0 0 18" align="Top Left HStretch">
+                                <UserString key="HStretch" value="true"/>
+                                <Widget type="AutoSizedTextBox" skin="NormalText">
+                                    <Property key="Caption" value="#{OMWEngine:WaterShaderTextureQuality}"/>
+                                </Widget>
+                                <Widget type="Spacer" />
+                            </Widget>
+
+                            <Widget type="HBox" align="Stretch">
+                                <UserString key="HStretch" value="true"/>
+                                <UserString key="VStretch" value="false"/>
+                                <Widget type="ComboBox" skin="MW_ComboBox" position="0 0 200 24" align="Left Top" name="WaterTextureSize">
+                                    <Property key="AddItem" value="#{OMWEngine:QualityLow}"/>
+                                    <Property key="AddItem" value="#{OMWEngine:QualityMedium}"/>
+                                    <Property key="AddItem" value="#{OMWEngine:QualityHigh}"/>
+                                </Widget>
+                                <Widget type="Spacer" />
+                            </Widget>
+
+                            <Widget type="Widget" position="0 0 0 18" align="Top Left HStretch">
+                                <UserString key="HStretch" value="true"/>
+                                <Widget type="AutoSizedTextBox" skin="NormalText">
+                                    <Property key="Caption" value="#{OMWEngine:ReflectionShaderDetail}"/>
+                                </Widget>
+                                <Widget type="Spacer" />
+                            </Widget>
+                            <Widget type="HBox" align="Stretch">
+                                <UserString key="HStretch" value="true"/>
+                                <UserString key="VStretch" value="false"/>
+
+                                <Widget type="ComboBox" skin="MW_ComboBox" position="0 0 200 24" align="Left Top" name="WaterReflectionDetail">
+                                    <Property key="AddItem" value="#{OMWEngine:ReflectionShaderDetailSky}"/>
+                                    <Property key="AddItem" value="#{OMWEngine:ReflectionShaderDetailTerrain}"/>
+                                    <Property key="AddItem" value="#{OMWEngine:ReflectionShaderDetailWorld}"/>
+                                    <Property key="AddItem" value="#{OMWEngine:ReflectionShaderDetailObjects}"/>
+                                    <Property key="AddItem" value="#{OMWEngine:ReflectionShaderDetailActors}"/>
+                                    <Property key="AddItem" value="#{OMWEngine:ReflectionShaderDetailGroundcover}"/>
+                                </Widget>
+                                <Widget type="Spacer" />
+                            </Widget>
+
+                            <Widget type="Widget" position="0 0 0 18" align="Top Left HStretch">
+                                <UserString key="HStretch" value="true"/>
+                                <Widget type="AutoSizedTextBox" skin="NormalText">
+                                    <Property key="Caption" value="#{OMWEngine:RainRippleDetail}"/>
+                                </Widget>
+                                <Widget type="Spacer" />
+                            </Widget>
+
+                            <Widget type="HBox" align="Stretch">
+                                <UserString key="HStretch" value="true"/>
+                                <UserString key="VStretch" value="false"/>
+
+                                <Widget type="ComboBox" skin="MW_ComboBox" position="0 0 200 24" align="Left Top" name="WaterRainRippleDetail">
+                                    <Property key="AddItem" value="#{OMWEngine:RainRippleDetailSimple}"/>
+                                    <Property key="AddItem" value="#{OMWEngine:RainRippleDetailSparse}"/>
+                                    <Property key="AddItem" value="#{OMWEngine:RainRippleDetailDense}"/>
+                                </Widget>
+                                <Widget type="Spacer" />
+                            </Widget>
+
+                        </Widget>
+
+                    </Widget>
+                    <Widget type="TabItem">
+                        <Property key="Caption" value=" #{OMWEngine:Lights} "/>
+                        <!-- Lighting Method -->
+                        <Widget type="TextBox" skin="NormalText" position="0 4 250 18" align="Left Top">
+                            <Property key="Caption" value="#{OMWEngine:LightingMethod}"/>
+                            <UserString key="ToolTipType" value="Layout"/>
+                            <UserString key="ToolTipLayout" value="TextToolTip"/>
+                            <UserString key="Caption_Text" value="#{OMWEngine:LightsLightingMethodTooltip}"/>
+                        </Widget>
+                        <Widget type="ComboBox" skin="MW_ComboBox" position="0 28 250 24" align="Left Top" name="LightingMethodButton">
+                            <Property key="AddItem" value="legacy"/>
+                            <Property key="AddItem" value="shaders compatibility"/>
+                            <Property key="AddItem" value="shaders"/>
+                        </Widget>
+                        <!-- Max Lights -->
+                        <Widget type="TextBox" skin="NormalText" position="258 4 350 18" align="Left Top" name="MaxLightsText">
+                            <UserString key="ToolTipType" value="Layout"/>
+                            <UserString key="ToolTipLayout" value="TextToolTip"/>
+                            <UserString key="Caption_Text" value="#{OMWEngine:MaxLightsTooltip}"/>
+                        </Widget>
+                        <Widget type="ScrollBar" position="0 0 0 0">
+                            <UserString key="SettingType" value="Slider"/>
+                            <UserString key="SettingCategory" value="Shaders"/>
+                            <UserString key="SettingName" value="max lights"/>
+                            <UserString key="SettingValueType" value="Integer"/>
+                            <UserString key="SettingLabelWidget" value="MaxLightsText"/>
+                            <UserString key="SettingLabelCaption" value="#{OMWEngine:MaxLights} (%s)"/>
+                        </Widget>
+                        <Widget type="ComboBox" skin="MW_ComboBox" position="258 28 250 24" align="Left Top" name="MaxLights">
+                            <Property key="AddItem" value="8"/>
+                            <Property key="AddItem" value="16"/>
+                            <Property key="AddItem" value="24"/>
+                            <Property key="AddItem" value="32"/>
+                            <Property key="AddItem" value="40"/>
+                            <Property key="AddItem" value="48"/>
+                            <Property key="AddItem" value="56"/>
+                            <Property key="AddItem" value="64"/>
+                        </Widget>
+                        <Widget type="ImageBox" skin="MW_HLine" position="0 54 360 18" align="Top HStretch"/>
+                        <!-- Light Fade Start -->
+                        <Widget type="TextBox" skin="NormalText" position="0 78 500 18" align="Left Top" name="MaxLightDistanceText">
+                            <UserString key="ToolTipType" value="Layout"/>
+                            <UserString key="ToolTipLayout" value="TextToolTip"/>
+                            <UserString key="Caption_Text" value="#{OMWEngine:LightsMaximumDistanceTooltip}"/>
+                        </Widget>
+                        <Widget type="ScrollBar" skin="MW_HScroll" position="0 104 352 18" align="HStretch Top">
+                            <Property key="Range" value="8193"/>
+                            <Property key="Page" value="128"/>
+                            <UserString key="SettingType" value="Slider"/>
+                            <UserString key="SettingMin" value="0"/>
+                            <UserString key="SettingMax" value="8192"/>
+                            <UserString key="SettingCategory" value="Shaders"/>
+                            <UserString key="SettingName" value="maximum light distance"/>
+                            <UserString key="SettingValueType" value="Float"/>
+                            <UserString key="SettingLabelWidget" value="MaxLightDistanceText"/>
+                            <UserString key="SettingLabelCaption" value="#{OMWEngine:LightsMaximumDistance} (%s)"/>
+                        </Widget>
+                        <!-- Light Fade Multiplier -->
+                        <Widget type="TextBox" skin="NormalText" position="0 128 500 18" align="Left Top" name="LightFadeMultiplierText">
+                            <UserString key="ToolTipType" value="Layout"/>
+                            <UserString key="ToolTipLayout" value="TextToolTip"/>
+                            <UserString key="Caption_Text" value="#{OMWEngine:LightsFadeStartMultiplierTooltip}"/>
+                        </Widget>
+                        <Widget type="ScrollBar" skin="MW_HScroll" position="0 152 352 18" align="HStretch Top">
+                            <Property key="Range" value="10000"/>
+                            <Property key="Page" value="100"/>
+                            <UserString key="SettingType" value="Slider"/>
+                            <UserString key="SettingCategory" value="Shaders"/>
+                            <UserString key="SettingName" value="light fade start"/>
+                            <UserString key="SettingValueType" value="Float"/>
+                            <UserString key="SettingMin" value="0.0"/>
+                            <UserString key="SettingMax" value="1.0"/>
+                            <UserString key="SettingLabelWidget" value="LightFadeMultiplierText"/>
+                            <UserString key="SettingLabelCaption" value="#{OMWEngine:LightsFadeStartMultiplier} (%s)"/>
+                        </Widget>
+                        <!-- Bounding Sphere Multiplier -->
+                        <Widget type="TextBox" skin="NormalText" position="0 176 500 18" align="Left Top" name="BoundingSphereMultText">
+                            <UserString key="ToolTipType" value="Layout"/>
+                            <UserString key="ToolTipLayout" value="TextToolTip"/>
+                            <UserString key="Caption_Text" value="#{OMWEngine:LightsBoundingSphereMultiplierTooltip}"/>
+                        </Widget>
+                        <Widget type="ScrollBar" skin="MW_HScroll" position="0 200 352 18" align="HStretch Top">
+                            <Property key="Range" value="500000"/>
+                            <Property key="Page" value="1000"/>
+                            <UserString key="SettingType" value="Slider"/>
+                            <UserString key="SettingMin" value="0.0"/>
+                            <UserString key="SettingMax" value="5.0"/>
+                            <UserString key="SettingCategory" value="Shaders"/>
+                            <UserString key="SettingName" value="light bounds multiplier"/>
+                            <UserString key="SettingValueType" value="Float"/>
+                            <UserString key="SettingLabelWidget" value="BoundingSphereMultText"/>
+                            <UserString key="SettingLabelCaption" value="#{OMWEngine:LightsBoundingSphereMultiplier} (%s)"/>
+                        </Widget>
+                        <!-- Minimum Ambient Brightness -->
+                        <Widget type="TextBox" skin="NormalText" position="0 224 500 18" align="Left Top" name="MinimumBrightnessText">
+                            <UserString key="ToolTipType" value="Layout"/>
+                            <UserString key="ToolTipLayout" value="TextToolTip"/>
+                            <UserString key="Caption_Text" value="#{OMWEngine:LightsMinimumInteriorBrightnessTooltip}"/>
+                        </Widget>
+                        <Widget type="ScrollBar" skin="MW_HScroll" position="0 248 352 18" align="HStretch Top">
+                            <Property key="Range" value="10000"/>
+                            <Property key="Page" value="100"/>
+                            <UserString key="SettingType" value="Slider"/>
+                            <UserString key="SettingCategory" value="Shaders"/>
+                            <UserString key="SettingName" value="minimum interior brightness"/>
+                            <UserString key="SettingValueType" value="Float"/>
+                            <UserString key="SettingLabelWidget" value="MinimumBrightnessText"/>
+                            <UserString key="SettingLabelCaption" value="#{OMWEngine:LightsMinimumInteriorBrightness} (%s)"/>
+                        </Widget>
+                        <Widget type="AutoSizedButton" skin="MW_Button" position="0 290 0 0" align="Top Left" name="LightsResetButton">
+                            <Property key="Caption" value="#{Interface:Reset}"/>
+                        </Widget>
+                    </Widget>
+                </Widget>
+            </Widget>
+            <Widget type="TabItem">
+                <Property key="Caption" value=" #{OMWEngine:Scripts} "/>
+
+                <Widget name="ScriptDisabled" type="EditBox" skin="SandText" position_real="0 0 1 1" align="HStretch Top">
+                    <Property key="Caption" value="#{OMWEngine:ScriptsDisabled}"/>
+                    <Property key="TextAlign" value="Center"/>
+                    <Property key="MultiLine" value="true"/>
+                    <Property key="WordWrap" value="true"/>
+                    <Property key="Static" value="true"/>
+                </Widget>
+
+                <Widget type="HBox" position_real="0 0 1 0.99" align="Stretch">
+                    <Property key="Padding" value="0"/>
+                    <Property key="Spacing" value="0"/>
+                    <Widget type="VBox" align="Left VStretch">
+                        <UserString key="VStretch" value="true"/>
+
+                        <Widget name="ScriptFilter" type="EditBox" skin="MW_TextEdit" position="0 0 300 28">
+                            <UserString key="HStretch" value="false"/>
+                            <UserString key="VStretch" value="false"/>
+                        </Widget>
+
+                        <Widget name="ScriptList" type="ListBox" skin="MW_List" align="Left VStretch">
+                            <UserString key="HStretch" value="true"/>
+                            <UserString key="VStretch" value="true"/>
+                        </Widget>
+                    </Widget>
+
+                    <Widget name="ScriptBox" type="Widget" align="Stretch" name="ScriptBox">
+                        <UserString key="HStretch" value="true"/>
+                        <UserString key="VStretch" value="true"/>
+
+                        <Widget name="ScriptView" type="ScrollView" skin="MW_ScrollViewVH" align="Stretch">
+                            <Property key="CanvasAlign" value="Left Top"/>
+                            <Widget name="ScriptAdapter" type="LuaAdapter"/>
+                        </Widget>
+                    </Widget>
+
+                </Widget>
+
+            </Widget>
+            <Widget type="TabItem">
+                <Property key="Caption" value=" #{OMWEngine:Language} "/>
+                <Widget type="AutoSizedTextBox" skin="SandText" position="4 4 300 32" align="Left Top">
+                    <Property key="Caption" value="#{OMWEngine:LanguageNote}"/>
+                </Widget>
+                <!-- Primary Language -->
+                <Widget type="TextBox" skin="NormalText" position="4 28 250 18" align="Left Top">
+                    <Property key="Caption" value="#{OMWEngine:PrimaryLanguage}"/>
+                    <UserString key="ToolTipType" value="Layout"/>
+                    <UserString key="ToolTipLayout" value="TextToolTip"/>
+                    <UserString key="Caption_Text" value="#{OMWEngine:PrimaryLanguageTooltip}"/>
+                </Widget>
+                <Widget type="ComboBox" skin="MW_ComboBox" position="4 52 250 24" align="Left Top" name="PrimaryLanguage" />
+                <!-- Secondary Language -->
+                <Widget type="TextBox" skin="NormalText" position="262 28 250 18" align="Left Top">
+                    <Property key="Caption" value="#{OMWEngine:SecondaryLanguage}"/>
+                    <UserString key="ToolTipType" value="Layout"/>
+                    <UserString key="ToolTipLayout" value="TextToolTip"/>
+                    <UserString key="Caption_Text" value="#{OMWEngine:SecondaryLanguageTooltip}"/>
+                </Widget>
+                <Widget type="ComboBox" skin="MW_ComboBox" position="262 52 250 24" align="Left Top" name="SecondaryLanguage" />
+                <Widget type="HBox" position="4 84 500 32">
+                    <Widget type="AutoSizedButton" skin="MW_Button" name="GmstOverridesL10nButton">
+                        <UserString key="SettingCategory" value="General"/>
+                        <UserString key="SettingName" value="gmst overrides l10n"/>
+                        <UserString key="SettingType" value="CheckButton"/>
+                    </Widget>
+                    <Widget type="AutoSizedTextBox" skin="SandText">
+                        <Property key="Caption" value="#{OMWEngine:GmstOverridesL10n} "/>
+                    </Widget>
+                </Widget>
+            </Widget>
+        </Widget>
+        <Widget type="AutoSizedButton" skin="MW_Button" position="320 420 56 24" align="Right Bottom" name="OkButton">
+            <Property key="ExpandDirection" value="Left"/>
+            <Property key="Caption" value="#{Interface:OK}"/>
+        </Widget>
+    </Widget>
+    <CodeGeneratorSettings/>
+</MyGUI>
diff --git a/files/data/shaders/bloomlinear.omwfx b/files/data/shaders/bloomlinear.omwfx
old mode 100644
new mode 100755
index 3de7139f39a..4c583a9a898
--- a/files/data/shaders/bloomlinear.omwfx
+++ b/files/data/shaders/bloomlinear.omwfx
@@ -80,8 +80,8 @@ shared {
         radius = max(radius, 0.1);
         // hack: make the radius wider on the screen edges
         // (makes things in the corner of the screen look less "wrong" with not-extremely-low FOVs)
-        radius *= pow(texcoord.x*2.0-1.0, 2)+1.0;
-        radius *= pow(texcoord.y*2.0-1.0, 2)+1.0;
+        radius *= pow(texcoord.x*2.0-1.0, 2.0)+1.0;
+        radius *= pow(texcoord.y*2.0-1.0, 2.0)+1.0;
         return radius;
     }
     vec3 powv(vec3 a, float x)
@@ -94,7 +94,7 @@ render_target RT_NoMipmap {
     width_ratio = 0.25;
     height_ratio = 0.25;
     internal_format = rgb16f;
-    source_type = float;
+    source_type = half_float;
     source_format = rgb;
     mipmaps = false;
     min_filter = nearest;
@@ -105,7 +105,7 @@ render_target RT_Horizontal {
     width_ratio = 0.25;
     height_ratio = 0.25;
     internal_format = rgb16f;
-    source_type = float;
+    source_type = half_float;
     source_format = rgb;
     mipmaps = false;
     min_filter = nearest;
@@ -116,7 +116,7 @@ render_target RT_Vertical {
     width_ratio = 0.25;
     height_ratio = 0.25;
     internal_format = rgb16f;
-    source_type = float;
+    source_type = half_float;
     source_format = rgb;
     mipmaps = false;
     min_filter = linear;
diff --git a/files/settings-default.cfg b/files/settings-default.cfg
index 1caf03c123f..336a0b34ccf 100644
--- a/files/settings-default.cfg
+++ b/files/settings-default.cfg
@@ -657,6 +657,9 @@ screenshot type = regular
 # Enable water shader with reflections and optionally refraction.
 shader = false
 
+# Enable shader ripples.
+shader ripples = false
+
 # Reflection and refraction texture size in pixels. (512, 1024, 2048).
 rtt size = 512
 
diff --git a/files/settings-default.cfg.orig b/files/settings-default.cfg.orig
new file mode 100644
index 00000000000..1caf03c123f
--- /dev/null
+++ b/files/settings-default.cfg.orig
@@ -0,0 +1,1267 @@
+# WARNING: Users should NOT edit this file. Users should add their personal preferences to the settings.cfg file overriding this file.
+# For the location of the settings.cfg file, as well as more detailed settings documentation, refer to:
+#
+#   https://openmw.readthedocs.io/en/latest/reference/modding/settings/index.html
+#
+
+[Camera]
+
+# Near clipping plane (>0.0, e.g. 0.01 to 18.0).
+near clip = 1
+
+# Cull objects that occupy less than 'small feature culling pixel size' on the screen.
+small feature culling = true
+
+small feature culling pixel size = 2.0
+
+# Maximum visible distance. Caution: this setting
+# can dramatically affect performance, see documentation for details.
+viewing distance = 7168.0
+
+# Camera field of view in degrees (e.g. 30.0 to 110.0).
+# Does not affect the player's hands in the first person camera.
+field of view = 60.0
+
+# Field of view for first person meshes (i.e. the player's hands)
+# Best to leave this at the default since vanilla assets are not complete enough to adapt to high FoV's. Too low FoV would clip the hands off screen.
+first person field of view = 60.0
+
+# Reverse the depth range, reduces z-fighting of distant objects and terrain
+reverse z = true
+
+[Cells]
+
+# Preload cells in a background thread. All settings starting with 'preload' have no effect unless this is enabled.
+preload enabled = true
+
+# The number of threads to be used for preloading operations.
+preload num threads = 1
+
+# Preload adjacent cells when moving close to an exterior cell border.
+preload exterior grid = true
+
+# Preload possible fast travel destinations.
+preload fast travel = false
+
+# Preload the locations that doors lead to.
+preload doors = true
+
+# Preloading distance threshold
+preload distance = 1000
+
+# Controls whether or not the nodes/collision shapes are pre-"instanced" (i.e. cloned) when a cell is preloaded.
+# Enabling this option slightly reduces the time it takes to transition into a preloaded cell, but also results in higher memory usage
+# proportional to the number of cells that are preloaded.
+preload instances = true
+
+# The minimum amount of cells in the preload cache before unused cells start to get thrown out (see "preload cell expiry delay").
+# This value should be lower or equal to 'preload cell cache max'.
+preload cell cache min = 12
+
+# The maximum amount of cells in the preload cache. A too high value could cause you to run out of memory.
+# You may need to reduce this setting when running lots of mods or high-res texture replacers.
+preload cell cache max = 20
+
+# How long to keep preloaded cells in cache after they're no longer referenced/required (in seconds)
+preload cell expiry delay = 5
+
+# The predicted position of the player N seconds in the future will be used for preloading cells and distant terrain
+prediction time = 1
+
+# How long to keep models/textures/collision shapes in cache after they're no longer referenced/required (in seconds)
+cache expiry delay = 5
+
+# Affects the time to be set aside each frame for graphics preloading operations
+target framerate = 60
+
+# The count of pointers, that will be saved for a faster search by object ID.
+pointers cache size = 40
+
+[Terrain]
+
+# If true, use paging and LOD algorithms to display the entire terrain. If false, only display terrain of the loaded cells
+distant terrain = false
+
+# Controls how the Quad Tree is split. This affects Vertex LOD, Texture LOD and load times. Values > 1 increase detail, values < 1 reduce detail.
+lod factor = 1.0
+
+# Controls only the Vertex LOD. Change in increments of 1, each change doubles (or halves) the number of vertices. Values > 0 increase detail, values < 0 reduce detail.
+vertex lod mod = 0
+
+# Controls when the distant terrain will flip to composited textures instead of high-detail textures, should be >= -3.
+# Higher value is more detailed textures.
+composite map level = 0
+
+# Controls the resolution of composite maps.
+composite map resolution = 512
+
+# Controls the maximum size of composite geometry, should be >= 1.0. With low values there will be many small chunks, with high values - lesser count of bigger chunks.
+max composite geometry size = 4.0
+
+# Draw lines arround chunks.
+debug chunks = false
+
+# Use object paging for non active cells
+object paging = true
+
+# Use object paging for active cells grid
+object paging active grid = true
+
+# Affects the likelyhood of more complex objects to get paged. Higher values improve visual fidelity at the cost of performance and RAM.
+object paging merge factor = 250
+
+# Cull objects smaller than this size divided by distance
+object paging min size = 0.01
+
+# Adjusts 'min size' based on merging decision. Allows inexpensive objects to be rendered from a greater distance.
+object paging min size merge factor = 0.3
+
+# Controls how inexpensive an object needs to be to utilize 'min size merge factor'.
+object paging min size cost multiplier = 25
+
+[Fog]
+
+# If true, use extended fog parameters for distant terrain not controlled by
+# viewing distance. If false, use the standard fog calculations.
+use distant fog = false
+
+distant land fog start = 16384
+
+distant land fog end = 40960
+
+distant underwater fog start = -4096
+
+distant underwater fog end = 2457.6
+
+distant interior fog start = 0
+
+distant interior fog end = 16384
+
+# Determine fog intensity based on the distance from the eye point.
+# This makes fogging independent from the viewing angle. Shaders will be used to render all objects.
+radial fog = false
+
+# Whether to use exponential formula for fog.
+exponential fog = false
+
+# Whether to hide the clipping plane by blending with sky.
+sky blending = false
+
+# Fraction of the maximum distance at which blending with the sky starts.
+sky blending start = 0.8
+
+# The sky RTT texture size, used only for sky blending. Smaller values
+# reduce quality of the sky blending, but can have slightly better performance.
+sky rtt resolution = 512 256
+
+[Map]
+
+# Size of each exterior cell in pixels in the world map. (e.g. 12 to 24).
+# Warning: affects explored areas in save files, see documentation.
+global map cell size = 18
+
+# Enables Fog of War rendering on the HUD map. Default is Off since with default settings
+# the map is so small that the fog would not obscure anything, just darken the edges slightly.
+local map hud fog of war = false
+
+# Resolution of local map in GUI window in pixels.  See documentation
+# for details which may affect cell load performance. (e.g. 128 to 1024).
+local map resolution = 256
+
+# Size of local map in GUI window in pixels.  (e.g. 256 to 1024).
+local map widget size = 512
+
+# If true, map in world mode, otherwise in local mode
+global = false
+
+# If true, allow zoom on local and global maps
+allow zooming = false
+
+# The local view distance in number of cells (up to the view distance)
+max local viewing distance = 10
+
+[GUI]
+
+# Scales GUI window and widget size. (<1.0 is smaller, >1.0 is larger).
+scaling factor = 1.0
+
+# Size of in-game fonts
+font size = 16
+
+# Transparency of GUI windows (0.0 to 1.0, transparent to opaque).
+menu transparency = 0.84
+
+# Time until tool tip appears when hovering over an object (0.0 is
+# instantly, 1.0 is the maximum delay of about 1.5 seconds).
+tooltip delay = 0.0
+
+# Stretch menus, load screens, etc. to the window aspect ratio.
+stretch menu background = false
+
+# Subtitles for NPC spoken dialog and some sound effects.
+subtitles = false
+
+# Red flash visually showing player damage.
+hit fader = true
+
+# Werewolf overlay border around screen or window.
+werewolf overlay = true
+
+# Color for tool tips and crosshair when owned by an NPC (R G B A).
+color background owned = 0.15 0.0 0.0 1.0
+color crosshair owned = 1.0 0.15 0.15 1.0
+
+# Controls whether Arrow keys, Movement keys, Tab/Shift-Tab and Spacebar/Enter/Activate may be used to navigate GUI buttons.
+keyboard navigation = true
+
+# Apply the defined color to dialogue topic.
+color topic enable = false
+
+# The color of dialogue topic keywords that gives unique actor responses
+# Format R G B A or empty for no special formatting
+# Default to blue
+color topic specific = 0.45 0.5 0.8 1
+
+# The color of dialogue topic keywords that gives already read responses
+# Format R G B A or empty for no special formatting
+# Default to grey
+color topic exhausted = 0.3 0.3 0.3 1
+
+[HUD]
+
+# Displays the crosshair or reticle when not in GUI mode.
+crosshair = true
+
+[Game]
+
+# Color crosshair and tool tip when object is owned by an NPC. (O is
+# no color, 1 is tool tip only, 2 is crosshair only, and 3 is both).
+show owned = 0
+
+# Show damage bonus of arrow and bolts.
+show projectile damage = false
+
+# Show additional weapon info: reach and attack speed
+show melee info = false
+
+# Show success probability in self-enchant dialog
+show enchant chance = false
+
+# Always use the best mode of attack: e.g. chop, slash or thrust.
+best attack = false
+
+# Difficulty.  Expressed as damage dealt and received. (e.g. -100 to 100).
+difficulty = 0
+
+# The maximum range of actor AI, animations and physics updates.
+actors processing range = 7168
+
+# Make reflected Absorb spells have no practical effect, like in Morrowind.
+classic reflected absorb spells behavior = true
+
+# Make Calm spells stop combat on every frame
+classic calm spells behavior = true
+
+# Show duration of magic effect and lights in the spells window.
+show effect duration = false
+
+# Prevent merchants from equipping items that are sold to them.
+prevent merchant equipping = false
+
+# Make enchanted weaponry without Magical flag bypass normal weapons resistance
+enchanted weapons are magical = true
+
+# Make player followers and escorters start combat with enemies who have started combat with them
+# or the player. Otherwise they wait for the enemies or the player to do an attack first.
+followers attack on sight = false
+
+# Can loot non-fighting actors during death animation
+can loot during death animation = true
+
+# Make the value of filled soul gems dependent only on soul magnitude (with formula from the Morrowind Code Patch)
+rebalance soul gem values = false
+
+# Allow to load per-group KF-files from Animations folder
+use additional anim sources = false
+
+# Make the disposition change of merchants caused by barter dealings permanent
+barter disposition change is permanent = false
+
+# Uses the MCP formula (damage * (strength / 40)) to factor Strength into hand-to-hand combat.
+# (0 means it does not factor it in, 1 means it factors into werewolves damage calculation and
+# 2 means werewolves are ignored)
+strength influences hand to hand = 0
+
+# Render holstered weapons (with quivers and scabbards), requires modded assets
+weapon sheathing = false
+
+# Render holstered shield when it is not in actor's hands, requires modded assets
+shield sheathing = false
+
+# Allow non-standard ammunition solely to bypass normal weapon resistance or weakness
+only appropriate ammunition bypasses resistance = false
+
+# Use casting animations for magic items, just as for spells
+use magic item animations = false
+
+# Don't use race weight in NPC movement speed calculations
+normalise race speed = false
+
+# Adjusts the number of projectiles you can enchant at once:
+# count = (soul gem charge * projectiles enchant multiplier) / enchantment strength
+# A value of 0 means that you can only enchant one projectile.
+projectiles enchant multiplier = 0
+
+# Make Damage Fatigue magic effect uncapped like Drain Fatigue effect.
+# This means that unlike Morrowind you will be able to knock down actors using this effect.
+uncapped damage fatigue = false
+
+# Turn lower body to movement direction. 'true' makes diagonal movement more realistic.
+turn to movement direction = false
+
+# Makes all movements of NPCs and player more smooth.
+smooth movement = false
+
+# Max delay of turning (in seconds) if player drastically changes direction on the run.
+smooth movement player turning delay = 0.333
+
+# All actors avoid collisions with other actors.
+NPCs avoid collisions = false
+
+# Give way to moving actors when idle. Requires 'NPCs avoid collisions' to be enabled.
+NPCs give way = true
+
+# Makes player swim a bit upward from the line of sight.
+swim upward correction = false
+
+# Strength of the 'swim upward correction' effect (if enabled).
+swim upward coef = 0.2
+
+# Make the training skills proposed by a trainer based on its base attribute instead of its modified ones
+trainers training skills based on base skill = false
+
+# Make stealing items from NPCs that were knocked down possible during combat.
+always allow stealing from knocked out actors = false
+
+# Enables visually harvesting plants for models that support it.
+graphic herbalism = true
+
+# Give actors an ability to swim over water surface when they follow other actor independently from their ability to swim
+# (true, false)
+allow actors to follow over water surface = true
+
+# Default size of actor for navmesh generation
+default actor pathfind half extents = 29.27999496459961 28.479997634887695 66.5
+
+# Enables use of day/night switch nodes
+day night switches = true
+
+# Enables degradation of NPC's armor from unarmed creature attacks.
+unarmed creature attacks damage armor = false
+
+# Collision is used for both physics simulation and navigation mesh generation for pathfinding:
+# 0 = Axis-aligned bounding box
+# 1 = Rotating box
+# 2 = Cylinder
+actor collision shape type = 0
+
+# When false the player character will base movement on animations. This will sway the camera 
+# while moving in third person like in vanilla, and reproduce movement bugs caused by glitchy 
+# vanilla animations.
+player movement ignores animation = false
+
+[General]
+
+# Anisotropy reduces distortion in textures at low angles (e.g. 0 to 16).
+anisotropy = 4
+
+# File format for screenshots.  (jpg, png, tga, and possibly more).
+screenshot format = png
+
+# Texture magnification filter type.  (nearest or linear).
+texture mag filter = linear
+
+# Texture minification filter type.  (nearest or linear).
+texture min filter = linear
+
+# Texture mipmap type.  (none, nearest, or linear).
+texture mipmap = nearest
+
+# Show message box when screenshot is saved to a file.
+notify on saved screenshot = false
+
+# List of the preferred languages separated by comma.
+# For example "de,en" means German as the first prority and English as a fallback.
+preferred locales = en
+
+# If true then l10n/*/gmst.yaml has priority over other l10n files.
+gmst overrides l10n = true
+
+# Buffer size for the in-game log viewer (press F10 to toggle). Zero disables the log viewer.
+log buffer size = 65536
+
+# Number of console history objects to retrieve from previous session.
+console history buffer size = 4096
+
+[Shaders]
+
+# Force rendering with shaders. By default, only bump-mapped objects will use shaders.
+# Enabling this option may cause slightly different visuals if the "clamp lighting" option
+# is set to false. Otherwise, there should not be a visual difference.
+force shaders = false
+
+# Force the use of per pixel lighting. By default, only bump mapped objects use per-pixel lighting.
+# Has no effect if the 'force shaders' option is false.
+# Enabling per-pixel lighting can result in visual differences to the original MW engine as
+# certain lights in Morrowind rely on vertex lighting to look as intended.
+force per pixel lighting = false
+
+# Restrict the amount of lighting that an object can receive to a maximum of (1,1,1).
+# Only affects objects that render with shaders (see 'force shaders' option). Always affects terrain.
+# Setting this option to 'true' results in fixed-function compatible lighting, but the lighting
+# may appear 'dull' and there might be color shifts.
+# Setting this option to 'false' results in more realistic lighting.
+clamp lighting = true
+
+# If this option is enabled, normal maps are automatically recognized and used if they are named appropriately
+# (see 'normal map pattern', e.g. for a base texture foo.dds, the normal map texture would have to be named foo_n.dds).
+# If this option is disabled, normal maps are only used if they are explicitly listed within the mesh file (.nif or .osg file).
+# Affects objects.
+auto use object normal maps = false
+
+# If this option is enabled, specular maps are automatically recognized and used if they are named appropriately
+# (see 'specular map pattern', e.g. for a base texture foo.dds, the specular map texture would have to be named foo_spec.dds).
+# If this option is disabled, normal maps are only used if they are explicitly listed within the mesh file (.osg file, not supported in .nif files).
+# Affects objects.
+auto use object specular maps = false
+
+# See 'auto use object normal maps'. Affects terrain.
+auto use terrain normal maps = false
+
+# If a file with pattern 'terrain specular map pattern' exists, use that file as a 'diffuse specular' map. The texture
+# must contain the layer color in the RGB channel (as usual), and a specular multiplier in the alpha channel.
+auto use terrain specular maps = false
+
+# The filename pattern to probe for when detecting normal maps (see 'auto use object normal maps', 'auto use terrain normal maps')
+normal map pattern = _n
+
+# Alternative filename pattern to probe for when detecting normal maps. Files with this pattern are expected to include 'height' in the alpha channel.
+# This height is used for parallax effects. Works for both terrain and objects.
+normal height map pattern = _nh
+
+# The filename pattern to probe for when detecting object specular maps (see 'auto use object specular maps')
+specular map pattern = _spec
+
+# The filename pattern to probe for when detecting terrain specular maps (see 'auto use terrain specular maps')
+terrain specular map pattern = _diffusespec
+
+# Apply lighting to reflections on the environment-mapped objects like in Morrowind Code Patch.
+# Affected objects use shaders.
+apply lighting to environment maps = false
+
+# Internal handling of lights, ignored if 'force shaders' is off. "legacy"
+# provides fixed function pipeline emulation."shaders compatibility" (default)
+# uncaps the light limit, enables groundcover lighting, and uses a modified
+# attenuation formula to reduce popping and light seams. "shaders" comes with
+# all these benefits and is meant for larger light limits, but may not be
+# supported on older hardware and may be slower on weaker hardware when
+# 'force per pixel lighting' is enabled.
+lighting method = shaders compatibility
+
+# Sets the bounding sphere multiplier of light sources if 'lighting method' is
+# not 'legacy'. These are used to determine if an object should receive
+# lighting. Higher values will allow for smoother transitions of light sources,
+# but may carry a performance cost and requires a higher number of 'max lights'
+# set.
+light bounds multiplier = 1.65
+
+# The distance from the camera at which lights fade away completely.
+# Set to 0 to disable fading.
+maximum light distance = 8192
+
+# Fraction of the maximum distance at which lights begin to gradually fade away.
+light fade start = 0.85
+
+# Set maximum number of lights per object.
+# When 'lighting method' is set to 'legacy', this setting will have no effect.
+max lights = 8
+
+# Sets minimum ambient brightness of interior cells. Levels below this threshold will have their
+# ambient values adjusted to balance the darker interiors.
+# When 'lighting method' is set to 'legacy', this setting will have no effect.
+minimum interior brightness = 0.08
+
+# Convert the alpha test (cutout/punchthrough alpha) to alpha-to-coverage.
+# This allows MSAA to work with alpha-tested meshes, producing better-looking edges without pixelation.
+# When MSAA is off, this setting will have no visible effect, but might have a performance cost.
+antialias alpha test = false
+
+# Attempt to simulate coverage-preserving mipmaps in textures created without them which are used for alpha testing anyway.
+# This will somewhat mitigate these objects appearing to shrink as they get further from the camera, but isn't perfect.
+# Better results can be achieved by generating more appropriate mipmaps in the first place, but if this workaround is used with such textures, affected objects will appear to grow as they get further from the camera.
+# It is recommended that mod authors specify how this setting should be set, and mod users follow their advice.
+adjust coverage for alpha test = true
+
+# Soften intersection of blended particle systems with opaque geometry
+soft particles = false
+
+# Rain and snow particle occlusion
+weather particle occlusion = false
+
+weather particle occlusion small feature culling pixel size = 4.0
+
+[Input]
+
+# Capture control of the cursor prevent movement outside the window.
+grab cursor = true
+
+# Camera sensitivity when not in GUI mode. (>0.0, e.g. 0.1 to 5.0).
+camera sensitivity = 1.0
+
+# Vertical camera sensitivity multiplier when not in GUI mode.
+# (>0.0, Because it's a multiplier values should be near 1.0)
+camera y multiplier = 1.0
+
+# Invert the horizontal axis while not in GUI mode.
+invert x axis = false
+
+# Invert the vertical axis while not in GUI mode.
+invert y axis = false
+
+# Enable controller support.
+enable controller = true
+
+# Emulated gamepad cursor sensitivity.
+gamepad cursor speed = 1.0
+
+# Set dead zone for joysticks (gamepad or on-screen ones)
+joystick dead zone = 0.1
+
+# Enable gyroscope support.
+enable gyroscope = false
+
+# Gyroscope axis that corresponds to horizontal camera axis.
+gyro horizontal axis = -x
+
+# Gyroscope axis that corresponds to vertical camera axis.
+gyro vertical axis = y
+
+# The minimum gyroscope movement that is able to rotate the camera.
+gyro input threshold = 0
+
+# Horizontal camera axis sensitivity to gyroscope movement.
+gyro horizontal sensitivity = 1.0
+
+# Vertical camera axis sensitivity to gyroscope movement.
+gyro vertical sensitivity = 1.0
+
+[Saves]
+
+# Name of last character played, and default for loading save files.
+character =
+
+# Automatically save the game whenever the player rests.
+autosave = true
+
+# Display the time played on each save file in the load menu.
+timeplayed = false
+
+# The maximum number of quick (or auto) save slots to have.
+# If all slots are used, the  oldest save is reused
+max quicksaves = 1
+
+[Sound]
+
+# Name of audio device file.  Blank means use the default device.
+device =
+
+# Volumes are 0.0 for silent and 1.0 for the maximum volume.
+
+# Master volume.  Controls all other volumes.
+master volume = 1.0
+
+# Footsteps volume.
+footsteps volume = 0.2
+
+# Music tracks volume.
+music volume = 0.5
+
+# Sound effects volume.
+sfx volume = 1.0
+
+# Voice dialog volume.
+voice volume = 0.8
+
+# Minimum size to use for the sound buffer cache, in MB. When the cache is
+# filled, old buffers will be unloaded until it's using no more than this much
+# memory. Must be less than or equal to 'buffer cache max'.
+buffer cache min = 56
+
+# Maximum size to use for the sound buffer cache, in MB. The cache can use up
+# to this much memory until old buffers get purged.
+buffer cache max = 64
+
+# Specifies whether to enable HRTF processing. Valid values are: -1 = auto,
+# 0 = off, 1 = on.
+hrtf enable = -1
+
+# Specifies which HRTF to use when HRTF is used. Blank means use the default.
+hrtf =
+
+# Specifies whether to use camera as audio listener
+camera listener = false
+
+[Video]
+
+# Resolution of the OpenMW window or screen.
+resolution x = 800
+resolution y = 600
+
+# Specify the window mode.
+# 0 = Fullscreen, 1 = Windowed Fullscreen, 2 = Windowed
+window mode = 2
+
+# Determines which screen OpenMW is on.  (>=0).
+screen = 0
+
+# Minimize OpenMW if it loses cursor or keyboard focus.
+minimize on focus loss = true
+
+# An operating system border is drawn around the OpenMW window.
+window border = true
+
+# Anti-aliasing reduces jagged polygon edges.  (>=0).
+antialiasing = 0
+
+# Vertical syncing to reduce tearing defects.
+# 0 = Off
+# 1 = On
+# 2 = Adaptive
+vsync mode = 0
+
+# Maximum frames per second. 0.0 is unlimited, or >0.0 to limit.
+framerate limit = 300
+
+# Game video contrast.  (>0.0).  No effect in Linux.
+contrast = 1.0
+
+# Video gamma setting.  (>0.0).  No effect in Linux.
+gamma = 1.0
+
+# Type of screenshot to take (regular, cylindrical, spherical, planet or cubemap), optionally followed by
+# screenshot width, height and cubemap resolution in pixels. (e.g. spherical 1600 1000 1200)
+screenshot type = regular
+
+[Water]
+
+# Enable water shader with reflections and optionally refraction.
+shader = false
+
+# Reflection and refraction texture size in pixels. (512, 1024, 2048).
+rtt size = 512
+
+# Enable refraction which affects visibility through water plane.
+refraction = false
+
+# Draw objects on water reflections.
+reflection detail = 2
+
+# Whether to use fully detailed raindrop ripples. (0, 1, 2).
+# 0 = rings only; 1 = sparse, high detail; 2 = dense, high detail
+rain ripple detail = 1
+
+# Overrides the value in '[Camera] small feature culling pixel size' specifically for water reflection/refraction textures.
+small feature culling pixel size = 20.0
+
+# By what factor water downscales objects. Only works with water shader and refractions on.
+refraction scale = 1.0
+
+[Windows]
+
+# Location and sizes of windows as a fraction of the OpenMW window or
+# screen size. (0.0 to 1.0).  X & Y, Width & Height.
+
+# Stats window displaying level, race, class, skills and stats.
+stats x = 0.015
+stats y = 0.015
+stats w = 0.4275
+stats h = 0.45
+stats maximized x = 0.255
+stats maximized y = 0.275
+stats maximized w = 0.4275
+stats maximized h = 0.45
+stats pin = false
+stats hidden = false
+stats maximized = false
+
+# Spells window displaying powers, spells, and magical items.
+spells x = 0.63
+spells y = 0.39
+spells w = 0.36
+spells h = 0.51
+spells maximized x = 0.32
+spells maximized y = 0.02
+spells maximized w = 0.36
+spells maximized h = 0.88
+spells pin = false
+spells hidden = false
+spells maximized = false
+
+# Local and world map window.
+map x = 0.63
+map y = 0.015
+map w = 0.36
+map h = 0.37
+map maximized x = 0.015
+map maximized y = 0.02
+map maximized w = 0.97
+map maximized h = 0.875
+map pin = false
+map hidden = false
+map maximized = false
+
+# Player inventory window when explicitly opened.
+inventory x = 0.015
+inventory y = 0.54
+inventory w = 0.45
+inventory h = 0.38
+inventory maximized x = 0.015
+inventory maximized y = 0.02
+inventory maximized w = 0.97
+inventory maximized h = 0.875
+inventory pin = false
+inventory hidden = false
+inventory maximized = false
+
+# Player inventory window when searching a container.
+inventory container x = 0.015
+inventory container y = 0.54
+inventory container w = 0.45
+inventory container h = 0.38
+inventory container maximized x = 0.015
+inventory container maximized y = 0.02
+inventory container maximized w = 0.97
+inventory container maximized h = 0.875
+inventory container maximized = false
+
+# Player inventory window when bartering with a shopkeeper.
+inventory barter x = 0.015
+inventory barter y = 0.54
+inventory barter w = 0.45
+inventory barter h = 0.38
+inventory barter maximized x = 0.015
+inventory barter maximized y = 0.02
+inventory barter maximized w = 0.97
+inventory barter maximized h = 0.875
+inventory barter maximized = false
+
+# Player inventory window when trading with a companion.
+inventory companion x = 0.015
+inventory companion y = 0.54
+inventory companion w = 0.45
+inventory companion h = 0.38
+inventory companion maximized x = 0.015
+inventory companion maximized y = 0.02
+inventory companion maximized w = 0.97
+inventory companion maximized h = 0.875
+inventory companion maximized = false
+
+# Dialog window for talking with NPCs.
+dialogue x = 0.15
+dialogue y = 0.5
+dialogue w = 0.7
+dialogue h = 0.45
+dialogue maximized x = 0.015
+dialogue maximized y = 0.02
+dialogue maximized w = 0.97
+dialogue maximized h = 0.875
+dialogue maximized = false
+
+# Alchemy window for crafting potions.
+alchemy x = 0.25
+alchemy y = 0.25
+alchemy w = 0.5
+alchemy h = 0.5
+alchemy maximized x = 0.015
+alchemy maximized y = 0.02
+alchemy maximized w = 0.97
+alchemy maximized h = 0.875
+alchemy maximized = false
+
+# Console command window for debugging commands.
+console x = 0.255
+console y = 0.215
+console w = 0.49
+console h = 0.3125
+console maximized x = 0.015
+console maximized y = 0.02
+console maximized w = 0.97
+console maximized h = 0.875
+console maximized = false
+
+# Container inventory when searching a container.
+container x = 0.49
+container y = 0.54
+container w = 0.39
+container h = 0.38
+container maximized x = 0.015
+container maximized y = 0.02
+container maximized w = 0.97
+container maximized h = 0.875
+container maximized = false
+
+# NPC inventory window when bartering with a shopkeeper.
+barter x = 0.6
+barter y = 0.27
+barter w = 0.38
+barter h = 0.63
+barter maximized x = 0.015
+barter maximized y = 0.02
+barter maximized w = 0.97
+barter maximized h = 0.875
+barter maximized = false
+
+# NPC inventory window when trading with a companion.
+companion x = 0.6
+companion y = 0.27
+companion w = 0.38
+companion h = 0.63
+companion maximized x = 0.015
+companion maximized y = 0.02
+companion maximized w = 0.97
+companion maximized h = 0.875
+companion maximized = false
+
+# Settings menu
+settings x = 0.1
+settings y = 0.1
+settings w = 0.8
+settings h = 0.8
+settings maximized x = 0.015
+settings maximized y = 0.02
+settings maximized w = 0.97
+settings maximized h = 0.875
+settings maximized = false
+
+# Postprocessor configuration window for controlling shaders.
+postprocessor h = 0.95
+postprocessor w = 0.44
+postprocessor x = 0.01
+postprocessor y = 0.02
+postprocessor maximized x = 0.015
+postprocessor maximized y = 0.02
+postprocessor maximized w = 0.97
+postprocessor maximized h = 0.875
+postprocessor maximized = false
+
+# Debug window for viewing logs and profiling
+debug x = 0.70
+debug y = 0.00
+debug w = 0.30
+debug h = 1.00
+debug maximized x = 0.015
+debug maximized y = 0.02
+debug maximized w = 0.97
+debug maximized h = 0.875
+debug maximized = false
+
+[Navigator]
+
+# Enable navigator (true, false). When enabled background threads are started to build navmesh for world geometry.
+# Pathfinding system uses navmesh to build paths. When disabled only pathgrid is used to build paths.
+enable = true
+
+# Scale of NavMesh coordinates to world coordinates (value > 0.0). Recastnavigation builds voxels for world geometry.
+# Basically voxel size is 1 / "cell size". To reduce amount of voxels we apply scale factor, to make voxel size
+# "recast scale factor" / "cell size". Default value calculates by this equation:
+# sStepSizeUp * "recast scale factor" / "cell size" = 5 (max climb height should be equal to 4 voxels)
+recast scale factor = 0.029411764705882353
+
+# The z-axis cell size to use for fields. (value > 0.0)
+# Defines voxel/grid/cell size. So their values have significant
+# side effects on all parameters defined in voxel units.
+# The minimum value for this parameter depends on the platform's floating point
+# accuracy, with the practical minimum usually around 0.05.
+# Same default value is used in RecastDemo.
+cell height = 0.2
+
+# The xy-plane cell size to use for fields. (value > 0.0)
+# Defines voxel/grid/cell size. So their values have significant
+# side effects on all parameters defined in voxel units.
+# The minimum value for this parameter depends on the platform's floating point
+# accuracy, with the practical minimum usually around 0.05.
+# Same default value is used in RecastDemo.
+cell size = 0.2
+
+# Sets the sampling distance to use when generating the detail mesh. (value = 0.0 or value >= 0.9)
+detail sample dist = 6.0
+
+# The maximum distance the detail mesh surface should deviate from heightfield data. (value >= 0.0)
+detail sample max error = 1.0
+
+# The maximum distance a simplfied contour's border edges should deviate the original raw contour. (value >= 0.0)
+max simplification error = 1.3
+
+# The width and height of each tile. (value > 0)
+tile size = 128
+
+# The size of the non-navigable border around the heightfield. (value >= 0)
+border size = 16
+
+# The maximum allowed length for contour edges along the border of the mesh. (value >= 0)
+max edge len = 12
+
+# Maximum number of search nodes. (0 < value <= 65535)
+max nav mesh query nodes = 2048
+
+# Maximum number of polygons per navmesh tile (value = 2^n, 0 < n < 22). Maximum number of navmesh tiles depends on
+# this value. 22 bits is a limit to store both tile identifier and polygon identifier (tiles = 2^(22 - log2(polygons))).
+# See recastnavigation for more details.
+max polygons per tile = 4096
+
+# The maximum number of vertices allowed for polygons generated during the contour to polygon conversion process. (value >= 3)
+max verts per poly = 6
+
+# Any regions with a span count smaller than this value will, if possible, be merged with larger regions. (value >= 0)
+region merge area = 400
+
+# The minimum number of cells allowed to form isolated island areas. (value >= 0)
+region min area = 64
+
+# Number of background threads to update nav mesh (value >= 1)
+async nav mesh updater threads = 1
+
+# Maximum total cached size of all nav mesh tiles in bytes (value >= 0)
+max nav mesh tiles cache size = 268435456
+
+# Maximum size of path over polygons (value > 0)
+max polygon path size = 1024
+
+# Maximum size of smoothed path (value > 0)
+max smooth path size = 1024
+
+# Write recast mesh to file in .obj format for each use to update nav mesh (true, false)
+enable write recast mesh to file = false
+
+# Write NavMesh to file to be able to open by RecastDemo (true, false)
+enable write nav mesh to file = false
+
+# Write each recast mesh file with revision in name. Otherwise will rewrite same file. (true, false)
+enable recast mesh file name revision = false
+
+# Write each nav mesh file with revision in name. Otherwise will rewrite same file. (true, false)
+enable nav mesh file name revision = false
+
+# Write recast mesh file at path with this prefix
+recast mesh path prefix =
+
+# Write nav mesh file at path with this prefix
+nav mesh path prefix =
+
+# Render nav mesh (true, false)
+enable nav mesh render = false
+
+# Navigation mesh rendering mode (default, update frequency)
+nav mesh render mode = area type
+
+# Render agents paths (true, false)
+enable agents paths render = false
+
+# Render recast mesh (true, false)
+enable recast mesh render = false
+
+# Max number of navmesh tiles (value >= 0)
+max tiles number = 512
+
+# Min time duration for the same tile update in milliseconds (value >= 0)
+min update interval ms = 250
+
+# Keep loading screen until navmesh is generated around the player for all tiles within manhattan distance (value >= 0).
+# Distance is measured in the number of tiles and can be only an integer value.
+wait until min distance to player = 5
+
+# Use navigation mesh cache stored on disk (true, false)
+enable nav mesh disk cache = true
+
+# Cache navigation mesh tiles to disk (true, false)
+write to navmeshdb = true
+
+# Approximate maximum file size of navigation mesh cache stored on disk in bytes (value > 0)
+max navmeshdb file size = 2147483648
+
+[Shadows]
+
+# Enable or disable shadows. Bear in mind that this will force OpenMW to use shaders as if "[Shaders]/force shaders" was set to true.
+enable shadows = false
+
+# How many shadow maps to use - more of these means each shadow map texel covers less area, producing better looking shadows, but may decrease performance.
+number of shadow maps = 3
+
+# The distance from the camera at which shadows fade away completely. Set to 0 to make the distance infinite.
+maximum shadow map distance = 8192
+
+# Fraction of the maximum distance at which shadows begin to gradually fade away.
+shadow fade start = 0.9
+
+# If true, allow shadow maps to overlap. Counter-intuitively, will produce better results when the light is behind the camera. When enabled, OpenMW uses Cascaded Shadow Maps and when disabled, it uses Parallel Split Shadow Maps.
+allow shadow map overlap = true
+
+# Indirectly controls where to split the shadow map(s). Values closer to 1.0 bring more detail closer to the camera (potentially excessively so), and values closer to 0.0 spread it more evenly across the whole viewing distance. 0.5 is recommended for most viewing distances by the original Parallel Split Shadow Maps paper, but this does not take into account use of a Light Space Perspective transformation, so other values may be preferable. If some of the terms used here go over your head, you might not want to change this, especially not without reading the associated papers first. When "allow shadow map overlap" is combined with a higher-than-default viewing distance, values closer to 1.0 will prevent nearby shadows losing a lot of quality.
+split point uniform logarithmic ratio = 0.5
+
+# Indirectly controls where to split the shadow map(s). Positive values move split points away from the camera and negative values move them towards the camera. Intended to be used in conjunction with changes to 'split point uniform logarithmic ratio' to counteract side effects, but may cause additional, more serious side effects. Read the Parallel Split Shadow Maps paper by F Zhang et al before changing.
+split point bias = 0.0
+
+# Enable the debug hud to see what the shadow map(s) contain.
+enable debug hud = false
+
+# Enable the debug overlay to see where each shadow map affects.
+enable debug overlay = false
+
+# Used to set the type of tight scene bound calculation method to be used by the shadow map that covers a smaller area. "bounds" (default) is less precise shadows but better performance or "primitives" for more precise shadows at expense of CPU.
+compute scene bounds = bounds
+
+# How large to make the shadow map(s). Higher values increase GPU load, but can produce better-looking results. Power-of-two values may turn out to be faster on some GPU/driver combinations.
+shadow map resolution = 1024
+
+# Controls the minimum near/far ratio for the Light Space Perspective Shadow Map transformation. Helps prevent too much detail being brought towards the camera at the expense of detail further from the camera. Increasing this pushes detail further away.
+minimum lispsm near far ratio = 0.25
+
+# Used as the factor parameter for the polygon offset used for shadow map rendering. Higher values reduce shadow flicker, but risk increasing Peter Panning. See https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPolygonOffset.xhtml for details.
+polygon offset factor = 1.1
+
+# Used as the units parameter for the polygon offset used for shadow map rendering. Higher values reduce shadow flicker, but risk increasing Peter Panning. See https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glPolygonOffset.xhtml for details.
+polygon offset units = 4.0
+
+# How far along the surface normal to project shadow coordinates. Higher values significantly reduce shadow flicker, usually with a lower increase of Peter Panning than the Polygon Offset settings. This value is in in-game units, so 1.0 is roughly 1.4 cm.
+normal offset distance = 1.0
+
+# Excludes theoretically unnecessary faces from shadow maps, slightly increasing performance. In practice, Peter Panning can be much less visible with these faces included, so if you have high polygon offset values, leave this off to minimise the side effects.
+use front face culling = false
+
+# Allow actors to cast shadows. Potentially decreases performance.
+actor shadows = false
+
+# Allow the player to cast shadows. Potentially decreases performance.
+player shadows = false
+
+# Allow terrain to cast shadows. Potentially decreases performance.
+terrain shadows = false
+
+# Allow world objects to cast shadows. Potentially decreases performance.
+object shadows = false
+
+# Allow shadows indoors. Due to limitations with Morrowind's data, only actors can cast shadows indoors, which some might feel is distracting.
+enable indoor shadows = true
+
+[Physics]
+# Set the number of background threads used for physics.
+# If no background threads are used, physics calculations are processed in the main thread
+# and the settings below have no effect.
+async num threads = 1
+
+# Set the number of frames an inactive line-of-sight request will be kept
+# refreshed in the background physics thread cache.
+lineofsight keep inactive cache = 0
+
+[Models]
+
+# Attempt to load any valid NIF file regardless of its version and track the progress.
+# Loading arbitrary meshes is not advised and may cause instability.
+load unsupported nif files = false
+
+# 3rd person base animation model that looks also for the corresponding kf-file
+xbaseanim = meshes/xbase_anim.nif
+
+# 3rd person base model with textkeys-data
+baseanim = meshes/base_anim.nif
+
+# 1st person base animation model that looks also for corresponding kf-file
+xbaseanim1st = meshes/xbase_anim.1st.nif
+
+# 3rd person beast race base model with textkeys-data
+baseanimkna = meshes/base_animkna.nif
+
+# 1st person beast race base animation model
+baseanimkna1st = meshes/base_animkna.1st.nif
+
+# 3rd person female base animation model
+xbaseanimfemale = meshes/xbase_anim_female.nif
+
+# 3rd person female base model with textkeys-data
+baseanimfemale = meshes/base_anim_female.nif
+
+# 1st person female base model with textkeys-data
+baseanimfemale1st = meshes/base_anim_female.1st.nif
+
+# 3rd person werewolf skin
+wolfskin = meshes/wolf/skin.nif
+
+# 1st person werewolf skin
+wolfskin1st = meshes/wolf/skin.1st.nif
+
+# Argonian smimkna
+xargonianswimkna = meshes/xargonian_swimkna.nif
+
+# File to load xbaseanim 3rd person animations
+xbaseanimkf = meshes/xbase_anim.kf
+
+# File to load xbaseanim 3rd person animations
+xbaseanim1stkf = meshes/xbase_anim.1st.kf
+
+# File to load xbaseanim animations from
+xbaseanimfemalekf = meshes/xbase_anim_female.kf
+
+# File to load xargonianswimkna animations from
+xargonianswimknakf = meshes/xargonian_swimkna.kf
+
+# Sky atmosphere mesh
+skyatmosphere = meshes/sky_atmosphere.nif
+
+# Sky clouds mesh 
+skyclouds = meshes/sky_clouds_01.nif
+
+# Sky stars mesh 01
+skynight01 = meshes/sky_night_01.nif
+
+# Sky stars mesh 02
+skynight02 = meshes/sky_night_02.nif
+
+# Ash clouds weather effect
+weatherashcloud = meshes/ashcloud.nif
+
+# Blight clouds weather effect
+weatherblightcloud = meshes/blightcloud.nif
+
+# Snow falling weather effect
+weathersnow = meshes/snow.nif
+
+# Blizzard weather effect
+weatherblizzard = meshes/blizzard.nif
+
+# Enable to write logs when loading NIF files
+write nif debug log = false
+
+[Groundcover]
+
+# enable separate groundcover handling
+enabled = false
+
+# A groundcover density (0.0 <= value <= 1.0)
+# 1.0 means 100% density
+density = 1.0
+
+# A maximum distance in game units on which groundcover is rendered.
+rendering distance = 6144.0
+
+# Whether grass should respond to the player treading on it.
+# 0 - Grass cannot be trampled.
+# 1 - The player's XY position is taken into account.
+# 2 - The player's height above the ground is taken into account, too.
+stomp mode = 2
+
+# How far away from the player grass can be before it's unaffected by being trod on, and how far it moves when it is.
+# 2 - MGE XE levels. Generally excessive, but what existing mods were made with in mind
+# 1 - Reduced levels.
+# 0 - Gentle levels.
+stomp intensity = 1
+
+[Lua]
+
+# Enable performance-heavy debug features
+lua debug = false
+
+# Set the maximum number of threads used for Lua scripts.
+# If zero, Lua scripts are processed in the main thread.
+lua num threads = 1
+
+# Enable Lua profiler
+lua profiler = true
+
+# No ownership tracking for allocations below or equal this size.
+small alloc max size = 1024
+
+# Memory limit for Lua runtime (only if lua profiler = true). If exceeded then only small allocations are allowed.
+# Small allocations are always allowed, so e.g. Lua console can function. Default value is 2GB.
+memory limit = 2147483648
+
+# Print debug info about memory usage (only if lua profiler = true).
+log memory usage = false
+
+# The maximal number of Lua instructions per function call (only if lua profiler = true).
+# If exceeded (e.g. because of an infinite loop) the function will be terminated.
+instruction limit per call = 100000000
+
+# Lua garbage collector steps per frame.
+gc steps per frame = 100
+
+[Stereo]
+# Enable/disable stereo view. This setting is ignored in VR.
+stereo enabled = false
+
+# If enabled, OpenMW will use the GL_OVR_MultiView and GL_OVR_MultiView2 extensions where possible.
+multiview = false
+
+# May accelerate the BruteForce method when shadows are enabled
+shared shadow maps = true
+
+# If false, OpenMW-VR will disable display lists when using multiview. Necessary on some buggy drivers, but may incur a slight performance penalty.
+allow display lists for multiview = false
+
+# If false, the default OSG horizontal split will be used for stereo
+# If true, the config defined in the [Stereo View] settings category will be used
+# Note: This option is ignored in VR, and exists primarily for debugging purposes
+use custom view = false
+
+# If true, overrides rendering resolution for each eye.
+# Note: This option is ignored in VR, and exists primarily for debugging purposes
+use custom eye resolution = false
+
+[Stereo View]
+# The default values are based on an HP Reverb G2 HMD
+eye resolution x = 3128
+eye resolution y = 3060
+
+# Left eye offset from center, expressed in MW units (1 meter = ~70)
+left eye offset x = -2.35
+left eye offset y = 0.0
+left eye offset z = 0.0
+# Left eye orientation, expressed as a quaternion
+left eye orientation x = 0.0
+left eye orientation y = 0.0
+left eye orientation z = 0.0
+left eye orientation w = 1.0
+# Left eye field of view, expressed in radians
+left eye fov left = -0.86
+left eye fov right = 0.78
+left eye fov up = 0.8
+left eye fov down = -0.8
+
+# Left eye offset from center, expressed in MW units (1 meter = ~70)
+right eye offset x = 2.35
+right eye offset y = 0.0
+right eye offset z = 0.0
+# Left eye orientation, expressed as a quaternion
+right eye orientation x = 0.0
+right eye orientation y = 0.0
+right eye orientation z = 0.0
+right eye orientation w = 1.0
+# Left eye field of view
+right eye fov left = -0.78
+right eye fov right = 0.86
+right eye fov up = 0.8
+right eye fov down = -0.8
+
+[Post Processing]
+
+# Enables post-processing 
+enabled = false
+
+# List of active shaders. This is more easily with the in-game shader HUD, by default accessible with the F2 key.
+chain =
+
+# Used for eye adaptation to control speed at which scene luminance can change from one frame to the next. No effect when HDR is not being utilized.
+auto exposure speed = 0.9
+
+# Transparent depth postpass. Re-renders transparent objects with alpha-clipping forced with a fixed threshold.
+transparent postpass = true
diff --git a/files/shaders/CMakeLists.txt b/files/shaders/CMakeLists.txt
index ca0c264ade7..20f4263b9ff 100644
--- a/files/shaders/CMakeLists.txt
+++ b/files/shaders/CMakeLists.txt
@@ -9,6 +9,7 @@ set(DDIRRELATIVE resources/shaders)
 set(SHADER_FILES
     lib/water/fresnel.glsl
     lib/water/rain_ripples.glsl
+    lib/water/rain_ripples_old.glsl
     lib/water/ripples.glsl
     lib/view/depth.glsl
     lib/luminance/constants.glsl
diff --git a/files/shaders/compatibility/bs/default.frag b/files/shaders/compatibility/bs/default.frag
old mode 100644
new mode 100755
index 77131c6a52c..ec5f5c89780
--- a/files/shaders/compatibility/bs/default.frag
+++ b/files/shaders/compatibility/bs/default.frag
@@ -80,7 +80,7 @@ void main()
     vec3 viewNormal = normalToView(normalTex.xyz * 2.0 - 1.0);
     specularColor *= normalTex.a;
 #else
-    vec3 viewNormal = normalize(gl_NormalMatrix * passNormal);
+    vec3 viewNormal = normalToView(normalize(passNormal));
 #endif
 
     float shadowing = unshadowedLightRatio(linearDepth);
diff --git a/files/shaders/compatibility/bs/default.vert b/files/shaders/compatibility/bs/default.vert
old mode 100644
new mode 100755
index 21942ec91e8..d9d47843c09
--- a/files/shaders/compatibility/bs/default.vert
+++ b/files/shaders/compatibility/bs/default.vert
@@ -69,7 +69,7 @@ void main(void)
 
 
 #if @shadows_enabled
-    vec3 viewNormal = normalize(gl_NormalMatrix * passNormal);
+    vec3 viewNormal = normalToView(passNormal);
     setupShadowCoords(viewPos, viewNormal);
 #endif
 }
diff --git a/files/shaders/compatibility/bs/nolighting.frag b/files/shaders/compatibility/bs/nolighting.frag
old mode 100644
new mode 100755
diff --git a/files/shaders/compatibility/bs/nolighting.vert b/files/shaders/compatibility/bs/nolighting.vert
old mode 100644
new mode 100755
index 57cedc6e948..3b0fa7b6261
--- a/files/shaders/compatibility/bs/nolighting.vert
+++ b/files/shaders/compatibility/bs/nolighting.vert
@@ -63,7 +63,7 @@ void main(void)
     }
 
 #if @shadows_enabled
-    vec3 viewNormal = normalize(gl_NormalMatrix * passNormal);
+    vec3 viewNormal = normalize((gl_NormalMatrix * gl_Normal).xyz);
     setupShadowCoords(viewPos, viewNormal);
 #endif
 }
diff --git a/files/shaders/compatibility/debug.frag b/files/shaders/compatibility/debug.frag
old mode 100644
new mode 100755
index a92b406d46b..041562fc0e2
--- a/files/shaders/compatibility/debug.frag
+++ b/files/shaders/compatibility/debug.frag
@@ -4,7 +4,7 @@
 
 varying vec3 vertexNormal;
 
-uniform bool useAdvancedShader = false;
+uniform bool useAdvancedShader;
 
 void main()
 {
diff --git a/files/shaders/compatibility/debug.vert b/files/shaders/compatibility/debug.vert
old mode 100644
new mode 100755
index 47d5337a66f..a1fa462f397
--- a/files/shaders/compatibility/debug.vert
+++ b/files/shaders/compatibility/debug.vert
@@ -6,7 +6,7 @@ uniform vec3 color;
 uniform vec3 trans;
 uniform vec3 scale;
 uniform bool useNormalAsColor;
-uniform bool useAdvancedShader = false;
+uniform bool useAdvancedShader;
 
 centroid varying vec4 passColor;
 varying vec3 vertexNormal;
diff --git a/files/shaders/compatibility/depthclipped.frag b/files/shaders/compatibility/depthclipped.frag
old mode 100644
new mode 100755
diff --git a/files/shaders/compatibility/depthclipped.vert b/files/shaders/compatibility/depthclipped.vert
old mode 100644
new mode 100755
diff --git a/files/shaders/compatibility/fog.glsl b/files/shaders/compatibility/fog.glsl
old mode 100644
new mode 100755
diff --git a/files/shaders/compatibility/fullscreen_tri.frag b/files/shaders/compatibility/fullscreen_tri.frag
old mode 100644
new mode 100755
diff --git a/files/shaders/compatibility/fullscreen_tri.vert b/files/shaders/compatibility/fullscreen_tri.vert
old mode 100644
new mode 100755
index 3174384212e..8510a0933c1
--- a/files/shaders/compatibility/fullscreen_tri.vert
+++ b/files/shaders/compatibility/fullscreen_tri.vert
@@ -1,6 +1,6 @@
 #version 120
 
-uniform vec2 scaling = vec2(1.0, 1.0);
+uniform vec2 scaling;// = vec2(1.0, 1.0);
 
 varying vec2 uv;
 
diff --git a/files/shaders/compatibility/groundcover.frag b/files/shaders/compatibility/groundcover.frag
old mode 100644
new mode 100755
diff --git a/files/shaders/compatibility/groundcover.vert b/files/shaders/compatibility/groundcover.vert
old mode 100644
new mode 100755
index 8cf53a19e05..95a17b50849
--- a/files/shaders/compatibility/groundcover.vert
+++ b/files/shaders/compatibility/groundcover.vert
@@ -156,7 +156,7 @@ void main(void)
 #endif
 
 #if (!PER_PIXEL_LIGHTING || @shadows_enabled)
-    vec3 viewNormal = normalize(gl_NormalMatrix * passNormal);
+    vec3 viewNormal = normalToView(passNormal);
 #endif
 
 #if @diffuseMap
diff --git a/files/shaders/compatibility/gui.frag b/files/shaders/compatibility/gui.frag
old mode 100644
new mode 100755
diff --git a/files/shaders/compatibility/gui.vert b/files/shaders/compatibility/gui.vert
old mode 100644
new mode 100755
diff --git a/files/shaders/compatibility/luminance/luminance.frag b/files/shaders/compatibility/luminance/luminance.frag
old mode 100644
new mode 100755
diff --git a/files/shaders/compatibility/luminance/resolve.frag b/files/shaders/compatibility/luminance/resolve.frag
old mode 100644
new mode 100755
diff --git a/files/shaders/compatibility/multiview_resolve.frag b/files/shaders/compatibility/multiview_resolve.frag
old mode 100644
new mode 100755
diff --git a/files/shaders/compatibility/multiview_resolve.vert b/files/shaders/compatibility/multiview_resolve.vert
old mode 100644
new mode 100755
diff --git a/files/shaders/compatibility/normals.glsl b/files/shaders/compatibility/normals.glsl
old mode 100644
new mode 100755
diff --git a/files/shaders/compatibility/objects.frag b/files/shaders/compatibility/objects.frag
old mode 100644
new mode 100755
index 56c7abf27c7..563929473cc
--- a/files/shaders/compatibility/objects.frag
+++ b/files/shaders/compatibility/objects.frag
@@ -84,11 +84,11 @@ varying vec3 passNormal;
 #if @normalMap || @diffuseParallax
 varying vec4 passTangent;
 #endif
-
+/*
 #if @additiveBlending
 #define ADDITIVE_BLENDING
 #endif
-
+*/
 #include "lib/light/lighting.glsl"
 #include "lib/material/parallax.glsl"
 #include "lib/material/alpha.glsl"
@@ -109,11 +109,11 @@ uniform float softFalloffDepth;
 
 #if @particleOcclusion
 #include "lib/particle/occlusion.glsl"
-uniform sampler2D orthoDepthMap;
+uniform highp sampler2D orthoDepthMap;
 varying vec3 orthoDepthMapCoord;
 #endif
 
-uniform sampler2D opaqueDepthTex;
+uniform highp sampler2D opaqueDepthTex;
 
 void main()
 {
diff --git a/files/shaders/compatibility/objects.vert b/files/shaders/compatibility/objects.vert
old mode 100644
new mode 100755
index 081ff909cf0..2bebcd60bf2
--- a/files/shaders/compatibility/objects.vert
+++ b/files/shaders/compatibility/objects.vert
@@ -101,7 +101,7 @@ void main(void)
 #endif
 
 #if @envMap || !PER_PIXEL_LIGHTING || @shadows_enabled
-    vec3 viewNormal = normalize(gl_NormalMatrix * passNormal);
+    vec3 viewNormal = normalToView(passNormal);
 #endif
 
 #if @envMap
diff --git a/files/shaders/compatibility/ripples_blobber.frag b/files/shaders/compatibility/ripples_blobber.frag
old mode 100644
new mode 100755
diff --git a/files/shaders/compatibility/ripples_simulate.frag b/files/shaders/compatibility/ripples_simulate.frag
old mode 100644
new mode 100755
diff --git a/files/shaders/compatibility/s360.frag b/files/shaders/compatibility/s360.frag
old mode 100644
new mode 100755
diff --git a/files/shaders/compatibility/s360.vert b/files/shaders/compatibility/s360.vert
old mode 100644
new mode 100755
diff --git a/files/shaders/compatibility/shadowcasting.frag b/files/shaders/compatibility/shadowcasting.frag
old mode 100644
new mode 100755
diff --git a/files/shaders/compatibility/shadowcasting.vert b/files/shaders/compatibility/shadowcasting.vert
old mode 100644
new mode 100755
diff --git a/files/shaders/compatibility/shadows_fragment.glsl b/files/shaders/compatibility/shadows_fragment.glsl
old mode 100644
new mode 100755
diff --git a/files/shaders/compatibility/shadows_vertex.glsl b/files/shaders/compatibility/shadows_vertex.glsl
old mode 100644
new mode 100755
diff --git a/files/shaders/compatibility/sky.frag b/files/shaders/compatibility/sky.frag
old mode 100644
new mode 100755
diff --git a/files/shaders/compatibility/sky.vert b/files/shaders/compatibility/sky.vert
old mode 100644
new mode 100755
diff --git a/files/shaders/compatibility/terrain.frag b/files/shaders/compatibility/terrain.frag
old mode 100644
new mode 100755
index abc7425eb05..38b985223e4
--- a/files/shaders/compatibility/terrain.frag
+++ b/files/shaders/compatibility/terrain.frag
@@ -65,7 +65,7 @@ void main()
 #if @normalMap
     vec3 viewNormal = normalToView(texture2D(normalMap, adjustedUV).xyz * 2.0 - 1.0);
 #else
-    vec3 viewNormal = normalize(gl_NormalMatrix * passNormal);
+    vec3 viewNormal = normalToView(normalize(passNormal));
 #endif
 
     float shadowing = unshadowedLightRatio(linearDepth);
diff --git a/files/shaders/compatibility/terrain.vert b/files/shaders/compatibility/terrain.vert
old mode 100644
new mode 100755
index cbfb7769ba5..3b2cb16db49
--- a/files/shaders/compatibility/terrain.vert
+++ b/files/shaders/compatibility/terrain.vert
@@ -52,7 +52,7 @@ void main(void)
 #endif
 
 #if !PER_PIXEL_LIGHTING || @shadows_enabled
-    vec3 viewNormal = normalize(gl_NormalMatrix * passNormal);
+    vec3 viewNormal = normalToView(passNormal);
 #endif
 
 #if !PER_PIXEL_LIGHTING
diff --git a/files/shaders/compatibility/vertexcolors.glsl b/files/shaders/compatibility/vertexcolors.glsl
old mode 100644
new mode 100755
diff --git a/files/shaders/compatibility/water.frag b/files/shaders/compatibility/water.frag
old mode 100644
new mode 100755
index c971f92b997..4b275575f34
--- a/files/shaders/compatibility/water.frag
+++ b/files/shaders/compatibility/water.frag
@@ -17,8 +17,6 @@
 // tweakables -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
 
 const float VISIBILITY = 2500.0;
-const float VISIBILITY_DEPTH = VISIBILITY * 1.5;
-const float DEPTH_FADE = 0.15;
 
 const float BIG_WAVES_X = 0.1; // strength of big waves
 const float BIG_WAVES_Y = 0.1;
@@ -50,7 +48,6 @@ const float SUN_SPEC_FADING_THRESHOLD = 0.15;       // visibility at which sun s
 const float SPEC_HARDNESS = 256.0;                 // specular highlights hardness
 
 const float BUMP_SUPPRESS_DEPTH = 300.0;           // at what water depth bumpmap will be suppressed for reflections and refractions (prevents artifacts at shores)
-const float REFR_FOG_DISTORT_DISTANCE = 3000.0;    // at what distance refraction fog will be calculated using real water depth instead of distorted depth (prevents splotchy shores)
 
 const vec2 WIND_DIR = vec2(0.5f, -0.8f);
 const float WIND_SPEED = 0.2f;
@@ -94,7 +91,11 @@ uniform vec2 screenRes;
 #include "lib/light/lighting.glsl"
 #include "fog.glsl"
 #include "lib/water/fresnel.glsl"
-#include "lib/water/rain_ripples.glsl"
+#if @shader_ripples
+    #include "lib/water/rain_ripples.glsl"
+#else
+    #include "lib/water/rain_ripples_old.glsl"
+#endif
 #include "lib/view/depth.glsl"
 
 void main(void)
@@ -124,11 +125,13 @@ void main(void)
 
     vec3 rippleAdd = rainRipple.xyz * 10.0;
 
+#if @shader_ripples
     float distToCenter = length(rippleMapUV - vec2(0.5));
     float blendClose = smoothstep(0.001, 0.02, distToCenter);
     float blendFar = 1.0 - smoothstep(0.3, 0.4, distToCenter);
     float distortionLevel = 2.0;
     rippleAdd += distortionLevel * vec3(texture2D(rippleMap, rippleMapUV).ba * blendFar * blendClose, 0.0);
+#endif
 
     vec2 bigWaves = vec2(BIG_WAVES_X,BIG_WAVES_Y);
     vec2 midWaves = mix(vec2(MID_WAVES_X,MID_WAVES_Y),vec2(MID_WAVES_RAIN_X,MID_WAVES_RAIN_Y),rainIntensity);
@@ -163,10 +166,9 @@ void main(void)
     vec2 screenCoordsOffset = normal.xy * REFL_BUMP;
 #if REFRACTION
     float depthSample = linearizeDepth(sampleRefractionDepthMap(screenCoords), near, far) * radialise;
+    float depthSampleDistorted = linearizeDepth(sampleRefractionDepthMap(screenCoords-screenCoordsOffset), near, far) * radialise;
     float surfaceDepth = linearizeDepth(gl_FragCoord.z, near, far) * radialise;
     float realWaterDepth = depthSample - surfaceDepth;  // undistorted water depth in view direction, independent of frustum
-    float depthSampleDistorted = linearizeDepth(sampleRefractionDepthMap(screenCoords - screenCoordsOffset), near, far) * radialise;
-    float waterDepthDistorted = max(depthSampleDistorted - surfaceDepth, 0.0);
     screenCoordsOffset *= clamp(realWaterDepth / BUMP_SUPPRESS_DEPTH,0,1);
 #endif
     // reflection
@@ -189,16 +191,6 @@ void main(void)
     // no alpha here, so make sure raindrop ripple specularity gets properly subdued
     rainSpecular *= clamp(fresnel*6.0 + specular * sunSpec.a, 0.0, 1.0);
 
-    // selectively nullify screenCoordsOffset to eliminate remaining shore artifacts, not needed for reflection
-    if (cameraPos.z > 0.0 && realWaterDepth <= VISIBILITY_DEPTH && waterDepthDistorted > VISIBILITY_DEPTH)
-        screenCoordsOffset = vec2(0.0);
-
-    depthSampleDistorted = linearizeDepth(sampleRefractionDepthMap(screenCoords - screenCoordsOffset), near, far) * radialise;
-    waterDepthDistorted = max(depthSampleDistorted - surfaceDepth, 0.0);
-
-    // fade to realWaterDepth at a distance to compensate for physically inaccurate depth calculation
-    waterDepthDistorted = mix(waterDepthDistorted, realWaterDepth, min(surfaceDepth / REFR_FOG_DISTORT_DISTANCE, 1.0));
-
     // refraction
     vec3 refraction = sampleRefractionMap(screenCoords - screenCoordsOffset).rgb;
     vec3 rawRefraction = refraction;
@@ -207,11 +199,7 @@ void main(void)
     if (cameraPos.z < 0.0)
         refraction = clamp(refraction * 1.5, 0.0, 1.0);
     else
-    {
-        float depthCorrection = sqrt(1.0 + 4.0 * DEPTH_FADE * DEPTH_FADE);
-        float factor = DEPTH_FADE * DEPTH_FADE / (-0.5 * depthCorrection + 0.5 - waterDepthDistorted / VISIBILITY) + 0.5 * depthCorrection + 0.5;
-        refraction = mix(refraction, waterColor, clamp(factor, 0.0, 1.0));
-    }
+        refraction = mix(refraction, waterColor, clamp(depthSampleDistorted/VISIBILITY, 0.0, 1.0));
 
     // sunlight scattering
     // normal for sunlight scattering
diff --git a/files/shaders/compatibility/water.frag.orig b/files/shaders/compatibility/water.frag.orig
new file mode 100755
index 00000000000..4ac640d37ee
--- /dev/null
+++ b/files/shaders/compatibility/water.frag.orig
@@ -0,0 +1,255 @@
+#version 120
+
+#if @useUBO
+    #extension GL_ARB_uniform_buffer_object : require
+#endif
+
+#if @useGPUShader4
+    #extension GL_EXT_gpu_shader4: require
+#endif
+
+#include "lib/core/fragment.h.glsl"
+
+#define REFRACTION @refraction_enabled
+
+// Inspired by Blender GLSL Water by martinsh ( https://devlog-martinsh.blogspot.de/2012/07/waterundewater-shader-wip.html )
+
+// tweakables -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
+
+const float VISIBILITY = 2500.0;
+const float VISIBILITY_DEPTH = VISIBILITY * 1.5;
+const float DEPTH_FADE = 0.15;
+
+const float BIG_WAVES_X = 0.1; // strength of big waves
+const float BIG_WAVES_Y = 0.1;
+
+const float MID_WAVES_X = 0.1; // strength of middle sized waves
+const float MID_WAVES_Y = 0.1;
+const float MID_WAVES_RAIN_X = 0.2;
+const float MID_WAVES_RAIN_Y = 0.2;
+
+const float SMALL_WAVES_X = 0.1; // strength of small waves
+const float SMALL_WAVES_Y = 0.1;
+const float SMALL_WAVES_RAIN_X = 0.3;
+const float SMALL_WAVES_RAIN_Y = 0.3;
+
+const float WAVE_CHOPPYNESS = 0.05;                // wave choppyness
+const float WAVE_SCALE = 75.0;                     // overall wave scale
+
+const float BUMP = 0.5;                            // overall water surface bumpiness
+const float BUMP_RAIN = 2.5;
+const float REFL_BUMP = 0.10;                      // reflection distortion amount
+const float REFR_BUMP = 0.07;                      // refraction distortion amount
+
+const float SCATTER_AMOUNT = 0.3;                  // amount of sunlight scattering
+const vec3 SCATTER_COLOUR = vec3(0.0,1.0,0.95);    // colour of sunlight scattering
+
+const vec3 SUN_EXT = vec3(0.45, 0.55, 0.68);       //sunlight extinction
+const float SUN_SPEC_FADING_THRESHOLD = 0.15;       // visibility at which sun specularity starts to fade
+
+const float SPEC_HARDNESS = 256.0;                 // specular highlights hardness
+
+const float BUMP_SUPPRESS_DEPTH = 300.0;           // at what water depth bumpmap will be suppressed for reflections and refractions (prevents artifacts at shores)
+const float REFR_FOG_DISTORT_DISTANCE = 3000.0;    // at what distance refraction fog will be calculated using real water depth instead of distorted depth (prevents splotchy shores)
+
+const vec2 WIND_DIR = vec2(0.5f, -0.8f);
+const float WIND_SPEED = 0.2f;
+
+const vec3 WATER_COLOR = vec3(0.090195, 0.115685, 0.12745);
+
+const float WOBBLY_SHORE_FADE_DISTANCE = 6200.0;   // fade out wobbly shores to mask precision errors, the effect is almost impossible to see at a distance
+
+// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
+
+vec2 normalCoords(vec2 uv, float scale, float speed, float time, float timer1, float timer2, vec3 previousNormal)
+{
+  return uv * (WAVE_SCALE * scale) + WIND_DIR * time * (WIND_SPEED * speed) -(previousNormal.xy/previousNormal.zz) * WAVE_CHOPPYNESS + vec2(time * timer1,time * timer2);
+}
+
+uniform sampler2D rippleMap;
+uniform vec3 playerPos;
+
+varying vec3 worldPos;
+
+varying vec2 rippleMapUV;
+
+varying vec4 position;
+varying float linearDepth;
+
+uniform sampler2D normalMap;
+
+uniform float osg_SimulationTime;
+
+uniform float near;
+uniform float far;
+
+uniform float rainIntensity;
+uniform bool enableRainRipples;
+
+uniform vec2 screenRes;
+
+#define PER_PIXEL_LIGHTING 0
+
+#include "shadows_fragment.glsl"
+#include "lib/light/lighting.glsl"
+#include "fog.glsl"
+#include "lib/water/fresnel.glsl"
+#if @shader_ripples
+    #include "lib/water/rain_ripples.glsl"
+#else
+    #include "lib/water/rain_ripples_old.glsl"
+#endif
+#include "lib/view/depth.glsl"
+
+void main(void)
+{
+    vec2 UV = worldPos.xy / (8192.0*5.0) * 3.0;
+    UV.y *= -1.0;
+
+    float shadow = unshadowedLightRatio(linearDepth);
+
+    vec2 screenCoords = gl_FragCoord.xy / screenRes;
+
+    #define waterTimer osg_SimulationTime
+
+    vec3 normal0 = 2.0 * texture2D(normalMap,normalCoords(UV, 0.05, 0.04, waterTimer, -0.015, -0.005, vec3(0.0,0.0,0.0))).rgb - 1.0;
+    vec3 normal1 = 2.0 * texture2D(normalMap,normalCoords(UV, 0.1,  0.08, waterTimer,  0.02,   0.015, normal0)).rgb - 1.0;
+    vec3 normal2 = 2.0 * texture2D(normalMap,normalCoords(UV, 0.25, 0.07, waterTimer, -0.04,  -0.03,  normal1)).rgb - 1.0;
+    vec3 normal3 = 2.0 * texture2D(normalMap,normalCoords(UV, 0.5,  0.09, waterTimer,  0.03,   0.04,  normal2)).rgb - 1.0;
+    vec3 normal4 = 2.0 * texture2D(normalMap,normalCoords(UV, 1.0,  0.4,  waterTimer, -0.02,   0.1,   normal3)).rgb - 1.0;
+    vec3 normal5 = 2.0 * texture2D(normalMap,normalCoords(UV, 2.0,  0.7,  waterTimer,  0.1,   -0.06,  normal4)).rgb - 1.0;
+
+    vec4 rainRipple;
+
+    if (rainIntensity > 0.01 && enableRainRipples)
+        rainRipple = rainCombined(position.xy/1000.0, waterTimer) * clamp(rainIntensity, 0.0, 1.0);
+    else
+        rainRipple = vec4(0.0);
+
+    vec3 rippleAdd = rainRipple.xyz * 10.0;
+
+#if @shader_ripples
+    float distToCenter = length(rippleMapUV - vec2(0.5));
+    float blendClose = smoothstep(0.001, 0.02, distToCenter);
+    float blendFar = 1.0 - smoothstep(0.3, 0.4, distToCenter);
+    float distortionLevel = 2.0;
+    rippleAdd += distortionLevel * vec3(texture2D(rippleMap, rippleMapUV).ba * blendFar * blendClose, 0.0);
+#endif
+
+    vec2 bigWaves = vec2(BIG_WAVES_X,BIG_WAVES_Y);
+    vec2 midWaves = mix(vec2(MID_WAVES_X,MID_WAVES_Y),vec2(MID_WAVES_RAIN_X,MID_WAVES_RAIN_Y),rainIntensity);
+    vec2 smallWaves = mix(vec2(SMALL_WAVES_X,SMALL_WAVES_Y),vec2(SMALL_WAVES_RAIN_X,SMALL_WAVES_RAIN_Y),rainIntensity);
+    float bump = mix(BUMP,BUMP_RAIN,rainIntensity);
+
+    vec3 normal = (normal0 * bigWaves.x + normal1 * bigWaves.y + normal2 * midWaves.x +
+                   normal3 * midWaves.y + normal4 * smallWaves.x + normal5 * smallWaves.y + rippleAdd);
+    normal = normalize(vec3(-normal.x * bump, -normal.y * bump, normal.z));
+
+    vec3 lVec = normalize((gl_ModelViewMatrixInverse * vec4(lcalcPosition(0).xyz, 0.0)).xyz);
+    vec3 cameraPos = (gl_ModelViewMatrixInverse * vec4(0,0,0,1)).xyz;
+    vec3 vVec = normalize(position.xyz - cameraPos.xyz);
+
+    float sunFade = length(gl_LightModel.ambient.xyz);
+
+    // fresnel
+    float ior = (cameraPos.z>0.0)?(1.333/1.0):(1.0/1.333); // air to water; water to air
+    float fresnel = clamp(fresnel_dielectric(vVec, normal, ior), 0.0, 1.0);
+
+    float radialise = 1.0;
+
+#if @radialFog
+    float radialDepth = distance(position.xyz, cameraPos);
+    // TODO: Figure out how to properly radialise refraction depth and thus underwater fog
+    // while avoiding oddities when the water plane is close to the clipping plane
+    // radialise = radialDepth / linearDepth;
+#else
+    float radialDepth = 0.0;
+#endif
+
+    vec2 screenCoordsOffset = normal.xy * REFL_BUMP;
+#if REFRACTION
+    float depthSample = linearizeDepth(sampleRefractionDepthMap(screenCoords), near, far) * radialise;
+    float surfaceDepth = linearizeDepth(gl_FragCoord.z, near, far) * radialise;
+    float realWaterDepth = depthSample - surfaceDepth;  // undistorted water depth in view direction, independent of frustum
+    float depthSampleDistorted = linearizeDepth(sampleRefractionDepthMap(screenCoords - screenCoordsOffset), near, far) * radialise;
+    float waterDepthDistorted = max(depthSampleDistorted - surfaceDepth, 0.0);
+    screenCoordsOffset *= clamp(realWaterDepth / BUMP_SUPPRESS_DEPTH,0,1);
+#endif
+    // reflection
+    vec3 reflection = sampleReflectionMap(screenCoords + screenCoordsOffset).rgb;
+
+    // specular
+    float specular = pow(max(dot(reflect(vVec, normal), lVec), 0.0),SPEC_HARDNESS) * shadow;
+
+    vec3 waterColor = WATER_COLOR * sunFade;
+
+    vec4 sunSpec = lcalcSpecular(0);
+    // alpha component is sun visibility; we want to start fading lighting effects when visibility is low
+    sunSpec.a = min(1.0, sunSpec.a / SUN_SPEC_FADING_THRESHOLD);
+
+    // artificial specularity to make rain ripples more noticeable
+    vec3 skyColorEstimate = vec3(max(0.0, mix(-0.3, 1.0, sunFade)));
+    vec3 rainSpecular = abs(rainRipple.w)*mix(skyColorEstimate, vec3(1.0), 0.05)*0.5;
+
+#if REFRACTION
+    // no alpha here, so make sure raindrop ripple specularity gets properly subdued
+    rainSpecular *= clamp(fresnel*6.0 + specular * sunSpec.a, 0.0, 1.0);
+
+    // selectively nullify screenCoordsOffset to eliminate remaining shore artifacts, not needed for reflection
+    if (cameraPos.z > 0.0 && realWaterDepth <= VISIBILITY_DEPTH && waterDepthDistorted > VISIBILITY_DEPTH)
+        screenCoordsOffset = vec2(0.0);
+
+    depthSampleDistorted = linearizeDepth(sampleRefractionDepthMap(screenCoords - screenCoordsOffset), near, far) * radialise;
+    waterDepthDistorted = max(depthSampleDistorted - surfaceDepth, 0.0);
+
+    // fade to realWaterDepth at a distance to compensate for physically inaccurate depth calculation
+    waterDepthDistorted = mix(waterDepthDistorted, realWaterDepth, min(surfaceDepth / REFR_FOG_DISTORT_DISTANCE, 1.0));
+
+    // refraction
+    vec3 refraction = sampleRefractionMap(screenCoords - screenCoordsOffset).rgb;
+    vec3 rawRefraction = refraction;
+
+    // brighten up the refraction underwater
+    if (cameraPos.z < 0.0)
+        refraction = clamp(refraction * 1.5, 0.0, 1.0);
+    else
+    {
+        float depthCorrection = sqrt(1.0 + 4.0 * DEPTH_FADE * DEPTH_FADE);
+        float factor = DEPTH_FADE * DEPTH_FADE / (-0.5 * depthCorrection + 0.5 - waterDepthDistorted / VISIBILITY) + 0.5 * depthCorrection + 0.5;
+        refraction = mix(refraction, waterColor, clamp(factor, 0.0, 1.0));
+    }
+
+    // sunlight scattering
+    // normal for sunlight scattering
+    vec3 lNormal = (normal0 * bigWaves.x * 0.5 + normal1 * bigWaves.y * 0.5 + normal2 * midWaves.x * 0.2 +
+                    normal3 * midWaves.y * 0.2 + normal4 * smallWaves.x * 0.1 + normal5 * smallWaves.y * 0.1 + rippleAdd);
+    lNormal = normalize(vec3(-lNormal.x * bump, -lNormal.y * bump, lNormal.z));
+    float sunHeight = lVec.z;
+    vec3 scatterColour = mix(SCATTER_COLOUR*vec3(1.0,0.4,0.0), SCATTER_COLOUR, clamp(1.0-exp(-sunHeight*SUN_EXT), 0.0, 1.0));
+    vec3 lR = reflect(lVec, lNormal);
+    float lightScatter = clamp(dot(lVec,lNormal)*0.7+0.3, 0.0, 1.0) * clamp(dot(lR, vVec)*2.0-1.2, 0.0, 1.0) * SCATTER_AMOUNT * sunFade * sunSpec.a * clamp(1.0-exp(-sunHeight), 0.0, 1.0);
+    gl_FragData[0].xyz = mix(mix(refraction,  scatterColour,  lightScatter), reflection, fresnel) + specular * sunSpec.rgb * sunSpec.a + rainSpecular;
+    gl_FragData[0].w = 1.0;
+
+    // wobbly water: hard-fade into refraction texture at extremely low depth, with a wobble based on normal mapping
+    vec3 normalShoreRippleRain = texture2D(normalMap,normalCoords(UV, 2.0, 2.7, -1.0*waterTimer,  0.05,  0.1,  normal3)).rgb - 0.5
+                               + texture2D(normalMap,normalCoords(UV, 2.0, 2.7,      waterTimer,  0.04, -0.13, normal4)).rgb - 0.5;
+    float verticalWaterDepth = realWaterDepth * mix(abs(vVec.z), 1.0, 0.2); // an estimate
+    float shoreOffset = verticalWaterDepth - (normal2.r + mix(0.0, normalShoreRippleRain.r, rainIntensity) + 0.15)*8.0;
+    float fuzzFactor = min(1.0, 1000.0/surfaceDepth) * mix(abs(vVec.z), 1.0, 0.2);
+    shoreOffset *= fuzzFactor;
+    shoreOffset = clamp(mix(shoreOffset, 1.0, clamp(linearDepth / WOBBLY_SHORE_FADE_DISTANCE, 0.0, 1.0)), 0.0, 1.0);
+    gl_FragData[0].xyz = mix(rawRefraction, gl_FragData[0].xyz, shoreOffset);
+#else
+    gl_FragData[0].xyz = mix(reflection,  waterColor,  (1.0-fresnel)*0.5) + specular * sunSpec.rgb  * sunSpec.a + rainSpecular;
+    gl_FragData[0].w = clamp(fresnel*6.0 + specular * sunSpec.a, 0.0, 1.0);     //clamp(fresnel*2.0 + specular * gl_LightSource[0].specular.a, 0.0, 1.0);
+#endif
+
+    gl_FragData[0] = applyFogAtDist(gl_FragData[0], radialDepth, linearDepth, far);
+
+#if !@disableNormals
+    gl_FragData[1].rgb = normalize(gl_NormalMatrix * normal) * 0.5 + 0.5;
+#endif
+
+    applyShadowDebugOverlay();
+}
diff --git a/files/shaders/compatibility/water.vert b/files/shaders/compatibility/water.vert
old mode 100644
new mode 100755
diff --git a/files/shaders/core/gui.frag b/files/shaders/core/gui.frag
old mode 100644
new mode 100755
diff --git a/files/shaders/core/gui.vert b/files/shaders/core/gui.vert
old mode 100644
new mode 100755
diff --git a/files/shaders/core/ripples_blobber.comp b/files/shaders/core/ripples_blobber.comp
old mode 100644
new mode 100755
diff --git a/files/shaders/core/ripples_simulate.comp b/files/shaders/core/ripples_simulate.comp
old mode 100644
new mode 100755
diff --git a/files/shaders/lib/core/fragment.glsl b/files/shaders/lib/core/fragment.glsl
old mode 100644
new mode 100755
diff --git a/files/shaders/lib/core/fragment_multiview.glsl b/files/shaders/lib/core/fragment_multiview.glsl
old mode 100644
new mode 100755
diff --git a/files/shaders/lib/core/vertex.glsl b/files/shaders/lib/core/vertex.glsl
old mode 100644
new mode 100755
diff --git a/files/shaders/lib/core/vertex.h.glsl b/files/shaders/lib/core/vertex.h.glsl
old mode 100644
new mode 100755
index 6e22f6deb15..c8a1080574d
--- a/files/shaders/lib/core/vertex.h.glsl
+++ b/files/shaders/lib/core/vertex.h.glsl
@@ -1,6 +1,16 @@
-@link "lib/core/vertex.glsl" if !@useOVR_multiview
-@link "lib/core/vertex_multiview.glsl" if @useOVR_multiview
+uniform mat4 projectionMatrix;
 
-vec4 modelToClip(vec4 pos);
-vec4 modelToView(vec4 pos);
-vec4 viewToClip(vec4 pos);
+vec4 modelToView(vec4 pos)
+{
+    return gl_ModelViewMatrix * pos;
+}
+
+vec4 modelToClip(vec4 pos)
+{
+    return projectionMatrix * modelToView(pos);
+}
+
+vec4 viewToClip(vec4 pos)
+{
+    return projectionMatrix * pos;
+}
diff --git a/files/shaders/lib/core/vertex_multiview.glsl b/files/shaders/lib/core/vertex_multiview.glsl
old mode 100644
new mode 100755
diff --git a/files/shaders/lib/light/lighting.glsl b/files/shaders/lib/light/lighting.glsl
old mode 100644
new mode 100755
diff --git a/files/shaders/lib/light/lighting_util.glsl b/files/shaders/lib/light/lighting_util.glsl
old mode 100644
new mode 100755
diff --git a/files/shaders/lib/luminance/constants.glsl b/files/shaders/lib/luminance/constants.glsl
old mode 100644
new mode 100755
diff --git a/files/shaders/lib/material/alpha.glsl b/files/shaders/lib/material/alpha.glsl
old mode 100644
new mode 100755
diff --git a/files/shaders/lib/material/parallax.glsl b/files/shaders/lib/material/parallax.glsl
old mode 100644
new mode 100755
diff --git a/files/shaders/lib/particle/occlusion.glsl b/files/shaders/lib/particle/occlusion.glsl
old mode 100644
new mode 100755
diff --git a/files/shaders/lib/particle/soft.glsl b/files/shaders/lib/particle/soft.glsl
old mode 100644
new mode 100755
diff --git a/files/shaders/lib/sky/passes.glsl b/files/shaders/lib/sky/passes.glsl
old mode 100644
new mode 100755
diff --git a/files/shaders/lib/util/coordinates.glsl b/files/shaders/lib/util/coordinates.glsl
old mode 100644
new mode 100755
diff --git a/files/shaders/lib/util/distortion.glsl b/files/shaders/lib/util/distortion.glsl
old mode 100644
new mode 100755
diff --git a/files/shaders/lib/util/quickstep.glsl b/files/shaders/lib/util/quickstep.glsl
old mode 100644
new mode 100755
diff --git a/files/shaders/lib/view/depth.glsl b/files/shaders/lib/view/depth.glsl
old mode 100644
new mode 100755
diff --git a/files/shaders/lib/water/fresnel.glsl b/files/shaders/lib/water/fresnel.glsl
old mode 100644
new mode 100755
diff --git a/files/shaders/lib/water/rain_ripples.glsl b/files/shaders/lib/water/rain_ripples.glsl
old mode 100644
new mode 100755
diff --git a/files/shaders/lib/water/rain_ripples_old.glsl b/files/shaders/lib/water/rain_ripples_old.glsl
new file mode 100755
index 00000000000..4e5f85017be
--- /dev/null
+++ b/files/shaders/lib/water/rain_ripples_old.glsl
@@ -0,0 +1,126 @@
+#ifndef LIB_WATER_RIPPLES
+#define LIB_WATER_RIPPLES
+
+#define RAIN_RIPPLE_DETAIL @rain_ripple_detail
+
+const float RAIN_RIPPLE_GAPS = 10.0;
+const float RAIN_RIPPLE_RADIUS = 0.2;
+
+float scramble(float x, float z)
+{
+    return fract(pow(fract(x)*3.0+1.0, z));
+}
+
+vec2 randOffset(vec2 c, float time)
+{
+  time = fract(time/1000.0);
+  c = vec2(c.x * c.y /  8.0 + c.y * 0.3 + c.x * 0.2,
+           c.x * c.y / 14.0 + c.y * 0.5 + c.x * 0.7);
+  c.x *= scramble(scramble(time + c.x/1000.0, 4.0), 3.0) + 1.0;
+  c.y *= scramble(scramble(time + c.y/1000.0, 3.5), 3.0) + 1.0;
+  return fract(c);
+}
+
+float randPhase(vec2 c)
+{
+  return fract((c.x * c.y) /  (c.x + c.y + 0.1));
+}
+
+float blip(float x)
+{
+  x = max(0.0, 1.0-x*x);
+  return x*x*x;
+}
+
+float blipDerivative(float x)
+{
+  x = clamp(x, -1.0, 1.0);
+  float n = x*x-1.0;
+  return -6.0*x*n*n;
+}
+
+const float RAIN_RING_TIME_OFFSET = 1.0/6.0;
+
+vec4 circle(vec2 coords, vec2 corner, float adjusted_time)
+{
+  vec2 center = vec2(0.5,0.5) + (0.5 - RAIN_RIPPLE_RADIUS) * (2.0 * randOffset(corner, floor(adjusted_time)) - 1.0);
+  float phase = fract(adjusted_time);
+  vec2 toCenter = coords - center;
+
+  float r = RAIN_RIPPLE_RADIUS;
+  float d = length(toCenter);
+  float ringfollower = (phase-d/r)/RAIN_RING_TIME_OFFSET-1.0; // -1.0 ~ +1.0 cover the breadth of the ripple's ring
+
+#if RAIN_RIPPLE_DETAIL > 0
+// normal mapped ripples
+  if(ringfollower < -1.0 || ringfollower > 1.0)
+    return vec4(0.0);
+
+  if(d > 1.0) // normalize center direction vector, but not for near-center ripples
+    toCenter /= d;
+
+  float height = blip(ringfollower*2.0+0.5); // brighten up outer edge of ring; for fake specularity
+  float range_limit = blip(min(0.0, ringfollower));
+  float energy = 1.0-phase;
+
+  vec2 normal2d = -toCenter*blipDerivative(ringfollower)*5.0;
+  vec3 normal = vec3(normal2d, 0.5);
+  vec4 ret = vec4(normal, height);
+  ret.xyw *= energy*energy;
+  // do energy adjustment here rather than later, so that we can use the w component for fake specularity
+  ret.xyz = normalize(ret.xyz) * energy*range_limit;
+  ret.z *= range_limit;
+  return ret;
+#else
+// ring-only ripples
+  if(ringfollower < -1.0 || ringfollower > 0.5)
+    return vec4(0.0);
+
+  float energy = 1.0-phase;
+  float height = blip(ringfollower*2.0+0.5)*energy*energy; // fake specularity
+
+  return vec4(0.0, 0.0, 0.0, height);
+#endif
+}
+vec4 rain(vec2 uv, float time)
+{
+  uv *= RAIN_RIPPLE_GAPS;
+  vec2 f_part = fract(uv);
+  vec2 i_part = floor(uv);
+  float adjusted_time = time * 1.2 + randPhase(i_part);
+#if RAIN_RIPPLE_DETAIL > 0
+  vec4 a = circle(f_part, i_part, adjusted_time);
+  vec4 b = circle(f_part, i_part, adjusted_time - RAIN_RING_TIME_OFFSET);
+  vec4 c = circle(f_part, i_part, adjusted_time - RAIN_RING_TIME_OFFSET*2.0);
+  vec4 d = circle(f_part, i_part, adjusted_time - RAIN_RING_TIME_OFFSET*3.0);
+  vec4 ret;
+  ret.xy = a.xy - b.xy/2.0 + c.xy/4.0 - d.xy/8.0;
+  // z should always point up
+  ret.z  = a.z  + b.z /2.0 + c.z /4.0 + d.z /8.0;
+  //ret.xyz *= 1.5;
+  // fake specularity looks weird if we use every single ring, also if the inner rings are too bright 
+  ret.w  = (a.w + c.w /8.0)*1.5;
+  return ret;
+#else
+  return circle(f_part, i_part, adjusted_time) * 1.5;
+#endif
+}
+
+vec2 complex_mult(vec2 a, vec2 b)
+{
+    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);
+}
+vec4 rainCombined(vec2 uv, float time) // returns ripple normal in xyz and fake specularity in w
+{
+  return
+    rain(uv, time)
+  + rain(complex_mult(uv, vec2(0.4, 0.7)) + vec2(1.2, 3.0),time)
+    #if RAIN_RIPPLE_DETAIL == 2
+      + rain(uv * 0.75 + vec2( 3.7,18.9),time)
+      + rain(uv * 0.9  + vec2( 5.7,30.1),time)
+      + rain(uv * 1.0  + vec2(10.5 ,5.7),time)
+    #endif
+  ;
+}
+
+#endif
diff --git a/files/shaders/lib/water/ripples.glsl b/files/shaders/lib/water/ripples.glsl
old mode 100644
new mode 100755
